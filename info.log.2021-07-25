2021-07-25 14:51:18  [ main:0 ] - [ INFO ]  parseC:\Users\ding7\Desktop\newtest\alias.cpp
  2021-07-25 14:51:19  [ main:417 ] - [ INFO ]  parseC:\Users\ding7\Desktop\newtest\template.cpp
  2021-07-25 14:51:19  [ main:462 ] - [ INFO ]  parseC:\Users\ding7\Desktop\newtest\using.cpp
  2021-07-25 14:51:19  [ main:470 ] - [ INFO ]  parseC:\Users\ding7\Desktop\newtest\Visibility Label.cpp
  2021-07-25 14:51:19  [ main:476 ] - [ INFO ]  start dependency
  2021-07-25 14:51:19  [ main:479 ] - [ INFO ]  includenum:0
  2021-07-25 14:51:19  [ main:479 ] - [ INFO ]  definenum:0
  2021-07-25 14:51:19  [ main:480 ] - [ INFO ]  callnum:1
  2021-07-25 14:51:19  [ main:480 ] - [ INFO ]  returnnum:3
  2021-07-25 14:51:19  [ main:480 ] - [ INFO ]  parameternum:6
  2021-07-25 14:51:19  [ main:488 ] - [ INFO ]  extendnum:0
  2021-07-25 14:51:19  [ main:488 ] - [ INFO ]  overridenum:0
  2021-07-25 14:51:19  [ main:540 ] - [ INFO ]  Process finish!
  2021-07-25 14:51:49  [ main:0 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\phantompy.cpp
  2021-07-25 14:51:50  [ main:463 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 14:51:50  [ main:516 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\frame.hpp:11
  2021-07-25 14:51:50  [ main:519 ] - [ ERROR ]  parsing error 
private slots:
    void loadFinished(bool ok);
  2021-07-25 14:51:50  [ main:519 ] - [ ERROR ]  warning: parse error private slots:
    void loadFinished(bool ok);Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\frame.hpp:38
  2021-07-25 14:51:50  [ main:522 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 14:51:50  [ main:522 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\image.hpp:9
  2021-07-25 14:51:50  [ main:539 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 14:51:50  [ main:539 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\timeout.hpp:9
  2021-07-25 14:51:50  [ main:540 ] - [ ERROR ]  parsing error 
private slots:
    void handleTimeout();
  2021-07-25 14:51:50  [ main:540 ] - [ ERROR ]  warning: parse error private slots:
    void handleTimeout();Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\timeout.hpp:22
  2021-07-25 14:51:50  [ main:549 ] - [ ERROR ]  parsing error 
QT_BEGIN_NAMESPACE
  2021-07-25 14:51:50  [ main:550 ] - [ ERROR ]  warning: parse error QT_BEGIN_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\parser.h:26
  2021-07-25 14:51:50  [ main:550 ] - [ ERROR ]  parsing error 
QT_END_NAMESPACE
  2021-07-25 14:51:50  [ main:550 ] - [ ERROR ]  warning: parse error QT_END_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\parser.h:29
  2021-07-25 14:51:50  [ main:551 ] - [ ERROR ]  parsing error 
class QJSON_EXPORT Parser
  {
    public:
      Parser();
      ~Parser();

      /**
      * Read JSON string from the I/O Device and converts it to a QVariant object
      * @param io Input output device
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true.
      * @returns a QVariant object generated from the JSON string
      */
      QVariant parse(QIODevice* io, bool* ok = 0);

      /**
      * This is a method provided for convenience.
      * @param jsonData data containing the JSON object representation
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true.
      * @returns a QVariant object generated from the JSON string
      * @sa errorString
      * @sa errorLine
      */
      QVariant parse(const QByteArray& jsonData, bool* ok = 0);

      /**
      * This method returns the error message
      * @returns a QString object containing the error message of the last parse operation
      * @sa errorLine
      */
      QString errorString() const;

      /**
      * This method returns line number where the error occurred
      * @returns the line number where the error occurred
      * @sa errorString
      */
      int errorLine() const;

      /**
       * Sets whether special numbers (Infinity, -Infinity, NaN) are allowed as an extension to
       * the standard
       * @param  allowSpecialNumbers new value of whether special numbers are allowed
       * @sa specialNumbersAllowed
       */
      void allowSpecialNumbers(bool allowSpecialNumbers);

      /**
       * @returns whether special numbers (Infinity, -Infinity, NaN) are allowed
       * @sa allowSpecialNumbers
       */
      bool specialNumbersAllowed() const;

    private:
      Q_DISABLE_COPY(Parser)
      ParserPrivate* const d;
  };
  2021-07-25 14:51:50  [ main:551 ] - [ ERROR ]  warning: parse error class QJSON_EXPORT Parser
  {
    public:
      Parser();
      ~Parser();

      /**
      * Read JSON string from the I/O Device and converts it to a QVariant object
      * @param io Input output device
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true.
      * @returns a QVariant object generated from the JSON string
      */
      QVariant parse(QIODevice* io, bool* ok = 0);

      /**
      * This is a method provided for convenience.
      * @param jsonData data containing the JSON object representation
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true.
      * @returns a QVariant object generated from the JSON string
      * @sa errorString
      * @sa errorLine
      */
      QVariant parse(const QByteArray& jsonData, bool* ok = 0);

      /**
      * This method returns the error message
      * @returns a QString object containing the error message of the last parse operation
      * @sa errorLine
      */
      QString errorString() const;

      /**
      * This method returns line number where the error occurred
      * @returns the line number where the error occurred
      * @sa errorString
      */
      int errorLine() const;

      /**
       * Sets whether special numbers (Infinity, -Infinity, NaN) are allowed as an extension to
       * the standard
       * @param  allowSpecialNumbers new value of whether special numbers are allowed
       * @sa specialNumbersAllowed
       */
      void allowSpecialNumbers(bool allowSpecialNumbers);

      /**
       * @returns whether special numbers (Infinity, -Infinity, NaN) are allowed
       * @sa allowSpecialNumbers
       */
      bool specialNumbersAllowed() const;

    private:
      Q_DISABLE_COPY(Parser)
      ParserPrivate* const d;
  };Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\parser.h:41
  2021-07-25 14:51:50  [ main:567 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 14:51:50  [ main:567 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\networkmanager.hpp:11
  2021-07-25 14:51:50  [ main:567 ] - [ ERROR ]  parsing error 
signals:
    void replyReceived(const QVariantMap &reply);
  2021-07-25 14:51:50  [ main:567 ] - [ ERROR ]  warning: parse error signals:
    void replyReceived(const QVariantMap &reply);Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\networkmanager.hpp:29
  2021-07-25 14:51:50  [ main:568 ] - [ ERROR ]  parsing error 
private slots:
    void provideAuthentication(QNetworkReply *reply, QAuthenticator *authenticator);
  2021-07-25 14:51:50  [ main:568 ] - [ ERROR ]  warning: parse error private slots:
    void provideAuthentication(QNetworkReply *reply, QAuthenticator *authenticator);Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\networkmanager.hpp:35
  2021-07-25 14:51:50  [ main:572 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 14:51:50  [ main:572 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\networkmanagerproxy.hpp:10
  2021-07-25 14:51:50  [ main:572 ] - [ ERROR ]  parsing error 
private slots:
    void finished();
  2021-07-25 14:51:50  [ main:573 ] - [ ERROR ]  warning: parse error private slots:
    void finished();Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\networkmanagerproxy.hpp:25
  2021-07-25 14:51:50  [ main:576 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 14:51:50  [ main:576 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\page.hpp:19
  2021-07-25 14:51:50  [ main:577 ] - [ ERROR ]  parsing error 
private slots:
    void loadFinished(bool ok);
  2021-07-25 14:51:50  [ main:577 ] - [ ERROR ]  warning: parse error private slots:
    void loadFinished(bool ok);Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\page.hpp:57
  2021-07-25 14:51:50  [ main:581 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 14:51:50  [ main:581 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\eventprocessor.hpp:9
  2021-07-25 14:51:50  [ main:581 ] - [ ERROR ]  parsing error 
private slots:
    void handleTimeout();
  2021-07-25 14:51:50  [ main:581 ] - [ ERROR ]  warning: parse error private slots:
    void handleTimeout();Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\eventprocessor.hpp:23
  2021-07-25 14:51:50  [ main:585 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 14:51:50  [ main:585 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\webelement.hpp:11
  2021-07-25 14:51:50  [ main:587 ] - [ ERROR ]  parsing error 
private slots:
    void loadFinished(bool ok);
  2021-07-25 14:51:50  [ main:587 ] - [ ERROR ]  warning: parse error private slots:
    void loadFinished(bool ok);Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\webelement.hpp:69
  2021-07-25 14:51:50  [ main:590 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 14:51:50  [ main:591 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\webelementcollection.hpp:11
  2021-07-25 14:51:50  [ main:609 ] - [ ERROR ]  parsing error 
QT_BEGIN_NAMESPACE
  2021-07-25 14:51:50  [ main:609 ] - [ ERROR ]  warning: parse error QT_BEGIN_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializer.h:26
  2021-07-25 14:51:50  [ main:609 ] - [ ERROR ]  parsing error 
QT_END_NAMESPACE
  2021-07-25 14:51:50  [ main:610 ] - [ ERROR ]  warning: parse error QT_END_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializer.h:30
  2021-07-25 14:51:50  [ main:610 ] - [ ERROR ]  parsing error 
class QJSON_EXPORT Serializer {
  public:
    Serializer();
    ~Serializer();

     /**
      * This method generates a textual JSON representation and outputs it to the
      * passed in I/O Device.
      * @param variant The JSON document in its in-memory representation as generated by the
      * parser.
      * @param out Input output device
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true
      */
    void serialize( const QVariant& variant, QIODevice* out, bool* ok);

    /**
      * This is a method provided for convenience. It turns the passed in in-memory
      * representation of the JSON document into a textual one, which is returned.
      * If the returned string is empty, the document was empty. If it was null, there
      * was a parsing error.
      *
      * @param variant The JSON document in its in-memory representation as generated by the
      * parser.
      *
      * \deprecated This method is going to be removed with the next major release of QJson.
      */
    QByteArray serialize( const QVariant& variant);

    /**
      * This is a method provided for convenience. It turns the passed in in-memory
      * representation of the JSON document into a textual one, which is returned.
      * If the returned string is empty, the document was empty. If it was null, there
      * was a parsing error.
      *
      * @param variant The JSON document in its in-memory representation as generated by the
      * parser.
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true
      */
    QByteArray serialize( const QVariant& variant, bool *ok);

    /**
     * Allow or disallow writing of NaN and/or Infinity (as an extension to QJson)
     */
    void allowSpecialNumbers(bool allow);

    /**
     * Is Nan and/or Infinity allowed?
     */
    bool specialNumbersAllowed() const;

    /**
     * set output indentation mode as defined in QJson::IndentMode
     */
    void setIndentMode(IndentMode mode = QJson::IndentNone);


    /**
    * set double precision used while converting Double
    * \sa QByteArray::number
    */
    void setDoublePrecision(int precision);

    /**
     * Returns one of the indentation modes defined in QJson::IndentMode
     */
    IndentMode indentMode() const;

    /**
     * Returns the error message
     */
    QString errorMessage() const;

  private:
    Q_DISABLE_COPY(Serializer)
    class SerializerPrivate;
    SerializerPrivate* const d;
  };
  2021-07-25 14:51:50  [ main:610 ] - [ ERROR ]  warning: parse error class QJSON_EXPORT Serializer {
  public:
    Serializer();
    ~Serializer();

     /**
      * This method generates a textual JSON representation and outputs it to the
      * passed in I/O Device.
      * @param variant The JSON document in its in-memory representation as generated by the
      * parser.
      * @param out Input output device
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true
      */
    void serialize( const QVariant& variant, QIODevice* out, bool* ok);

    /**
      * This is a method provided for convenience. It turns the passed in in-memory
      * representation of the JSON document into a textual one, which is returned.
      * If the returned string is empty, the document was empty. If it was null, there
      * was a parsing error.
      *
      * @param variant The JSON document in its in-memory representation as generated by the
      * parser.
      *
      * \deprecated This method is going to be removed with the next major release of QJson.
      */
    QByteArray serialize( const QVariant& variant);

    /**
      * This is a method provided for convenience. It turns the passed in in-memory
      * representation of the JSON document into a textual one, which is returned.
      * If the returned string is empty, the document was empty. If it was null, there
      * was a parsing error.
      *
      * @param variant The JSON document in its in-memory representation as generated by the
      * parser.
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true
      */
    QByteArray serialize( const QVariant& variant, bool *ok);

    /**
     * Allow or disallow writing of NaN and/or Infinity (as an extension to QJson)
     */
    void allowSpecialNumbers(bool allow);

    /**
     * Is Nan and/or Infinity allowed?
     */
    bool specialNumbersAllowed() const;

    /**
     * set output indentation mode as defined in QJson::IndentMode
     */
    void setIndentMode(IndentMode mode = QJson::IndentNone);


    /**
    * set double precision used while converting Double
    * \sa QByteArray::number
    */
    void setDoublePrecision(int precision);

    /**
     * Returns one of the indentation modes defined in QJson::IndentMode
     */
    IndentMode indentMode() const;

    /**
     * Returns the error message
     */
    QString errorMessage() const;

  private:
    Q_DISABLE_COPY(Serializer)
    class SerializerPrivate;
    SerializerPrivate* const d;
  };Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializer.h:112
  2021-07-25 14:51:50  [ main:614 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 14:51:50  [ main:614 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\cookiejar.hpp:14
  2021-07-25 14:51:50  [ main:680 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\phantompy.hpp
  2021-07-25 14:51:50  [ main:681 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\context.cpp
  2021-07-25 14:51:50  [ main:708 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\context.hpp
  2021-07-25 14:51:50  [ main:709 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\cookiejar.cpp
  2021-07-25 14:51:50  [ main:730 ] - [ ERROR ]  warning: parse error foreach(QNetworkCookie n_cookie, cookiesForUrl(QUrl(url))) {
        cookie["name"] = QString::fromUtf8(n_cookie.name());
        cookie["value"] = QString::fromUtf8(n_cookie.value());
        cookie["domain"] = n_cookie.domain();
        cookie["path"] = n_cookie.path();
        cookie["expires"] = n_cookie.expirationDate().toString(Qt::ISODate);

        cookiesList.append(cookie);
    }Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\cookiejar.cpp:112
  2021-07-25 14:51:50  [ main:730 ] - [ ERROR ]  warning: parse error foreach(QNetworkCookie n_cookie, allCookies()) {
        cookie["name"] = QString::fromUtf8(n_cookie.name());
        cookie["value"] = QString::fromUtf8(n_cookie.value());
        cookie["domain"] = n_cookie.domain();
        cookie["path"] = n_cookie.path();
        cookie["expires"] = n_cookie.expirationDate().toString(Qt::ISODate);

        cookiesList.append(cookie);
    }Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\cookiejar.cpp:129
  2021-07-25 14:51:50  [ main:731 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\cookiejar.hpp
  2021-07-25 14:51:50  [ main:732 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\eventprocessor.cpp
  2021-07-25 14:51:50  [ main:740 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\eventprocessor.hpp
  2021-07-25 14:51:50  [ main:741 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\frame.cpp
  2021-07-25 14:51:50  [ main:777 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\frame.hpp
  2021-07-25 14:51:50  [ main:779 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\image.cpp
  2021-07-25 14:51:50  [ main:787 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\image.hpp
  2021-07-25 14:51:50  [ main:788 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\networkmanager.cpp
  2021-07-25 14:51:50  [ main:796 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 14:51:50  [ main:796 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\networktimeout.hpp:10
  2021-07-25 14:51:50  [ main:804 ] - [ ERROR ]  warning: parse error foreach (QByteArray headerName, reply->rawHeaderList()) {
        QVariantMap header;
        header["name"] = QString::fromUtf8(headerName);
        header["value"] = QString::fromUtf8(reply->rawHeader(headerName));

        headers.append(header);
    }Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\networkmanager.cpp:69
  2021-07-25 14:51:50  [ main:806 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\networkmanager.hpp
  2021-07-25 14:51:50  [ main:807 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\networkmanagerproxy.cpp
  2021-07-25 14:51:50  [ main:814 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\networkmanagerproxy.hpp
  2021-07-25 14:51:50  [ main:814 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\networktimeout.cpp
  2021-07-25 14:51:50  [ main:818 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\networktimeout.hpp
  2021-07-25 14:51:50  [ main:819 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\page.cpp
  2021-07-25 14:51:50  [ main:830 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\page.hpp
  2021-07-25 14:51:50  [ main:830 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\timeout.cpp
  2021-07-25 14:51:50  [ main:835 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\timeout.hpp
  2021-07-25 14:51:50  [ main:836 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\webelement.cpp
  2021-07-25 14:51:50  [ main:848 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\webelement.hpp
  2021-07-25 14:51:50  [ main:849 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\webelementcollection.cpp
  2021-07-25 14:51:50  [ main:854 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\webelementcollection.hpp
  2021-07-25 14:51:50  [ main:855 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\FlexLexer.h
  2021-07-25 14:51:50  [ main:868 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\json_parser.cc
  2021-07-25 14:51:50  [ main:946 ] - [ ERROR ]  parsing error 
Q_DECLARE_METATYPE(QVector<QVariant>*)
  Q_DECLARE_METATYPE(QVariantMap*)


/* Line 33 of lalr1.cc  */
#line 72 "json_parser.hh"


#include <string>
#include <iostream>
#include "stack.hh"
#include "location.hh"

/* Enabling traces.  */
#ifndef YYDEBUG
# define YYDEBUG 1
#endif


namespace yy {
/* Line 33 of lalr1.cc  */
#line 88 "json_parser.hh"

  /// A Bison parser.
  class json_parser
  {
  public:
    /// Symbol semantic values.
#ifndef YYSTYPE
    typedef int semantic_type;
#else
    typedef YYSTYPE semantic_type;
#endif
    /// Symbol locations.
    typedef location location_type;
    /// Tokens.
    struct token
    {
      /* Tokens.  */
   enum yytokentype {
     END = 0,
     CURLY_BRACKET_OPEN = 1,
     CURLY_BRACKET_CLOSE = 2,
     SQUARE_BRACKET_OPEN = 3,
     SQUARE_BRACKET_CLOSE = 4,
     COLON = 5,
     COMMA = 6,
     NUMBER = 7,
     TRUE_VAL = 8,
     FALSE_VAL = 9,
     NULL_VAL = 10,
     STRING = 11,
     INVALID = 12
   };

    };
    /// Token type.
    typedef token::yytokentype token_type;

    /// Build a parser object.
    json_parser (QJson::ParserPrivate* driver_yyarg);
    virtual ~json_parser ();

    /// Parse.
    /// \returns  0 iff parsing succeeded.
    virtual int parse ();

#if YYDEBUG
    /// The current debugging stream.
    std::ostream& debug_stream () const;
    /// Set the current debugging stream.
    void set_debug_stream (std::ostream &);

    /// Type for debugging levels.
    typedef int debug_level_type;
    /// The current debugging level.
    debug_level_type debug_level () const;
    /// Set the current debugging level.
    void set_debug_level (debug_level_type l);
#endif

  private:
    /// Report a syntax error.
    /// \param loc    where the syntax error is found.
    /// \param msg    a description of the syntax error.
    virtual void error (const location_type& loc, const std::string& msg);

    /// Generate an error message.
    /// \param state   the state where the error occurred.
    /// \param tok     the lookahead token.
    virtual std::string yysyntax_error_ (int yystate, int tok);

#if YYDEBUG
    /// \brief Report a symbol value on the debug stream.
    /// \param yytype       The token type.
    /// \param yyvaluep     Its semantic value.
    /// \param yylocationp  Its location.
    virtual void yy_symbol_value_print_ (int yytype,
					 const semantic_type* yyvaluep,
					 const location_type* yylocationp);
    /// \brief Report a symbol on the debug stream.
    /// \param yytype       The token type.
    /// \param yyvaluep     Its semantic value.
    /// \param yylocationp  Its location.
    virtual void yy_symbol_print_ (int yytype,
				   const semantic_type* yyvaluep,
				   const location_type* yylocationp);
#endif


    /// State numbers.
    typedef int state_type;
    /// State stack type.
    typedef stack<state_type>    state_stack_type;
    /// Semantic value stack type.
    typedef stack<semantic_type> semantic_stack_type;
    /// location stack type.
    typedef stack<location_type> location_stack_type;

    /// The state stack.
    state_stack_type yystate_stack_;
    /// The semantic value stack.
    semantic_stack_type yysemantic_stack_;
    /// The location stack.
    location_stack_type yylocation_stack_;

    /// Whether the given \c yypact_ value indicates a defaulted state.
    /// \param yyvalue   the value to check
    static bool yy_pact_value_is_default_ (int yyvalue);

    /// Whether the given \c yytable_ value indicates a syntax error.
    /// \param yyvalue   the value to check
    static bool yy_table_value_is_error_ (int yyvalue);

    /// Internal symbol numbers.
    typedef unsigned char token_number_type;
    /* Tables.  */
    /// For a state, the index in \a yytable_ of its portion.
    static const signed char yypact_[];
    static const signed char yypact_ninf_;

    /// For a state, default reduction number.
    /// Unless\a  yytable_ specifies something else to do.
    /// Zero means the default is an error.
    static const unsigned char yydefact_[];

    static const signed char yypgoto_[];
    static const signed char yydefgoto_[];

    /// What to do in a state.
    /// \a yytable_[yypact_[s]]: what to do in state \a s.
    /// - if positive, shift that token.
    /// - if negative, reduce the rule which number is the opposite.
    /// - if zero, do what YYDEFACT says.
    static const unsigned char yytable_[];
    static const signed char yytable_ninf_;

    static const signed char yycheck_[];

    /// For a state, its accessing symbol.
    static const unsigned char yystos_[];

    /// For a rule, its LHS.
    static const unsigned char yyr1_[];
    /// For a rule, its RHS length.
    static const unsigned char yyr2_[]; 

    /// Convert the symbol name \a n to a form suitable for a diagnostic.
    static std::string yytnamerr_ (const char *n);


    /// For a symbol, its name in clear.
    static const char* const yytname_[];
#if YYDEBUG
    /// A type to store symbol numbers and -1.
    typedef signed char rhs_number_type;
    /// A `-1'-separated list of the rules' RHS.
    static const rhs_number_type yyrhs_[];
    /// For each rule, the index of the first RHS symbol in \a yyrhs_.
    static const unsigned char yyprhs_[];
    /// For each rule, its source line number.
    static const unsigned char yyrline_[];
    /// For each scanner token number, its symbol number.
    static const unsigned short int yytoken_number_[];
    /// Report on the debug stream that the rule \a r is going to be reduced.
    virtual void yy_reduce_print_ (int r);
    /// Print the state stack on the debug stream.
    virtual void yystack_print_ ();

    /* Debugging.  */
    int yydebug_;
    std::ostream* yycdebug_;
#endif

    /// Convert a scanner token number \a t to a symbol number.
    token_number_type yytranslate_ (int t);

    /// \brief Reclaim the memory associated to a symbol.
    /// \param yymsg        Why this token is reclaimed.
    ///                     If null, do not display the symbol, just free it.
    /// \param yytype       The symbol type.
    /// \param yyvaluep     Its semantic value.
    /// \param yylocationp  Its location.
    inline void yydestruct_ (const char* yymsg,
			     int yytype,
			     semantic_type* yyvaluep,
			     location_type* yylocationp);

    /// Pop \a n symbols the three stacks.
    inline void yypop_ (unsigned int n = 1);

    /* Constants.  */
    static const int yyeof_;
    /* LAST_ -- Last index in TABLE_.  */
    static const int yylast_;
    static const int yynnts_;
    static const int yyempty_;
    static const int yyfinal_;
    static const int yyterror_;
    static const int yyerrcode_;
    static const int yyntokens_;
    static const unsigned int yyuser_token_number_max_;
    static const token_number_type yyundef_token_;

    /* User arguments.  */
    QJson::ParserPrivate* driver;
  };

}
  2021-07-25 14:51:50  [ main:946 ] - [ ERROR ]  warning: parse error Q_DECLARE_METATYPE(QVector<QVariant>*)
  Q_DECLARE_METATYPE(QVariantMap*)


/* Line 33 of lalr1.cc  */
#line 72 "json_parser.hh"


#include <string>
#include <iostream>
#include "stack.hh"
#include "location.hh"

/* Enabling traces.  */
#ifndef YYDEBUG
# define YYDEBUG 1
#endif


namespace yy {
/* Line 33 of lalr1.cc  */
#line 88 "json_parser.hh"

  /// A Bison parser.
  class json_parser
  {
  public:
    /// Symbol semantic values.
#ifndef YYSTYPE
    typedef int semantic_type;
#else
    typedef YYSTYPE semantic_type;
#endif
    /// Symbol locations.
    typedef location location_type;
    /// Tokens.
    struct token
    {
      /* Tokens.  */
   enum yytokentype {
     END = 0,
     CURLY_BRACKET_OPEN = 1,
     CURLY_BRACKET_CLOSE = 2,
     SQUARE_BRACKET_OPEN = 3,
     SQUARE_BRACKET_CLOSE = 4,
     COLON = 5,
     COMMA = 6,
     NUMBER = 7,
     TRUE_VAL = 8,
     FALSE_VAL = 9,
     NULL_VAL = 10,
     STRING = 11,
     INVALID = 12
   };

    };
    /// Token type.
    typedef token::yytokentype token_type;

    /// Build a parser object.
    json_parser (QJson::ParserPrivate* driver_yyarg);
    virtual ~json_parser ();

    /// Parse.
    /// \returns  0 iff parsing succeeded.
    virtual int parse ();

#if YYDEBUG
    /// The current debugging stream.
    std::ostream& debug_stream () const;
    /// Set the current debugging stream.
    void set_debug_stream (std::ostream &);

    /// Type for debugging levels.
    typedef int debug_level_type;
    /// The current debugging level.
    debug_level_type debug_level () const;
    /// Set the current debugging level.
    void set_debug_level (debug_level_type l);
#endif

  private:
    /// Report a syntax error.
    /// \param loc    where the syntax error is found.
    /// \param msg    a description of the syntax error.
    virtual void error (const location_type& loc, const std::string& msg);

    /// Generate an error message.
    /// \param state   the state where the error occurred.
    /// \param tok     the lookahead token.
    virtual std::string yysyntax_error_ (int yystate, int tok);

#if YYDEBUG
    /// \brief Report a symbol value on the debug stream.
    /// \param yytype       The token type.
    /// \param yyvaluep     Its semantic value.
    /// \param yylocationp  Its location.
    virtual void yy_symbol_value_print_ (int yytype,
					 const semantic_type* yyvaluep,
					 const location_type* yylocationp);
    /// \brief Report a symbol on the debug stream.
    /// \param yytype       The token type.
    /// \param yyvaluep     Its semantic value.
    /// \param yylocationp  Its location.
    virtual void yy_symbol_print_ (int yytype,
				   const semantic_type* yyvaluep,
				   const location_type* yylocationp);
#endif


    /// State numbers.
    typedef int state_type;
    /// State stack type.
    typedef stack<state_type>    state_stack_type;
    /// Semantic value stack type.
    typedef stack<semantic_type> semantic_stack_type;
    /// location stack type.
    typedef stack<location_type> location_stack_type;

    /// The state stack.
    state_stack_type yystate_stack_;
    /// The semantic value stack.
    semantic_stack_type yysemantic_stack_;
    /// The location stack.
    location_stack_type yylocation_stack_;

    /// Whether the given \c yypact_ value indicates a defaulted state.
    /// \param yyvalue   the value to check
    static bool yy_pact_value_is_default_ (int yyvalue);

    /// Whether the given \c yytable_ value indicates a syntax error.
    /// \param yyvalue   the value to check
    static bool yy_table_value_is_error_ (int yyvalue);

    /// Internal symbol numbers.
    typedef unsigned char token_number_type;
    /* Tables.  */
    /// For a state, the index in \a yytable_ of its portion.
    static const signed char yypact_[];
    static const signed char yypact_ninf_;

    /// For a state, default reduction number.
    /// Unless\a  yytable_ specifies something else to do.
    /// Zero means the default is an error.
    static const unsigned char yydefact_[];

    static const signed char yypgoto_[];
    static const signed char yydefgoto_[];

    /// What to do in a state.
    /// \a yytable_[yypact_[s]]: what to do in state \a s.
    /// - if positive, shift that token.
    /// - if negative, reduce the rule which number is the opposite.
    /// - if zero, do what YYDEFACT says.
    static const unsigned char yytable_[];
    static const signed char yytable_ninf_;

    static const signed char yycheck_[];

    /// For a state, its accessing symbol.
    static const unsigned char yystos_[];

    /// For a rule, its LHS.
    static const unsigned char yyr1_[];
    /// For a rule, its RHS length.
    static const unsigned char yyr2_[]; 

    /// Convert the symbol name \a n to a form suitable for a diagnostic.
    static std::string yytnamerr_ (const char *n);


    /// For a symbol, its name in clear.
    static const char* const yytname_[];
#if YYDEBUG
    /// A type to store symbol numbers and -1.
    typedef signed char rhs_number_type;
    /// A `-1'-separated list of the rules' RHS.
    static const rhs_number_type yyrhs_[];
    /// For each rule, the index of the first RHS symbol in \a yyrhs_.
    static const unsigned char yyprhs_[];
    /// For each rule, its source line number.
    static const unsigned char yyrline_[];
    /// For each scanner token number, its symbol number.
    static const unsigned short int yytoken_number_[];
    /// Report on the debug stream that the rule \a r is going to be reduced.
    virtual void yy_reduce_print_ (int r);
    /// Print the state stack on the debug stream.
    virtual void yystack_print_ ();

    /* Debugging.  */
    int yydebug_;
    std::ostream* yycdebug_;
#endif

    /// Convert a scanner token number \a t to a symbol number.
    token_number_type yytranslate_ (int t);

    /// \brief Reclaim the memory associated to a symbol.
    /// \param yymsg        Why this token is reclaimed.
    ///                     If null, do not display the symbol, just free it.
    /// \param yytype       The symbol type.
    /// \param yyvaluep     Its semantic value.
    /// \param yylocationp  Its location.
    inline void yydestruct_ (const char* yymsg,
			     int yytype,
			     semantic_type* yyvaluep,
			     location_type* yylocationp);

    /// Pop \a n symbols the three stacks.
    inline void yypop_ (unsigned int n = 1);

    /* Constants.  */
    static const int yyeof_;
    /* LAST_ -- Last index in TABLE_.  */
    static const int yylast_;
    static const int yynnts_;
    static const int yyempty_;
    static const int yyfinal_;
    static const int yyterror_;
    static const int yyerrcode_;
    static const int yyntokens_;
    static const unsigned int yyuser_token_number_max_;
    static const token_number_type yyundef_token_;

    /* User arguments.  */
    QJson::ParserPrivate* driver;
  };

}Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\json_parser.hh:66
  2021-07-25 14:51:50  [ main:991 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\json_parser.hh
  2021-07-25 14:51:50  [ main:992 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\json_scanner.cc
  2021-07-25 14:51:50  [ main:1338 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\json_scanner.cpp
  2021-07-25 14:51:51  [ main:1353 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\json_scanner.h
  2021-07-25 14:51:51  [ main:1354 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\location.hh
  2021-07-25 14:51:51  [ main:1354 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\parser.cpp
  2021-07-25 14:51:51  [ main:1365 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\parser.h
  2021-07-25 14:51:51  [ main:1366 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\parserrunnable.cpp
  2021-07-25 14:51:51  [ main:1373 ] - [ ERROR ]  parsing error 
QT_BEGIN_NAMESPACE
  2021-07-25 14:51:51  [ main:1374 ] - [ ERROR ]  warning: parse error QT_BEGIN_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\parserrunnable.h:29
  2021-07-25 14:51:51  [ main:1374 ] - [ ERROR ]  parsing error 
QT_END_NAMESPACE
  2021-07-25 14:51:51  [ main:1374 ] - [ ERROR ]  warning: parse error QT_END_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\parserrunnable.h:31
  2021-07-25 14:51:51  [ main:1374 ] - [ ERROR ]  parsing error 
class QJSON_EXPORT ParserRunnable  : public QObject, public QRunnable
  {
    Q_OBJECT
    public:
      explicit ParserRunnable(QObject* parent = 0);
      ~ParserRunnable();

      void setData( const QByteArray& data );

      void run();

    Q_SIGNALS:
      /**
      * This signal is emitted when the parsing process has been completed
      * @param json contains the result of the parsing
      * @param ok if a parsing error occurs ok is set to false, otherwise it's set to true.
      * @param error_msg contains a string explaining the failure reason
      **/
      void parsingFinished(const QVariant& json, bool ok, const QString& error_msg);

    private:
      Q_DISABLE_COPY(ParserRunnable)
      class Private;
      Private* const d;
  };
  2021-07-25 14:51:51  [ main:1374 ] - [ ERROR ]  warning: parse error class QJSON_EXPORT ParserRunnable  : public QObject, public QRunnable
  {
    Q_OBJECT
    public:
      explicit ParserRunnable(QObject* parent = 0);
      ~ParserRunnable();

      void setData( const QByteArray& data );

      void run();

    Q_SIGNALS:
      /**
      * This signal is emitted when the parsing process has been completed
      * @param json contains the result of the parsing
      * @param ok if a parsing error occurs ok is set to false, otherwise it's set to true.
      * @param error_msg contains a string explaining the failure reason
      **/
      void parsingFinished(const QVariant& json, bool ok, const QString& error_msg);

    private:
      Q_DISABLE_COPY(ParserRunnable)
      class Private;
      Private* const d;
  };Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\parserrunnable.h:37
  2021-07-25 14:51:51  [ main:1378 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\parserrunnable.h
  2021-07-25 14:51:51  [ main:1379 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\parser_p.h
  2021-07-25 14:51:51  [ main:1380 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\position.hh
  2021-07-25 14:51:51  [ main:1389 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\qjson_debug.h
  2021-07-25 14:51:51  [ main:1390 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\qjson_export.h
  2021-07-25 14:51:51  [ main:1390 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\qobjecthelper.cpp
  2021-07-25 14:51:51  [ main:1398 ] - [ ERROR ]  parsing error 
QT_BEGIN_NAMESPACE
  2021-07-25 14:51:51  [ main:1399 ] - [ ERROR ]  warning: parse error QT_BEGIN_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\qobjecthelper.h:30
  2021-07-25 14:51:51  [ main:1399 ] - [ ERROR ]  parsing error 
QT_END_NAMESPACE
  2021-07-25 14:51:51  [ main:1399 ] - [ ERROR ]  warning: parse error QT_END_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\qobjecthelper.h:32
  2021-07-25 14:51:51  [ main:1399 ] - [ ERROR ]  parsing error 
class QJSON_EXPORT QObjectHelper {
    public:
      QObjectHelper();
      ~QObjectHelper();

    /**
    * This method converts a QObject instance into a QVariantMap.
    *
    * @param object The QObject instance to be converted.
    * @param ignoredProperties Properties that won't be converted.
    */
    static QVariantMap qobject2qvariant( const QObject* object,
                                  const QStringList& ignoredProperties = QStringList(QString(QLatin1String("objectName"))));

    /**
    * This method converts a QVariantMap instance into a QObject
    *
    * @param variant Attributes to assign to the object.
    * @param object The QObject instance to update.
    */
    static void qvariant2qobject(const QVariantMap& variant, QObject* object);

    private:
      Q_DISABLE_COPY(QObjectHelper)
      class QObjectHelperPrivate;
      QObjectHelperPrivate* const d;
  };
  2021-07-25 14:51:51  [ main:1399 ] - [ ERROR ]  warning: parse error class QJSON_EXPORT QObjectHelper {
    public:
      QObjectHelper();
      ~QObjectHelper();

    /**
    * This method converts a QObject instance into a QVariantMap.
    *
    * @param object The QObject instance to be converted.
    * @param ignoredProperties Properties that won't be converted.
    */
    static QVariantMap qobject2qvariant( const QObject* object,
                                  const QStringList& ignoredProperties = QStringList(QString(QLatin1String("objectName"))));

    /**
    * This method converts a QVariantMap instance into a QObject
    *
    * @param variant Attributes to assign to the object.
    * @param object The QObject instance to update.
    */
    static void qvariant2qobject(const QVariantMap& variant, QObject* object);

    private:
      Q_DISABLE_COPY(QObjectHelper)
      class QObjectHelperPrivate;
      QObjectHelperPrivate* const d;
  };Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\qobjecthelper.h:118
  2021-07-25 14:51:51  [ main:1404 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\qobjecthelper.h
  2021-07-25 14:51:51  [ main:1404 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\serializer.cpp
  2021-07-25 14:51:51  [ main:1421 ] - [ ERROR ]  warning: parse error Q_FOREACH( const QByteArray& i, list ) {
    if ( !res.isEmpty() )
      res += sep;
    res += i;
  }Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializer.cpp:55
  2021-07-25 14:51:51  [ main:1421 ] - [ ERROR ]  warning: parse error Q_FOREACH( const QVariant& var, list )
    {
      indentLevel++;
      QByteArray serializedValue = serialize( var, ok, indentLevel);
      indentLevel--;
      if ( !*ok ) {
        break;
      }
      values << serializedValue;
    }Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializer.cpp:72
  2021-07-25 14:51:51  [ main:1434 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\serializer.h
  2021-07-25 14:51:51  [ main:1435 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\serializerrunnable.cpp
  2021-07-25 14:51:51  [ main:1442 ] - [ ERROR ]  parsing error 
QT_BEGIN_NAMESPACE
  2021-07-25 14:51:51  [ main:1442 ] - [ ERROR ]  warning: parse error QT_BEGIN_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializerrunnable.h:29
  2021-07-25 14:51:51  [ main:1442 ] - [ ERROR ]  parsing error 
QT_END_NAMESPACE
  2021-07-25 14:51:51  [ main:1443 ] - [ ERROR ]  warning: parse error QT_END_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializerrunnable.h:33
  2021-07-25 14:51:51  [ main:1443 ] - [ ERROR ]  parsing error 
class QJSON_EXPORT SerializerRunnable  : public QObject, public QRunnable
  {
    Q_OBJECT
    public:
      explicit SerializerRunnable(QObject* parent = 0);
      ~SerializerRunnable();

      /**
       * Sets the json object to serialize.
       *
       * @param json QVariant containing the json representation to be serialized
       */
      void setJsonObject( const QVariant& json );

      /* reimp */ void run();

    Q_SIGNALS:
      /**
      * This signal is emitted when the serialization process has been completed
      * @param serialized contains the result of the serialization
      * @param ok if a serialization error occurs ok is set to false, otherwise it's set to true.
      * @param error_msg contains a string explaining the failure reason
      **/
      void parsingFinished(const QByteArray& serialized, bool ok, const QString& error_msg);

    private:
      Q_DISABLE_COPY(SerializerRunnable)
      class Private;
      Private* const d;
  };
  2021-07-25 14:51:51  [ main:1443 ] - [ ERROR ]  warning: parse error class QJSON_EXPORT SerializerRunnable  : public QObject, public QRunnable
  {
    Q_OBJECT
    public:
      explicit SerializerRunnable(QObject* parent = 0);
      ~SerializerRunnable();

      /**
       * Sets the json object to serialize.
       *
       * @param json QVariant containing the json representation to be serialized
       */
      void setJsonObject( const QVariant& json );

      /* reimp */ void run();

    Q_SIGNALS:
      /**
      * This signal is emitted when the serialization process has been completed
      * @param serialized contains the result of the serialization
      * @param ok if a serialization error occurs ok is set to false, otherwise it's set to true.
      * @param error_msg contains a string explaining the failure reason
      **/
      void parsingFinished(const QByteArray& serialized, bool ok, const QString& error_msg);

    private:
      Q_DISABLE_COPY(SerializerRunnable)
      class Private;
      Private* const d;
  };Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializerrunnable.h:39
  2021-07-25 14:51:51  [ main:1447 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\serializerrunnable.h
  2021-07-25 14:51:51  [ main:1447 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\stack.hh
  2021-07-25 14:51:51  [ main:1449 ] - [ INFO ]  start dependency
  2021-07-25 14:51:51  [ main:1516 ] - [ INFO ]  includenum:73
  2021-07-25 14:51:51  [ main:1516 ] - [ INFO ]  definenum:81
  2021-07-25 14:51:51  [ main:1516 ] - [ INFO ]  callnum:45
  2021-07-25 14:51:51  [ main:1516 ] - [ INFO ]  returnnum:159
  2021-07-25 14:51:51  [ main:1516 ] - [ INFO ]  parameternum:614
  2021-07-25 14:51:51  [ main:1516 ] - [ INFO ]  extendnum:1
  2021-07-25 14:51:51  [ main:1516 ] - [ INFO ]  overridenum:1
  2021-07-25 14:51:51  [ main:1624 ] - [ INFO ]  Process finish!
  2021-07-25 14:52:11  [ main:0 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\phantompy.cpp
  2021-07-25 14:52:11  [ main:471 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 14:52:11  [ main:531 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\frame.hpp:11
  2021-07-25 14:52:11  [ main:533 ] - [ ERROR ]  parsing error 
private slots:
    void loadFinished(bool ok);
  2021-07-25 14:52:11  [ main:534 ] - [ ERROR ]  warning: parse error private slots:
    void loadFinished(bool ok);Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\frame.hpp:38
  2021-07-25 14:52:11  [ main:537 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 14:52:11  [ main:537 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\image.hpp:9
  2021-07-25 14:52:11  [ main:554 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 14:52:11  [ main:554 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\timeout.hpp:9
  2021-07-25 14:52:11  [ main:554 ] - [ ERROR ]  parsing error 
private slots:
    void handleTimeout();
  2021-07-25 14:52:11  [ main:555 ] - [ ERROR ]  warning: parse error private slots:
    void handleTimeout();Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\timeout.hpp:22
  2021-07-25 14:52:11  [ main:566 ] - [ ERROR ]  parsing error 
QT_BEGIN_NAMESPACE
  2021-07-25 14:52:11  [ main:566 ] - [ ERROR ]  warning: parse error QT_BEGIN_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\parser.h:26
  2021-07-25 14:52:11  [ main:566 ] - [ ERROR ]  parsing error 
QT_END_NAMESPACE
  2021-07-25 14:52:11  [ main:567 ] - [ ERROR ]  warning: parse error QT_END_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\parser.h:29
  2021-07-25 14:52:11  [ main:568 ] - [ ERROR ]  parsing error 
class QJSON_EXPORT Parser
  {
    public:
      Parser();
      ~Parser();

      /**
      * Read JSON string from the I/O Device and converts it to a QVariant object
      * @param io Input output device
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true.
      * @returns a QVariant object generated from the JSON string
      */
      QVariant parse(QIODevice* io, bool* ok = 0);

      /**
      * This is a method provided for convenience.
      * @param jsonData data containing the JSON object representation
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true.
      * @returns a QVariant object generated from the JSON string
      * @sa errorString
      * @sa errorLine
      */
      QVariant parse(const QByteArray& jsonData, bool* ok = 0);

      /**
      * This method returns the error message
      * @returns a QString object containing the error message of the last parse operation
      * @sa errorLine
      */
      QString errorString() const;

      /**
      * This method returns line number where the error occurred
      * @returns the line number where the error occurred
      * @sa errorString
      */
      int errorLine() const;

      /**
       * Sets whether special numbers (Infinity, -Infinity, NaN) are allowed as an extension to
       * the standard
       * @param  allowSpecialNumbers new value of whether special numbers are allowed
       * @sa specialNumbersAllowed
       */
      void allowSpecialNumbers(bool allowSpecialNumbers);

      /**
       * @returns whether special numbers (Infinity, -Infinity, NaN) are allowed
       * @sa allowSpecialNumbers
       */
      bool specialNumbersAllowed() const;

    private:
      Q_DISABLE_COPY(Parser)
      ParserPrivate* const d;
  };
  2021-07-25 14:52:11  [ main:568 ] - [ ERROR ]  warning: parse error class QJSON_EXPORT Parser
  {
    public:
      Parser();
      ~Parser();

      /**
      * Read JSON string from the I/O Device and converts it to a QVariant object
      * @param io Input output device
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true.
      * @returns a QVariant object generated from the JSON string
      */
      QVariant parse(QIODevice* io, bool* ok = 0);

      /**
      * This is a method provided for convenience.
      * @param jsonData data containing the JSON object representation
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true.
      * @returns a QVariant object generated from the JSON string
      * @sa errorString
      * @sa errorLine
      */
      QVariant parse(const QByteArray& jsonData, bool* ok = 0);

      /**
      * This method returns the error message
      * @returns a QString object containing the error message of the last parse operation
      * @sa errorLine
      */
      QString errorString() const;

      /**
      * This method returns line number where the error occurred
      * @returns the line number where the error occurred
      * @sa errorString
      */
      int errorLine() const;

      /**
       * Sets whether special numbers (Infinity, -Infinity, NaN) are allowed as an extension to
       * the standard
       * @param  allowSpecialNumbers new value of whether special numbers are allowed
       * @sa specialNumbersAllowed
       */
      void allowSpecialNumbers(bool allowSpecialNumbers);

      /**
       * @returns whether special numbers (Infinity, -Infinity, NaN) are allowed
       * @sa allowSpecialNumbers
       */
      bool specialNumbersAllowed() const;

    private:
      Q_DISABLE_COPY(Parser)
      ParserPrivate* const d;
  };Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\parser.h:41
  2021-07-25 14:52:11  [ main:585 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 14:52:11  [ main:586 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\networkmanager.hpp:11
  2021-07-25 14:52:11  [ main:586 ] - [ ERROR ]  parsing error 
signals:
    void replyReceived(const QVariantMap &reply);
  2021-07-25 14:52:11  [ main:586 ] - [ ERROR ]  warning: parse error signals:
    void replyReceived(const QVariantMap &reply);Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\networkmanager.hpp:29
  2021-07-25 14:52:11  [ main:587 ] - [ ERROR ]  parsing error 
private slots:
    void provideAuthentication(QNetworkReply *reply, QAuthenticator *authenticator);
  2021-07-25 14:52:11  [ main:587 ] - [ ERROR ]  warning: parse error private slots:
    void provideAuthentication(QNetworkReply *reply, QAuthenticator *authenticator);Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\networkmanager.hpp:35
  2021-07-25 14:52:11  [ main:590 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 14:52:11  [ main:590 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\networkmanagerproxy.hpp:10
  2021-07-25 14:52:11  [ main:590 ] - [ ERROR ]  parsing error 
private slots:
    void finished();
  2021-07-25 14:52:11  [ main:591 ] - [ ERROR ]  warning: parse error private slots:
    void finished();Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\networkmanagerproxy.hpp:25
  2021-07-25 14:52:11  [ main:594 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 14:52:11  [ main:595 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\page.hpp:19
  2021-07-25 14:52:11  [ main:596 ] - [ ERROR ]  parsing error 
private slots:
    void loadFinished(bool ok);
  2021-07-25 14:52:11  [ main:597 ] - [ ERROR ]  warning: parse error private slots:
    void loadFinished(bool ok);Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\page.hpp:57
  2021-07-25 14:52:11  [ main:601 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 14:52:11  [ main:602 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\eventprocessor.hpp:9
  2021-07-25 14:52:11  [ main:602 ] - [ ERROR ]  parsing error 
private slots:
    void handleTimeout();
  2021-07-25 14:52:11  [ main:602 ] - [ ERROR ]  warning: parse error private slots:
    void handleTimeout();Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\eventprocessor.hpp:23
  2021-07-25 14:52:11  [ main:606 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 14:52:11  [ main:606 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\webelement.hpp:11
  2021-07-25 14:52:11  [ main:607 ] - [ ERROR ]  parsing error 
private slots:
    void loadFinished(bool ok);
  2021-07-25 14:52:11  [ main:607 ] - [ ERROR ]  warning: parse error private slots:
    void loadFinished(bool ok);Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\webelement.hpp:69
  2021-07-25 14:52:11  [ main:611 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 14:52:11  [ main:611 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\webelementcollection.hpp:11
  2021-07-25 14:52:11  [ main:634 ] - [ ERROR ]  parsing error 
QT_BEGIN_NAMESPACE
  2021-07-25 14:52:11  [ main:634 ] - [ ERROR ]  warning: parse error QT_BEGIN_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializer.h:26
  2021-07-25 14:52:11  [ main:634 ] - [ ERROR ]  parsing error 
QT_END_NAMESPACE
  2021-07-25 14:52:11  [ main:634 ] - [ ERROR ]  warning: parse error QT_END_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializer.h:30
  2021-07-25 14:52:11  [ main:634 ] - [ ERROR ]  parsing error 
class QJSON_EXPORT Serializer {
  public:
    Serializer();
    ~Serializer();

     /**
      * This method generates a textual JSON representation and outputs it to the
      * passed in I/O Device.
      * @param variant The JSON document in its in-memory representation as generated by the
      * parser.
      * @param out Input output device
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true
      */
    void serialize( const QVariant& variant, QIODevice* out, bool* ok);

    /**
      * This is a method provided for convenience. It turns the passed in in-memory
      * representation of the JSON document into a textual one, which is returned.
      * If the returned string is empty, the document was empty. If it was null, there
      * was a parsing error.
      *
      * @param variant The JSON document in its in-memory representation as generated by the
      * parser.
      *
      * \deprecated This method is going to be removed with the next major release of QJson.
      */
    QByteArray serialize( const QVariant& variant);

    /**
      * This is a method provided for convenience. It turns the passed in in-memory
      * representation of the JSON document into a textual one, which is returned.
      * If the returned string is empty, the document was empty. If it was null, there
      * was a parsing error.
      *
      * @param variant The JSON document in its in-memory representation as generated by the
      * parser.
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true
      */
    QByteArray serialize( const QVariant& variant, bool *ok);

    /**
     * Allow or disallow writing of NaN and/or Infinity (as an extension to QJson)
     */
    void allowSpecialNumbers(bool allow);

    /**
     * Is Nan and/or Infinity allowed?
     */
    bool specialNumbersAllowed() const;

    /**
     * set output indentation mode as defined in QJson::IndentMode
     */
    void setIndentMode(IndentMode mode = QJson::IndentNone);


    /**
    * set double precision used while converting Double
    * \sa QByteArray::number
    */
    void setDoublePrecision(int precision);

    /**
     * Returns one of the indentation modes defined in QJson::IndentMode
     */
    IndentMode indentMode() const;

    /**
     * Returns the error message
     */
    QString errorMessage() const;

  private:
    Q_DISABLE_COPY(Serializer)
    class SerializerPrivate;
    SerializerPrivate* const d;
  };
  2021-07-25 14:52:11  [ main:635 ] - [ ERROR ]  warning: parse error class QJSON_EXPORT Serializer {
  public:
    Serializer();
    ~Serializer();

     /**
      * This method generates a textual JSON representation and outputs it to the
      * passed in I/O Device.
      * @param variant The JSON document in its in-memory representation as generated by the
      * parser.
      * @param out Input output device
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true
      */
    void serialize( const QVariant& variant, QIODevice* out, bool* ok);

    /**
      * This is a method provided for convenience. It turns the passed in in-memory
      * representation of the JSON document into a textual one, which is returned.
      * If the returned string is empty, the document was empty. If it was null, there
      * was a parsing error.
      *
      * @param variant The JSON document in its in-memory representation as generated by the
      * parser.
      *
      * \deprecated This method is going to be removed with the next major release of QJson.
      */
    QByteArray serialize( const QVariant& variant);

    /**
      * This is a method provided for convenience. It turns the passed in in-memory
      * representation of the JSON document into a textual one, which is returned.
      * If the returned string is empty, the document was empty. If it was null, there
      * was a parsing error.
      *
      * @param variant The JSON document in its in-memory representation as generated by the
      * parser.
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true
      */
    QByteArray serialize( const QVariant& variant, bool *ok);

    /**
     * Allow or disallow writing of NaN and/or Infinity (as an extension to QJson)
     */
    void allowSpecialNumbers(bool allow);

    /**
     * Is Nan and/or Infinity allowed?
     */
    bool specialNumbersAllowed() const;

    /**
     * set output indentation mode as defined in QJson::IndentMode
     */
    void setIndentMode(IndentMode mode = QJson::IndentNone);


    /**
    * set double precision used while converting Double
    * \sa QByteArray::number
    */
    void setDoublePrecision(int precision);

    /**
     * Returns one of the indentation modes defined in QJson::IndentMode
     */
    IndentMode indentMode() const;

    /**
     * Returns the error message
     */
    QString errorMessage() const;

  private:
    Q_DISABLE_COPY(Serializer)
    class SerializerPrivate;
    SerializerPrivate* const d;
  };Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializer.h:112
  2021-07-25 14:52:11  [ main:638 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 14:52:11  [ main:638 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\cookiejar.hpp:14
  2021-07-25 14:52:11  [ main:707 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\phantompy.hpp
  2021-07-25 14:52:11  [ main:708 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\context.cpp
  2021-07-25 14:52:11  [ main:734 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\context.hpp
  2021-07-25 14:52:11  [ main:735 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\cookiejar.cpp
  2021-07-25 14:52:12  [ main:761 ] - [ ERROR ]  warning: parse error foreach(QNetworkCookie n_cookie, cookiesForUrl(QUrl(url))) {
        cookie["name"] = QString::fromUtf8(n_cookie.name());
        cookie["value"] = QString::fromUtf8(n_cookie.value());
        cookie["domain"] = n_cookie.domain();
        cookie["path"] = n_cookie.path();
        cookie["expires"] = n_cookie.expirationDate().toString(Qt::ISODate);

        cookiesList.append(cookie);
    }Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\cookiejar.cpp:112
  2021-07-25 14:52:12  [ main:762 ] - [ ERROR ]  warning: parse error foreach(QNetworkCookie n_cookie, allCookies()) {
        cookie["name"] = QString::fromUtf8(n_cookie.name());
        cookie["value"] = QString::fromUtf8(n_cookie.value());
        cookie["domain"] = n_cookie.domain();
        cookie["path"] = n_cookie.path();
        cookie["expires"] = n_cookie.expirationDate().toString(Qt::ISODate);

        cookiesList.append(cookie);
    }Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\cookiejar.cpp:129
  2021-07-25 14:52:12  [ main:763 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\cookiejar.hpp
  2021-07-25 14:52:12  [ main:764 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\eventprocessor.cpp
  2021-07-25 14:52:12  [ main:771 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\eventprocessor.hpp
  2021-07-25 14:52:12  [ main:772 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\frame.cpp
  2021-07-25 14:52:12  [ main:802 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\frame.hpp
  2021-07-25 14:52:12  [ main:803 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\image.cpp
  2021-07-25 14:52:12  [ main:808 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\image.hpp
  2021-07-25 14:52:12  [ main:809 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\networkmanager.cpp
  2021-07-25 14:52:12  [ main:817 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 14:52:12  [ main:817 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\networktimeout.hpp:10
  2021-07-25 14:52:12  [ main:824 ] - [ ERROR ]  warning: parse error foreach (QByteArray headerName, reply->rawHeaderList()) {
        QVariantMap header;
        header["name"] = QString::fromUtf8(headerName);
        header["value"] = QString::fromUtf8(reply->rawHeader(headerName));

        headers.append(header);
    }Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\networkmanager.cpp:69
  2021-07-25 14:52:12  [ main:826 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\networkmanager.hpp
  2021-07-25 14:52:12  [ main:826 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\networkmanagerproxy.cpp
  2021-07-25 14:52:12  [ main:833 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\networkmanagerproxy.hpp
  2021-07-25 14:52:12  [ main:834 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\networktimeout.cpp
  2021-07-25 14:52:12  [ main:838 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\networktimeout.hpp
  2021-07-25 14:52:12  [ main:839 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\page.cpp
  2021-07-25 14:52:12  [ main:850 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\page.hpp
  2021-07-25 14:52:12  [ main:851 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\timeout.cpp
  2021-07-25 14:52:12  [ main:857 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\timeout.hpp
  2021-07-25 14:52:12  [ main:858 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\webelement.cpp
  2021-07-25 14:52:12  [ main:872 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\webelement.hpp
  2021-07-25 14:52:12  [ main:873 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\webelementcollection.cpp
  2021-07-25 14:52:12  [ main:878 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\webelementcollection.hpp
  2021-07-25 14:52:12  [ main:879 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\FlexLexer.h
  2021-07-25 14:52:12  [ main:891 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\json_parser.cc
  2021-07-25 14:52:12  [ main:968 ] - [ ERROR ]  parsing error 
Q_DECLARE_METATYPE(QVector<QVariant>*)
  Q_DECLARE_METATYPE(QVariantMap*)


/* Line 33 of lalr1.cc  */
#line 72 "json_parser.hh"


#include <string>
#include <iostream>
#include "stack.hh"
#include "location.hh"

/* Enabling traces.  */
#ifndef YYDEBUG
# define YYDEBUG 1
#endif


namespace yy {
/* Line 33 of lalr1.cc  */
#line 88 "json_parser.hh"

  /// A Bison parser.
  class json_parser
  {
  public:
    /// Symbol semantic values.
#ifndef YYSTYPE
    typedef int semantic_type;
#else
    typedef YYSTYPE semantic_type;
#endif
    /// Symbol locations.
    typedef location location_type;
    /// Tokens.
    struct token
    {
      /* Tokens.  */
   enum yytokentype {
     END = 0,
     CURLY_BRACKET_OPEN = 1,
     CURLY_BRACKET_CLOSE = 2,
     SQUARE_BRACKET_OPEN = 3,
     SQUARE_BRACKET_CLOSE = 4,
     COLON = 5,
     COMMA = 6,
     NUMBER = 7,
     TRUE_VAL = 8,
     FALSE_VAL = 9,
     NULL_VAL = 10,
     STRING = 11,
     INVALID = 12
   };

    };
    /// Token type.
    typedef token::yytokentype token_type;

    /// Build a parser object.
    json_parser (QJson::ParserPrivate* driver_yyarg);
    virtual ~json_parser ();

    /// Parse.
    /// \returns  0 iff parsing succeeded.
    virtual int parse ();

#if YYDEBUG
    /// The current debugging stream.
    std::ostream& debug_stream () const;
    /// Set the current debugging stream.
    void set_debug_stream (std::ostream &);

    /// Type for debugging levels.
    typedef int debug_level_type;
    /// The current debugging level.
    debug_level_type debug_level () const;
    /// Set the current debugging level.
    void set_debug_level (debug_level_type l);
#endif

  private:
    /// Report a syntax error.
    /// \param loc    where the syntax error is found.
    /// \param msg    a description of the syntax error.
    virtual void error (const location_type& loc, const std::string& msg);

    /// Generate an error message.
    /// \param state   the state where the error occurred.
    /// \param tok     the lookahead token.
    virtual std::string yysyntax_error_ (int yystate, int tok);

#if YYDEBUG
    /// \brief Report a symbol value on the debug stream.
    /// \param yytype       The token type.
    /// \param yyvaluep     Its semantic value.
    /// \param yylocationp  Its location.
    virtual void yy_symbol_value_print_ (int yytype,
					 const semantic_type* yyvaluep,
					 const location_type* yylocationp);
    /// \brief Report a symbol on the debug stream.
    /// \param yytype       The token type.
    /// \param yyvaluep     Its semantic value.
    /// \param yylocationp  Its location.
    virtual void yy_symbol_print_ (int yytype,
				   const semantic_type* yyvaluep,
				   const location_type* yylocationp);
#endif


    /// State numbers.
    typedef int state_type;
    /// State stack type.
    typedef stack<state_type>    state_stack_type;
    /// Semantic value stack type.
    typedef stack<semantic_type> semantic_stack_type;
    /// location stack type.
    typedef stack<location_type> location_stack_type;

    /// The state stack.
    state_stack_type yystate_stack_;
    /// The semantic value stack.
    semantic_stack_type yysemantic_stack_;
    /// The location stack.
    location_stack_type yylocation_stack_;

    /// Whether the given \c yypact_ value indicates a defaulted state.
    /// \param yyvalue   the value to check
    static bool yy_pact_value_is_default_ (int yyvalue);

    /// Whether the given \c yytable_ value indicates a syntax error.
    /// \param yyvalue   the value to check
    static bool yy_table_value_is_error_ (int yyvalue);

    /// Internal symbol numbers.
    typedef unsigned char token_number_type;
    /* Tables.  */
    /// For a state, the index in \a yytable_ of its portion.
    static const signed char yypact_[];
    static const signed char yypact_ninf_;

    /// For a state, default reduction number.
    /// Unless\a  yytable_ specifies something else to do.
    /// Zero means the default is an error.
    static const unsigned char yydefact_[];

    static const signed char yypgoto_[];
    static const signed char yydefgoto_[];

    /// What to do in a state.
    /// \a yytable_[yypact_[s]]: what to do in state \a s.
    /// - if positive, shift that token.
    /// - if negative, reduce the rule which number is the opposite.
    /// - if zero, do what YYDEFACT says.
    static const unsigned char yytable_[];
    static const signed char yytable_ninf_;

    static const signed char yycheck_[];

    /// For a state, its accessing symbol.
    static const unsigned char yystos_[];

    /// For a rule, its LHS.
    static const unsigned char yyr1_[];
    /// For a rule, its RHS length.
    static const unsigned char yyr2_[]; 

    /// Convert the symbol name \a n to a form suitable for a diagnostic.
    static std::string yytnamerr_ (const char *n);


    /// For a symbol, its name in clear.
    static const char* const yytname_[];
#if YYDEBUG
    /// A type to store symbol numbers and -1.
    typedef signed char rhs_number_type;
    /// A `-1'-separated list of the rules' RHS.
    static const rhs_number_type yyrhs_[];
    /// For each rule, the index of the first RHS symbol in \a yyrhs_.
    static const unsigned char yyprhs_[];
    /// For each rule, its source line number.
    static const unsigned char yyrline_[];
    /// For each scanner token number, its symbol number.
    static const unsigned short int yytoken_number_[];
    /// Report on the debug stream that the rule \a r is going to be reduced.
    virtual void yy_reduce_print_ (int r);
    /// Print the state stack on the debug stream.
    virtual void yystack_print_ ();

    /* Debugging.  */
    int yydebug_;
    std::ostream* yycdebug_;
#endif

    /// Convert a scanner token number \a t to a symbol number.
    token_number_type yytranslate_ (int t);

    /// \brief Reclaim the memory associated to a symbol.
    /// \param yymsg        Why this token is reclaimed.
    ///                     If null, do not display the symbol, just free it.
    /// \param yytype       The symbol type.
    /// \param yyvaluep     Its semantic value.
    /// \param yylocationp  Its location.
    inline void yydestruct_ (const char* yymsg,
			     int yytype,
			     semantic_type* yyvaluep,
			     location_type* yylocationp);

    /// Pop \a n symbols the three stacks.
    inline void yypop_ (unsigned int n = 1);

    /* Constants.  */
    static const int yyeof_;
    /* LAST_ -- Last index in TABLE_.  */
    static const int yylast_;
    static const int yynnts_;
    static const int yyempty_;
    static const int yyfinal_;
    static const int yyterror_;
    static const int yyerrcode_;
    static const int yyntokens_;
    static const unsigned int yyuser_token_number_max_;
    static const token_number_type yyundef_token_;

    /* User arguments.  */
    QJson::ParserPrivate* driver;
  };

}
  2021-07-25 14:52:12  [ main:969 ] - [ ERROR ]  warning: parse error Q_DECLARE_METATYPE(QVector<QVariant>*)
  Q_DECLARE_METATYPE(QVariantMap*)


/* Line 33 of lalr1.cc  */
#line 72 "json_parser.hh"


#include <string>
#include <iostream>
#include "stack.hh"
#include "location.hh"

/* Enabling traces.  */
#ifndef YYDEBUG
# define YYDEBUG 1
#endif


namespace yy {
/* Line 33 of lalr1.cc  */
#line 88 "json_parser.hh"

  /// A Bison parser.
  class json_parser
  {
  public:
    /// Symbol semantic values.
#ifndef YYSTYPE
    typedef int semantic_type;
#else
    typedef YYSTYPE semantic_type;
#endif
    /// Symbol locations.
    typedef location location_type;
    /// Tokens.
    struct token
    {
      /* Tokens.  */
   enum yytokentype {
     END = 0,
     CURLY_BRACKET_OPEN = 1,
     CURLY_BRACKET_CLOSE = 2,
     SQUARE_BRACKET_OPEN = 3,
     SQUARE_BRACKET_CLOSE = 4,
     COLON = 5,
     COMMA = 6,
     NUMBER = 7,
     TRUE_VAL = 8,
     FALSE_VAL = 9,
     NULL_VAL = 10,
     STRING = 11,
     INVALID = 12
   };

    };
    /// Token type.
    typedef token::yytokentype token_type;

    /// Build a parser object.
    json_parser (QJson::ParserPrivate* driver_yyarg);
    virtual ~json_parser ();

    /// Parse.
    /// \returns  0 iff parsing succeeded.
    virtual int parse ();

#if YYDEBUG
    /// The current debugging stream.
    std::ostream& debug_stream () const;
    /// Set the current debugging stream.
    void set_debug_stream (std::ostream &);

    /// Type for debugging levels.
    typedef int debug_level_type;
    /// The current debugging level.
    debug_level_type debug_level () const;
    /// Set the current debugging level.
    void set_debug_level (debug_level_type l);
#endif

  private:
    /// Report a syntax error.
    /// \param loc    where the syntax error is found.
    /// \param msg    a description of the syntax error.
    virtual void error (const location_type& loc, const std::string& msg);

    /// Generate an error message.
    /// \param state   the state where the error occurred.
    /// \param tok     the lookahead token.
    virtual std::string yysyntax_error_ (int yystate, int tok);

#if YYDEBUG
    /// \brief Report a symbol value on the debug stream.
    /// \param yytype       The token type.
    /// \param yyvaluep     Its semantic value.
    /// \param yylocationp  Its location.
    virtual void yy_symbol_value_print_ (int yytype,
					 const semantic_type* yyvaluep,
					 const location_type* yylocationp);
    /// \brief Report a symbol on the debug stream.
    /// \param yytype       The token type.
    /// \param yyvaluep     Its semantic value.
    /// \param yylocationp  Its location.
    virtual void yy_symbol_print_ (int yytype,
				   const semantic_type* yyvaluep,
				   const location_type* yylocationp);
#endif


    /// State numbers.
    typedef int state_type;
    /// State stack type.
    typedef stack<state_type>    state_stack_type;
    /// Semantic value stack type.
    typedef stack<semantic_type> semantic_stack_type;
    /// location stack type.
    typedef stack<location_type> location_stack_type;

    /// The state stack.
    state_stack_type yystate_stack_;
    /// The semantic value stack.
    semantic_stack_type yysemantic_stack_;
    /// The location stack.
    location_stack_type yylocation_stack_;

    /// Whether the given \c yypact_ value indicates a defaulted state.
    /// \param yyvalue   the value to check
    static bool yy_pact_value_is_default_ (int yyvalue);

    /// Whether the given \c yytable_ value indicates a syntax error.
    /// \param yyvalue   the value to check
    static bool yy_table_value_is_error_ (int yyvalue);

    /// Internal symbol numbers.
    typedef unsigned char token_number_type;
    /* Tables.  */
    /// For a state, the index in \a yytable_ of its portion.
    static const signed char yypact_[];
    static const signed char yypact_ninf_;

    /// For a state, default reduction number.
    /// Unless\a  yytable_ specifies something else to do.
    /// Zero means the default is an error.
    static const unsigned char yydefact_[];

    static const signed char yypgoto_[];
    static const signed char yydefgoto_[];

    /// What to do in a state.
    /// \a yytable_[yypact_[s]]: what to do in state \a s.
    /// - if positive, shift that token.
    /// - if negative, reduce the rule which number is the opposite.
    /// - if zero, do what YYDEFACT says.
    static const unsigned char yytable_[];
    static const signed char yytable_ninf_;

    static const signed char yycheck_[];

    /// For a state, its accessing symbol.
    static const unsigned char yystos_[];

    /// For a rule, its LHS.
    static const unsigned char yyr1_[];
    /// For a rule, its RHS length.
    static const unsigned char yyr2_[]; 

    /// Convert the symbol name \a n to a form suitable for a diagnostic.
    static std::string yytnamerr_ (const char *n);


    /// For a symbol, its name in clear.
    static const char* const yytname_[];
#if YYDEBUG
    /// A type to store symbol numbers and -1.
    typedef signed char rhs_number_type;
    /// A `-1'-separated list of the rules' RHS.
    static const rhs_number_type yyrhs_[];
    /// For each rule, the index of the first RHS symbol in \a yyrhs_.
    static const unsigned char yyprhs_[];
    /// For each rule, its source line number.
    static const unsigned char yyrline_[];
    /// For each scanner token number, its symbol number.
    static const unsigned short int yytoken_number_[];
    /// Report on the debug stream that the rule \a r is going to be reduced.
    virtual void yy_reduce_print_ (int r);
    /// Print the state stack on the debug stream.
    virtual void yystack_print_ ();

    /* Debugging.  */
    int yydebug_;
    std::ostream* yycdebug_;
#endif

    /// Convert a scanner token number \a t to a symbol number.
    token_number_type yytranslate_ (int t);

    /// \brief Reclaim the memory associated to a symbol.
    /// \param yymsg        Why this token is reclaimed.
    ///                     If null, do not display the symbol, just free it.
    /// \param yytype       The symbol type.
    /// \param yyvaluep     Its semantic value.
    /// \param yylocationp  Its location.
    inline void yydestruct_ (const char* yymsg,
			     int yytype,
			     semantic_type* yyvaluep,
			     location_type* yylocationp);

    /// Pop \a n symbols the three stacks.
    inline void yypop_ (unsigned int n = 1);

    /* Constants.  */
    static const int yyeof_;
    /* LAST_ -- Last index in TABLE_.  */
    static const int yylast_;
    static const int yynnts_;
    static const int yyempty_;
    static const int yyfinal_;
    static const int yyterror_;
    static const int yyerrcode_;
    static const int yyntokens_;
    static const unsigned int yyuser_token_number_max_;
    static const token_number_type yyundef_token_;

    /* User arguments.  */
    QJson::ParserPrivate* driver;
  };

}Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\json_parser.hh:66
  2021-07-25 14:52:12  [ main:1013 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\json_parser.hh
  2021-07-25 14:52:12  [ main:1014 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\json_scanner.cc
  2021-07-25 14:52:12  [ main:1415 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\json_scanner.cpp
  2021-07-25 14:52:12  [ main:1423 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\json_scanner.h
  2021-07-25 14:52:12  [ main:1423 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\location.hh
  2021-07-25 14:52:12  [ main:1424 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\parser.cpp
  2021-07-25 14:52:12  [ main:1436 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\parser.h
  2021-07-25 14:52:12  [ main:1437 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\parserrunnable.cpp
  2021-07-25 14:52:12  [ main:1444 ] - [ ERROR ]  parsing error 
QT_BEGIN_NAMESPACE
  2021-07-25 14:52:12  [ main:1444 ] - [ ERROR ]  warning: parse error QT_BEGIN_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\parserrunnable.h:29
  2021-07-25 14:52:12  [ main:1445 ] - [ ERROR ]  parsing error 
QT_END_NAMESPACE
  2021-07-25 14:52:12  [ main:1445 ] - [ ERROR ]  warning: parse error QT_END_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\parserrunnable.h:31
  2021-07-25 14:52:12  [ main:1445 ] - [ ERROR ]  parsing error 
class QJSON_EXPORT ParserRunnable  : public QObject, public QRunnable
  {
    Q_OBJECT
    public:
      explicit ParserRunnable(QObject* parent = 0);
      ~ParserRunnable();

      void setData( const QByteArray& data );

      void run();

    Q_SIGNALS:
      /**
      * This signal is emitted when the parsing process has been completed
      * @param json contains the result of the parsing
      * @param ok if a parsing error occurs ok is set to false, otherwise it's set to true.
      * @param error_msg contains a string explaining the failure reason
      **/
      void parsingFinished(const QVariant& json, bool ok, const QString& error_msg);

    private:
      Q_DISABLE_COPY(ParserRunnable)
      class Private;
      Private* const d;
  };
  2021-07-25 14:52:12  [ main:1445 ] - [ ERROR ]  warning: parse error class QJSON_EXPORT ParserRunnable  : public QObject, public QRunnable
  {
    Q_OBJECT
    public:
      explicit ParserRunnable(QObject* parent = 0);
      ~ParserRunnable();

      void setData( const QByteArray& data );

      void run();

    Q_SIGNALS:
      /**
      * This signal is emitted when the parsing process has been completed
      * @param json contains the result of the parsing
      * @param ok if a parsing error occurs ok is set to false, otherwise it's set to true.
      * @param error_msg contains a string explaining the failure reason
      **/
      void parsingFinished(const QVariant& json, bool ok, const QString& error_msg);

    private:
      Q_DISABLE_COPY(ParserRunnable)
      class Private;
      Private* const d;
  };Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\parserrunnable.h:37
  2021-07-25 14:52:12  [ main:1450 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\parserrunnable.h
  2021-07-25 14:52:12  [ main:1450 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\parser_p.h
  2021-07-25 14:52:12  [ main:1451 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\position.hh
  2021-07-25 14:52:12  [ main:1464 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\qjson_debug.h
  2021-07-25 14:52:12  [ main:1465 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\qjson_export.h
  2021-07-25 14:52:12  [ main:1466 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\qobjecthelper.cpp
  2021-07-25 14:52:12  [ main:1473 ] - [ ERROR ]  parsing error 
QT_BEGIN_NAMESPACE
  2021-07-25 14:52:12  [ main:1474 ] - [ ERROR ]  warning: parse error QT_BEGIN_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\qobjecthelper.h:30
  2021-07-25 14:52:12  [ main:1474 ] - [ ERROR ]  parsing error 
QT_END_NAMESPACE
  2021-07-25 14:52:12  [ main:1474 ] - [ ERROR ]  warning: parse error QT_END_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\qobjecthelper.h:32
  2021-07-25 14:52:12  [ main:1474 ] - [ ERROR ]  parsing error 
class QJSON_EXPORT QObjectHelper {
    public:
      QObjectHelper();
      ~QObjectHelper();

    /**
    * This method converts a QObject instance into a QVariantMap.
    *
    * @param object The QObject instance to be converted.
    * @param ignoredProperties Properties that won't be converted.
    */
    static QVariantMap qobject2qvariant( const QObject* object,
                                  const QStringList& ignoredProperties = QStringList(QString(QLatin1String("objectName"))));

    /**
    * This method converts a QVariantMap instance into a QObject
    *
    * @param variant Attributes to assign to the object.
    * @param object The QObject instance to update.
    */
    static void qvariant2qobject(const QVariantMap& variant, QObject* object);

    private:
      Q_DISABLE_COPY(QObjectHelper)
      class QObjectHelperPrivate;
      QObjectHelperPrivate* const d;
  };
  2021-07-25 14:52:12  [ main:1474 ] - [ ERROR ]  warning: parse error class QJSON_EXPORT QObjectHelper {
    public:
      QObjectHelper();
      ~QObjectHelper();

    /**
    * This method converts a QObject instance into a QVariantMap.
    *
    * @param object The QObject instance to be converted.
    * @param ignoredProperties Properties that won't be converted.
    */
    static QVariantMap qobject2qvariant( const QObject* object,
                                  const QStringList& ignoredProperties = QStringList(QString(QLatin1String("objectName"))));

    /**
    * This method converts a QVariantMap instance into a QObject
    *
    * @param variant Attributes to assign to the object.
    * @param object The QObject instance to update.
    */
    static void qvariant2qobject(const QVariantMap& variant, QObject* object);

    private:
      Q_DISABLE_COPY(QObjectHelper)
      class QObjectHelperPrivate;
      QObjectHelperPrivate* const d;
  };Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\qobjecthelper.h:118
  2021-07-25 14:52:12  [ main:1479 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\qobjecthelper.h
  2021-07-25 14:52:12  [ main:1480 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\serializer.cpp
  2021-07-25 14:52:12  [ main:1497 ] - [ ERROR ]  warning: parse error Q_FOREACH( const QByteArray& i, list ) {
    if ( !res.isEmpty() )
      res += sep;
    res += i;
  }Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializer.cpp:55
  2021-07-25 14:52:12  [ main:1497 ] - [ ERROR ]  warning: parse error Q_FOREACH( const QVariant& var, list )
    {
      indentLevel++;
      QByteArray serializedValue = serialize( var, ok, indentLevel);
      indentLevel--;
      if ( !*ok ) {
        break;
      }
      values << serializedValue;
    }Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializer.cpp:72
  2021-07-25 14:52:12  [ main:1510 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\serializer.h
  2021-07-25 14:52:12  [ main:1510 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\serializerrunnable.cpp
  2021-07-25 14:52:12  [ main:1518 ] - [ ERROR ]  parsing error 
QT_BEGIN_NAMESPACE
  2021-07-25 14:52:12  [ main:1518 ] - [ ERROR ]  warning: parse error QT_BEGIN_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializerrunnable.h:29
  2021-07-25 14:52:12  [ main:1518 ] - [ ERROR ]  parsing error 
QT_END_NAMESPACE
  2021-07-25 14:52:12  [ main:1518 ] - [ ERROR ]  warning: parse error QT_END_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializerrunnable.h:33
  2021-07-25 14:52:12  [ main:1518 ] - [ ERROR ]  parsing error 
class QJSON_EXPORT SerializerRunnable  : public QObject, public QRunnable
  {
    Q_OBJECT
    public:
      explicit SerializerRunnable(QObject* parent = 0);
      ~SerializerRunnable();

      /**
       * Sets the json object to serialize.
       *
       * @param json QVariant containing the json representation to be serialized
       */
      void setJsonObject( const QVariant& json );

      /* reimp */ void run();

    Q_SIGNALS:
      /**
      * This signal is emitted when the serialization process has been completed
      * @param serialized contains the result of the serialization
      * @param ok if a serialization error occurs ok is set to false, otherwise it's set to true.
      * @param error_msg contains a string explaining the failure reason
      **/
      void parsingFinished(const QByteArray& serialized, bool ok, const QString& error_msg);

    private:
      Q_DISABLE_COPY(SerializerRunnable)
      class Private;
      Private* const d;
  };
  2021-07-25 14:52:12  [ main:1519 ] - [ ERROR ]  warning: parse error class QJSON_EXPORT SerializerRunnable  : public QObject, public QRunnable
  {
    Q_OBJECT
    public:
      explicit SerializerRunnable(QObject* parent = 0);
      ~SerializerRunnable();

      /**
       * Sets the json object to serialize.
       *
       * @param json QVariant containing the json representation to be serialized
       */
      void setJsonObject( const QVariant& json );

      /* reimp */ void run();

    Q_SIGNALS:
      /**
      * This signal is emitted when the serialization process has been completed
      * @param serialized contains the result of the serialization
      * @param ok if a serialization error occurs ok is set to false, otherwise it's set to true.
      * @param error_msg contains a string explaining the failure reason
      **/
      void parsingFinished(const QByteArray& serialized, bool ok, const QString& error_msg);

    private:
      Q_DISABLE_COPY(SerializerRunnable)
      class Private;
      Private* const d;
  };Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializerrunnable.h:39
  2021-07-25 14:52:12  [ main:1524 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\serializerrunnable.h
  2021-07-25 14:52:12  [ main:1524 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\stack.hh
  2021-07-25 14:52:12  [ main:1527 ] - [ INFO ]  start dependency
  2021-07-25 14:52:12  [ main:1600 ] - [ INFO ]  includenum:73
  2021-07-25 14:52:12  [ main:1601 ] - [ INFO ]  definenum:81
  2021-07-25 14:52:12  [ main:1601 ] - [ INFO ]  callnum:45
  2021-07-25 14:52:12  [ main:1601 ] - [ INFO ]  returnnum:159
  2021-07-25 14:52:12  [ main:1601 ] - [ INFO ]  parameternum:614
  2021-07-25 14:52:12  [ main:1601 ] - [ INFO ]  extendnum:1
  2021-07-25 14:52:12  [ main:1601 ] - [ INFO ]  overridenum:1
  2021-07-25 14:52:12  [ main:1715 ] - [ INFO ]  Process finish!
  2021-07-25 14:52:40  [ main:0 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\phantompy.cpp
  2021-07-25 14:52:40  [ main:449 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 14:52:40  [ main:496 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\frame.hpp:11
  2021-07-25 14:52:40  [ main:498 ] - [ ERROR ]  parsing error 
private slots:
    void loadFinished(bool ok);
  2021-07-25 14:52:40  [ main:498 ] - [ ERROR ]  warning: parse error private slots:
    void loadFinished(bool ok);Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\frame.hpp:38
  2021-07-25 14:52:40  [ main:502 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 14:52:40  [ main:502 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\image.hpp:9
  2021-07-25 14:52:40  [ main:520 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 14:52:40  [ main:520 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\timeout.hpp:9
  2021-07-25 14:52:40  [ main:520 ] - [ ERROR ]  parsing error 
private slots:
    void handleTimeout();
  2021-07-25 14:52:40  [ main:520 ] - [ ERROR ]  warning: parse error private slots:
    void handleTimeout();Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\timeout.hpp:22
  2021-07-25 14:52:40  [ main:530 ] - [ ERROR ]  parsing error 
QT_BEGIN_NAMESPACE
  2021-07-25 14:52:40  [ main:530 ] - [ ERROR ]  warning: parse error QT_BEGIN_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\parser.h:26
  2021-07-25 14:52:40  [ main:530 ] - [ ERROR ]  parsing error 
QT_END_NAMESPACE
  2021-07-25 14:52:40  [ main:530 ] - [ ERROR ]  warning: parse error QT_END_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\parser.h:29
  2021-07-25 14:52:40  [ main:531 ] - [ ERROR ]  parsing error 
class QJSON_EXPORT Parser
  {
    public:
      Parser();
      ~Parser();

      /**
      * Read JSON string from the I/O Device and converts it to a QVariant object
      * @param io Input output device
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true.
      * @returns a QVariant object generated from the JSON string
      */
      QVariant parse(QIODevice* io, bool* ok = 0);

      /**
      * This is a method provided for convenience.
      * @param jsonData data containing the JSON object representation
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true.
      * @returns a QVariant object generated from the JSON string
      * @sa errorString
      * @sa errorLine
      */
      QVariant parse(const QByteArray& jsonData, bool* ok = 0);

      /**
      * This method returns the error message
      * @returns a QString object containing the error message of the last parse operation
      * @sa errorLine
      */
      QString errorString() const;

      /**
      * This method returns line number where the error occurred
      * @returns the line number where the error occurred
      * @sa errorString
      */
      int errorLine() const;

      /**
       * Sets whether special numbers (Infinity, -Infinity, NaN) are allowed as an extension to
       * the standard
       * @param  allowSpecialNumbers new value of whether special numbers are allowed
       * @sa specialNumbersAllowed
       */
      void allowSpecialNumbers(bool allowSpecialNumbers);

      /**
       * @returns whether special numbers (Infinity, -Infinity, NaN) are allowed
       * @sa allowSpecialNumbers
       */
      bool specialNumbersAllowed() const;

    private:
      Q_DISABLE_COPY(Parser)
      ParserPrivate* const d;
  };
  2021-07-25 14:52:40  [ main:531 ] - [ ERROR ]  warning: parse error class QJSON_EXPORT Parser
  {
    public:
      Parser();
      ~Parser();

      /**
      * Read JSON string from the I/O Device and converts it to a QVariant object
      * @param io Input output device
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true.
      * @returns a QVariant object generated from the JSON string
      */
      QVariant parse(QIODevice* io, bool* ok = 0);

      /**
      * This is a method provided for convenience.
      * @param jsonData data containing the JSON object representation
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true.
      * @returns a QVariant object generated from the JSON string
      * @sa errorString
      * @sa errorLine
      */
      QVariant parse(const QByteArray& jsonData, bool* ok = 0);

      /**
      * This method returns the error message
      * @returns a QString object containing the error message of the last parse operation
      * @sa errorLine
      */
      QString errorString() const;

      /**
      * This method returns line number where the error occurred
      * @returns the line number where the error occurred
      * @sa errorString
      */
      int errorLine() const;

      /**
       * Sets whether special numbers (Infinity, -Infinity, NaN) are allowed as an extension to
       * the standard
       * @param  allowSpecialNumbers new value of whether special numbers are allowed
       * @sa specialNumbersAllowed
       */
      void allowSpecialNumbers(bool allowSpecialNumbers);

      /**
       * @returns whether special numbers (Infinity, -Infinity, NaN) are allowed
       * @sa allowSpecialNumbers
       */
      bool specialNumbersAllowed() const;

    private:
      Q_DISABLE_COPY(Parser)
      ParserPrivate* const d;
  };Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\parser.h:41
  2021-07-25 14:52:40  [ main:546 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 14:52:40  [ main:546 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\networkmanager.hpp:11
  2021-07-25 14:52:40  [ main:547 ] - [ ERROR ]  parsing error 
signals:
    void replyReceived(const QVariantMap &reply);
  2021-07-25 14:52:40  [ main:547 ] - [ ERROR ]  warning: parse error signals:
    void replyReceived(const QVariantMap &reply);Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\networkmanager.hpp:29
  2021-07-25 14:52:40  [ main:547 ] - [ ERROR ]  parsing error 
private slots:
    void provideAuthentication(QNetworkReply *reply, QAuthenticator *authenticator);
  2021-07-25 14:52:40  [ main:547 ] - [ ERROR ]  warning: parse error private slots:
    void provideAuthentication(QNetworkReply *reply, QAuthenticator *authenticator);Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\networkmanager.hpp:35
  2021-07-25 14:52:40  [ main:550 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 14:52:40  [ main:550 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\networkmanagerproxy.hpp:10
  2021-07-25 14:52:40  [ main:551 ] - [ ERROR ]  parsing error 
private slots:
    void finished();
  2021-07-25 14:52:40  [ main:551 ] - [ ERROR ]  warning: parse error private slots:
    void finished();Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\networkmanagerproxy.hpp:25
  2021-07-25 14:52:40  [ main:555 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 14:52:40  [ main:555 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\page.hpp:19
  2021-07-25 14:52:40  [ main:556 ] - [ ERROR ]  parsing error 
private slots:
    void loadFinished(bool ok);
  2021-07-25 14:52:40  [ main:556 ] - [ ERROR ]  warning: parse error private slots:
    void loadFinished(bool ok);Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\page.hpp:57
  2021-07-25 14:52:40  [ main:559 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 14:52:40  [ main:559 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\eventprocessor.hpp:9
  2021-07-25 14:52:40  [ main:560 ] - [ ERROR ]  parsing error 
private slots:
    void handleTimeout();
  2021-07-25 14:52:40  [ main:560 ] - [ ERROR ]  warning: parse error private slots:
    void handleTimeout();Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\eventprocessor.hpp:23
  2021-07-25 14:52:40  [ main:563 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 14:52:40  [ main:563 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\webelement.hpp:11
  2021-07-25 14:52:40  [ main:565 ] - [ ERROR ]  parsing error 
private slots:
    void loadFinished(bool ok);
  2021-07-25 14:52:40  [ main:565 ] - [ ERROR ]  warning: parse error private slots:
    void loadFinished(bool ok);Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\webelement.hpp:69
  2021-07-25 14:52:40  [ main:569 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 14:52:40  [ main:570 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\webelementcollection.hpp:11
  2021-07-25 14:52:40  [ main:588 ] - [ ERROR ]  parsing error 
QT_BEGIN_NAMESPACE
  2021-07-25 14:52:40  [ main:588 ] - [ ERROR ]  warning: parse error QT_BEGIN_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializer.h:26
  2021-07-25 14:52:40  [ main:588 ] - [ ERROR ]  parsing error 
QT_END_NAMESPACE
  2021-07-25 14:52:40  [ main:589 ] - [ ERROR ]  warning: parse error QT_END_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializer.h:30
  2021-07-25 14:52:40  [ main:589 ] - [ ERROR ]  parsing error 
class QJSON_EXPORT Serializer {
  public:
    Serializer();
    ~Serializer();

     /**
      * This method generates a textual JSON representation and outputs it to the
      * passed in I/O Device.
      * @param variant The JSON document in its in-memory representation as generated by the
      * parser.
      * @param out Input output device
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true
      */
    void serialize( const QVariant& variant, QIODevice* out, bool* ok);

    /**
      * This is a method provided for convenience. It turns the passed in in-memory
      * representation of the JSON document into a textual one, which is returned.
      * If the returned string is empty, the document was empty. If it was null, there
      * was a parsing error.
      *
      * @param variant The JSON document in its in-memory representation as generated by the
      * parser.
      *
      * \deprecated This method is going to be removed with the next major release of QJson.
      */
    QByteArray serialize( const QVariant& variant);

    /**
      * This is a method provided for convenience. It turns the passed in in-memory
      * representation of the JSON document into a textual one, which is returned.
      * If the returned string is empty, the document was empty. If it was null, there
      * was a parsing error.
      *
      * @param variant The JSON document in its in-memory representation as generated by the
      * parser.
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true
      */
    QByteArray serialize( const QVariant& variant, bool *ok);

    /**
     * Allow or disallow writing of NaN and/or Infinity (as an extension to QJson)
     */
    void allowSpecialNumbers(bool allow);

    /**
     * Is Nan and/or Infinity allowed?
     */
    bool specialNumbersAllowed() const;

    /**
     * set output indentation mode as defined in QJson::IndentMode
     */
    void setIndentMode(IndentMode mode = QJson::IndentNone);


    /**
    * set double precision used while converting Double
    * \sa QByteArray::number
    */
    void setDoublePrecision(int precision);

    /**
     * Returns one of the indentation modes defined in QJson::IndentMode
     */
    IndentMode indentMode() const;

    /**
     * Returns the error message
     */
    QString errorMessage() const;

  private:
    Q_DISABLE_COPY(Serializer)
    class SerializerPrivate;
    SerializerPrivate* const d;
  };
  2021-07-25 14:52:40  [ main:589 ] - [ ERROR ]  warning: parse error class QJSON_EXPORT Serializer {
  public:
    Serializer();
    ~Serializer();

     /**
      * This method generates a textual JSON representation and outputs it to the
      * passed in I/O Device.
      * @param variant The JSON document in its in-memory representation as generated by the
      * parser.
      * @param out Input output device
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true
      */
    void serialize( const QVariant& variant, QIODevice* out, bool* ok);

    /**
      * This is a method provided for convenience. It turns the passed in in-memory
      * representation of the JSON document into a textual one, which is returned.
      * If the returned string is empty, the document was empty. If it was null, there
      * was a parsing error.
      *
      * @param variant The JSON document in its in-memory representation as generated by the
      * parser.
      *
      * \deprecated This method is going to be removed with the next major release of QJson.
      */
    QByteArray serialize( const QVariant& variant);

    /**
      * This is a method provided for convenience. It turns the passed in in-memory
      * representation of the JSON document into a textual one, which is returned.
      * If the returned string is empty, the document was empty. If it was null, there
      * was a parsing error.
      *
      * @param variant The JSON document in its in-memory representation as generated by the
      * parser.
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true
      */
    QByteArray serialize( const QVariant& variant, bool *ok);

    /**
     * Allow or disallow writing of NaN and/or Infinity (as an extension to QJson)
     */
    void allowSpecialNumbers(bool allow);

    /**
     * Is Nan and/or Infinity allowed?
     */
    bool specialNumbersAllowed() const;

    /**
     * set output indentation mode as defined in QJson::IndentMode
     */
    void setIndentMode(IndentMode mode = QJson::IndentNone);


    /**
    * set double precision used while converting Double
    * \sa QByteArray::number
    */
    void setDoublePrecision(int precision);

    /**
     * Returns one of the indentation modes defined in QJson::IndentMode
     */
    IndentMode indentMode() const;

    /**
     * Returns the error message
     */
    QString errorMessage() const;

  private:
    Q_DISABLE_COPY(Serializer)
    class SerializerPrivate;
    SerializerPrivate* const d;
  };Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializer.h:112
  2021-07-25 14:52:40  [ main:593 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 14:52:40  [ main:593 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\cookiejar.hpp:14
  2021-07-25 14:52:41  [ main:655 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\phantompy.hpp
  2021-07-25 14:52:41  [ main:656 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\context.cpp
  2021-07-25 14:52:41  [ main:680 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\context.hpp
  2021-07-25 14:52:41  [ main:681 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\cookiejar.cpp
  2021-07-25 14:52:41  [ main:701 ] - [ ERROR ]  warning: parse error foreach(QNetworkCookie n_cookie, cookiesForUrl(QUrl(url))) {
        cookie["name"] = QString::fromUtf8(n_cookie.name());
        cookie["value"] = QString::fromUtf8(n_cookie.value());
        cookie["domain"] = n_cookie.domain();
        cookie["path"] = n_cookie.path();
        cookie["expires"] = n_cookie.expirationDate().toString(Qt::ISODate);

        cookiesList.append(cookie);
    }Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\cookiejar.cpp:112
  2021-07-25 14:52:41  [ main:702 ] - [ ERROR ]  warning: parse error foreach(QNetworkCookie n_cookie, allCookies()) {
        cookie["name"] = QString::fromUtf8(n_cookie.name());
        cookie["value"] = QString::fromUtf8(n_cookie.value());
        cookie["domain"] = n_cookie.domain();
        cookie["path"] = n_cookie.path();
        cookie["expires"] = n_cookie.expirationDate().toString(Qt::ISODate);

        cookiesList.append(cookie);
    }Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\cookiejar.cpp:129
  2021-07-25 14:52:41  [ main:703 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\cookiejar.hpp
  2021-07-25 14:52:41  [ main:704 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\eventprocessor.cpp
  2021-07-25 14:52:41  [ main:711 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\eventprocessor.hpp
  2021-07-25 14:52:41  [ main:712 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\frame.cpp
  2021-07-25 14:52:41  [ main:740 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\frame.hpp
  2021-07-25 14:52:41  [ main:741 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\image.cpp
  2021-07-25 14:52:41  [ main:746 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\image.hpp
  2021-07-25 14:52:41  [ main:747 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\networkmanager.cpp
  2021-07-25 14:52:41  [ main:752 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 14:52:41  [ main:752 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\networktimeout.hpp:10
  2021-07-25 14:52:41  [ main:758 ] - [ ERROR ]  warning: parse error foreach (QByteArray headerName, reply->rawHeaderList()) {
        QVariantMap header;
        header["name"] = QString::fromUtf8(headerName);
        header["value"] = QString::fromUtf8(reply->rawHeader(headerName));

        headers.append(header);
    }Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\networkmanager.cpp:69
  2021-07-25 14:52:41  [ main:760 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\networkmanager.hpp
  2021-07-25 14:52:41  [ main:761 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\networkmanagerproxy.cpp
  2021-07-25 14:52:41  [ main:767 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\networkmanagerproxy.hpp
  2021-07-25 14:52:41  [ main:768 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\networktimeout.cpp
  2021-07-25 14:52:41  [ main:772 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\networktimeout.hpp
  2021-07-25 14:52:41  [ main:772 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\page.cpp
  2021-07-25 14:52:41  [ main:782 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\page.hpp
  2021-07-25 14:52:41  [ main:783 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\timeout.cpp
  2021-07-25 14:52:41  [ main:788 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\timeout.hpp
  2021-07-25 14:52:41  [ main:789 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\webelement.cpp
  2021-07-25 14:52:41  [ main:799 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\webelement.hpp
  2021-07-25 14:52:41  [ main:799 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\webelementcollection.cpp
  2021-07-25 14:52:41  [ main:804 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\webelementcollection.hpp
  2021-07-25 14:52:41  [ main:805 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\FlexLexer.h
  2021-07-25 14:52:41  [ main:815 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\json_parser.cc
  2021-07-25 14:52:41  [ main:892 ] - [ ERROR ]  parsing error 
Q_DECLARE_METATYPE(QVector<QVariant>*)
  Q_DECLARE_METATYPE(QVariantMap*)


/* Line 33 of lalr1.cc  */
#line 72 "json_parser.hh"


#include <string>
#include <iostream>
#include "stack.hh"
#include "location.hh"

/* Enabling traces.  */
#ifndef YYDEBUG
# define YYDEBUG 1
#endif


namespace yy {
/* Line 33 of lalr1.cc  */
#line 88 "json_parser.hh"

  /// A Bison parser.
  class json_parser
  {
  public:
    /// Symbol semantic values.
#ifndef YYSTYPE
    typedef int semantic_type;
#else
    typedef YYSTYPE semantic_type;
#endif
    /// Symbol locations.
    typedef location location_type;
    /// Tokens.
    struct token
    {
      /* Tokens.  */
   enum yytokentype {
     END = 0,
     CURLY_BRACKET_OPEN = 1,
     CURLY_BRACKET_CLOSE = 2,
     SQUARE_BRACKET_OPEN = 3,
     SQUARE_BRACKET_CLOSE = 4,
     COLON = 5,
     COMMA = 6,
     NUMBER = 7,
     TRUE_VAL = 8,
     FALSE_VAL = 9,
     NULL_VAL = 10,
     STRING = 11,
     INVALID = 12
   };

    };
    /// Token type.
    typedef token::yytokentype token_type;

    /// Build a parser object.
    json_parser (QJson::ParserPrivate* driver_yyarg);
    virtual ~json_parser ();

    /// Parse.
    /// \returns  0 iff parsing succeeded.
    virtual int parse ();

#if YYDEBUG
    /// The current debugging stream.
    std::ostream& debug_stream () const;
    /// Set the current debugging stream.
    void set_debug_stream (std::ostream &);

    /// Type for debugging levels.
    typedef int debug_level_type;
    /// The current debugging level.
    debug_level_type debug_level () const;
    /// Set the current debugging level.
    void set_debug_level (debug_level_type l);
#endif

  private:
    /// Report a syntax error.
    /// \param loc    where the syntax error is found.
    /// \param msg    a description of the syntax error.
    virtual void error (const location_type& loc, const std::string& msg);

    /// Generate an error message.
    /// \param state   the state where the error occurred.
    /// \param tok     the lookahead token.
    virtual std::string yysyntax_error_ (int yystate, int tok);

#if YYDEBUG
    /// \brief Report a symbol value on the debug stream.
    /// \param yytype       The token type.
    /// \param yyvaluep     Its semantic value.
    /// \param yylocationp  Its location.
    virtual void yy_symbol_value_print_ (int yytype,
					 const semantic_type* yyvaluep,
					 const location_type* yylocationp);
    /// \brief Report a symbol on the debug stream.
    /// \param yytype       The token type.
    /// \param yyvaluep     Its semantic value.
    /// \param yylocationp  Its location.
    virtual void yy_symbol_print_ (int yytype,
				   const semantic_type* yyvaluep,
				   const location_type* yylocationp);
#endif


    /// State numbers.
    typedef int state_type;
    /// State stack type.
    typedef stack<state_type>    state_stack_type;
    /// Semantic value stack type.
    typedef stack<semantic_type> semantic_stack_type;
    /// location stack type.
    typedef stack<location_type> location_stack_type;

    /// The state stack.
    state_stack_type yystate_stack_;
    /// The semantic value stack.
    semantic_stack_type yysemantic_stack_;
    /// The location stack.
    location_stack_type yylocation_stack_;

    /// Whether the given \c yypact_ value indicates a defaulted state.
    /// \param yyvalue   the value to check
    static bool yy_pact_value_is_default_ (int yyvalue);

    /// Whether the given \c yytable_ value indicates a syntax error.
    /// \param yyvalue   the value to check
    static bool yy_table_value_is_error_ (int yyvalue);

    /// Internal symbol numbers.
    typedef unsigned char token_number_type;
    /* Tables.  */
    /// For a state, the index in \a yytable_ of its portion.
    static const signed char yypact_[];
    static const signed char yypact_ninf_;

    /// For a state, default reduction number.
    /// Unless\a  yytable_ specifies something else to do.
    /// Zero means the default is an error.
    static const unsigned char yydefact_[];

    static const signed char yypgoto_[];
    static const signed char yydefgoto_[];

    /// What to do in a state.
    /// \a yytable_[yypact_[s]]: what to do in state \a s.
    /// - if positive, shift that token.
    /// - if negative, reduce the rule which number is the opposite.
    /// - if zero, do what YYDEFACT says.
    static const unsigned char yytable_[];
    static const signed char yytable_ninf_;

    static const signed char yycheck_[];

    /// For a state, its accessing symbol.
    static const unsigned char yystos_[];

    /// For a rule, its LHS.
    static const unsigned char yyr1_[];
    /// For a rule, its RHS length.
    static const unsigned char yyr2_[]; 

    /// Convert the symbol name \a n to a form suitable for a diagnostic.
    static std::string yytnamerr_ (const char *n);


    /// For a symbol, its name in clear.
    static const char* const yytname_[];
#if YYDEBUG
    /// A type to store symbol numbers and -1.
    typedef signed char rhs_number_type;
    /// A `-1'-separated list of the rules' RHS.
    static const rhs_number_type yyrhs_[];
    /// For each rule, the index of the first RHS symbol in \a yyrhs_.
    static const unsigned char yyprhs_[];
    /// For each rule, its source line number.
    static const unsigned char yyrline_[];
    /// For each scanner token number, its symbol number.
    static const unsigned short int yytoken_number_[];
    /// Report on the debug stream that the rule \a r is going to be reduced.
    virtual void yy_reduce_print_ (int r);
    /// Print the state stack on the debug stream.
    virtual void yystack_print_ ();

    /* Debugging.  */
    int yydebug_;
    std::ostream* yycdebug_;
#endif

    /// Convert a scanner token number \a t to a symbol number.
    token_number_type yytranslate_ (int t);

    /// \brief Reclaim the memory associated to a symbol.
    /// \param yymsg        Why this token is reclaimed.
    ///                     If null, do not display the symbol, just free it.
    /// \param yytype       The symbol type.
    /// \param yyvaluep     Its semantic value.
    /// \param yylocationp  Its location.
    inline void yydestruct_ (const char* yymsg,
			     int yytype,
			     semantic_type* yyvaluep,
			     location_type* yylocationp);

    /// Pop \a n symbols the three stacks.
    inline void yypop_ (unsigned int n = 1);

    /* Constants.  */
    static const int yyeof_;
    /* LAST_ -- Last index in TABLE_.  */
    static const int yylast_;
    static const int yynnts_;
    static const int yyempty_;
    static const int yyfinal_;
    static const int yyterror_;
    static const int yyerrcode_;
    static const int yyntokens_;
    static const unsigned int yyuser_token_number_max_;
    static const token_number_type yyundef_token_;

    /* User arguments.  */
    QJson::ParserPrivate* driver;
  };

}
  2021-07-25 14:52:41  [ main:892 ] - [ ERROR ]  warning: parse error Q_DECLARE_METATYPE(QVector<QVariant>*)
  Q_DECLARE_METATYPE(QVariantMap*)


/* Line 33 of lalr1.cc  */
#line 72 "json_parser.hh"


#include <string>
#include <iostream>
#include "stack.hh"
#include "location.hh"

/* Enabling traces.  */
#ifndef YYDEBUG
# define YYDEBUG 1
#endif


namespace yy {
/* Line 33 of lalr1.cc  */
#line 88 "json_parser.hh"

  /// A Bison parser.
  class json_parser
  {
  public:
    /// Symbol semantic values.
#ifndef YYSTYPE
    typedef int semantic_type;
#else
    typedef YYSTYPE semantic_type;
#endif
    /// Symbol locations.
    typedef location location_type;
    /// Tokens.
    struct token
    {
      /* Tokens.  */
   enum yytokentype {
     END = 0,
     CURLY_BRACKET_OPEN = 1,
     CURLY_BRACKET_CLOSE = 2,
     SQUARE_BRACKET_OPEN = 3,
     SQUARE_BRACKET_CLOSE = 4,
     COLON = 5,
     COMMA = 6,
     NUMBER = 7,
     TRUE_VAL = 8,
     FALSE_VAL = 9,
     NULL_VAL = 10,
     STRING = 11,
     INVALID = 12
   };

    };
    /// Token type.
    typedef token::yytokentype token_type;

    /// Build a parser object.
    json_parser (QJson::ParserPrivate* driver_yyarg);
    virtual ~json_parser ();

    /// Parse.
    /// \returns  0 iff parsing succeeded.
    virtual int parse ();

#if YYDEBUG
    /// The current debugging stream.
    std::ostream& debug_stream () const;
    /// Set the current debugging stream.
    void set_debug_stream (std::ostream &);

    /// Type for debugging levels.
    typedef int debug_level_type;
    /// The current debugging level.
    debug_level_type debug_level () const;
    /// Set the current debugging level.
    void set_debug_level (debug_level_type l);
#endif

  private:
    /// Report a syntax error.
    /// \param loc    where the syntax error is found.
    /// \param msg    a description of the syntax error.
    virtual void error (const location_type& loc, const std::string& msg);

    /// Generate an error message.
    /// \param state   the state where the error occurred.
    /// \param tok     the lookahead token.
    virtual std::string yysyntax_error_ (int yystate, int tok);

#if YYDEBUG
    /// \brief Report a symbol value on the debug stream.
    /// \param yytype       The token type.
    /// \param yyvaluep     Its semantic value.
    /// \param yylocationp  Its location.
    virtual void yy_symbol_value_print_ (int yytype,
					 const semantic_type* yyvaluep,
					 const location_type* yylocationp);
    /// \brief Report a symbol on the debug stream.
    /// \param yytype       The token type.
    /// \param yyvaluep     Its semantic value.
    /// \param yylocationp  Its location.
    virtual void yy_symbol_print_ (int yytype,
				   const semantic_type* yyvaluep,
				   const location_type* yylocationp);
#endif


    /// State numbers.
    typedef int state_type;
    /// State stack type.
    typedef stack<state_type>    state_stack_type;
    /// Semantic value stack type.
    typedef stack<semantic_type> semantic_stack_type;
    /// location stack type.
    typedef stack<location_type> location_stack_type;

    /// The state stack.
    state_stack_type yystate_stack_;
    /// The semantic value stack.
    semantic_stack_type yysemantic_stack_;
    /// The location stack.
    location_stack_type yylocation_stack_;

    /// Whether the given \c yypact_ value indicates a defaulted state.
    /// \param yyvalue   the value to check
    static bool yy_pact_value_is_default_ (int yyvalue);

    /// Whether the given \c yytable_ value indicates a syntax error.
    /// \param yyvalue   the value to check
    static bool yy_table_value_is_error_ (int yyvalue);

    /// Internal symbol numbers.
    typedef unsigned char token_number_type;
    /* Tables.  */
    /// For a state, the index in \a yytable_ of its portion.
    static const signed char yypact_[];
    static const signed char yypact_ninf_;

    /// For a state, default reduction number.
    /// Unless\a  yytable_ specifies something else to do.
    /// Zero means the default is an error.
    static const unsigned char yydefact_[];

    static const signed char yypgoto_[];
    static const signed char yydefgoto_[];

    /// What to do in a state.
    /// \a yytable_[yypact_[s]]: what to do in state \a s.
    /// - if positive, shift that token.
    /// - if negative, reduce the rule which number is the opposite.
    /// - if zero, do what YYDEFACT says.
    static const unsigned char yytable_[];
    static const signed char yytable_ninf_;

    static const signed char yycheck_[];

    /// For a state, its accessing symbol.
    static const unsigned char yystos_[];

    /// For a rule, its LHS.
    static const unsigned char yyr1_[];
    /// For a rule, its RHS length.
    static const unsigned char yyr2_[]; 

    /// Convert the symbol name \a n to a form suitable for a diagnostic.
    static std::string yytnamerr_ (const char *n);


    /// For a symbol, its name in clear.
    static const char* const yytname_[];
#if YYDEBUG
    /// A type to store symbol numbers and -1.
    typedef signed char rhs_number_type;
    /// A `-1'-separated list of the rules' RHS.
    static const rhs_number_type yyrhs_[];
    /// For each rule, the index of the first RHS symbol in \a yyrhs_.
    static const unsigned char yyprhs_[];
    /// For each rule, its source line number.
    static const unsigned char yyrline_[];
    /// For each scanner token number, its symbol number.
    static const unsigned short int yytoken_number_[];
    /// Report on the debug stream that the rule \a r is going to be reduced.
    virtual void yy_reduce_print_ (int r);
    /// Print the state stack on the debug stream.
    virtual void yystack_print_ ();

    /* Debugging.  */
    int yydebug_;
    std::ostream* yycdebug_;
#endif

    /// Convert a scanner token number \a t to a symbol number.
    token_number_type yytranslate_ (int t);

    /// \brief Reclaim the memory associated to a symbol.
    /// \param yymsg        Why this token is reclaimed.
    ///                     If null, do not display the symbol, just free it.
    /// \param yytype       The symbol type.
    /// \param yyvaluep     Its semantic value.
    /// \param yylocationp  Its location.
    inline void yydestruct_ (const char* yymsg,
			     int yytype,
			     semantic_type* yyvaluep,
			     location_type* yylocationp);

    /// Pop \a n symbols the three stacks.
    inline void yypop_ (unsigned int n = 1);

    /* Constants.  */
    static const int yyeof_;
    /* LAST_ -- Last index in TABLE_.  */
    static const int yylast_;
    static const int yynnts_;
    static const int yyempty_;
    static const int yyfinal_;
    static const int yyterror_;
    static const int yyerrcode_;
    static const int yyntokens_;
    static const unsigned int yyuser_token_number_max_;
    static const token_number_type yyundef_token_;

    /* User arguments.  */
    QJson::ParserPrivate* driver;
  };

}Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\json_parser.hh:66
  2021-07-25 14:52:41  [ main:936 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\json_parser.hh
  2021-07-25 14:52:41  [ main:937 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\json_scanner.cc
  2021-07-25 14:52:41  [ main:1335 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\json_scanner.cpp
  2021-07-25 14:52:41  [ main:1342 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\json_scanner.h
  2021-07-25 14:52:41  [ main:1343 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\location.hh
  2021-07-25 14:52:41  [ main:1343 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\parser.cpp
  2021-07-25 14:52:41  [ main:1353 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\parser.h
  2021-07-25 14:52:41  [ main:1354 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\parserrunnable.cpp
  2021-07-25 14:52:41  [ main:1361 ] - [ ERROR ]  parsing error 
QT_BEGIN_NAMESPACE
  2021-07-25 14:52:41  [ main:1361 ] - [ ERROR ]  warning: parse error QT_BEGIN_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\parserrunnable.h:29
  2021-07-25 14:52:41  [ main:1361 ] - [ ERROR ]  parsing error 
QT_END_NAMESPACE
  2021-07-25 14:52:41  [ main:1361 ] - [ ERROR ]  warning: parse error QT_END_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\parserrunnable.h:31
  2021-07-25 14:52:41  [ main:1361 ] - [ ERROR ]  parsing error 
class QJSON_EXPORT ParserRunnable  : public QObject, public QRunnable
  {
    Q_OBJECT
    public:
      explicit ParserRunnable(QObject* parent = 0);
      ~ParserRunnable();

      void setData( const QByteArray& data );

      void run();

    Q_SIGNALS:
      /**
      * This signal is emitted when the parsing process has been completed
      * @param json contains the result of the parsing
      * @param ok if a parsing error occurs ok is set to false, otherwise it's set to true.
      * @param error_msg contains a string explaining the failure reason
      **/
      void parsingFinished(const QVariant& json, bool ok, const QString& error_msg);

    private:
      Q_DISABLE_COPY(ParserRunnable)
      class Private;
      Private* const d;
  };
  2021-07-25 14:52:41  [ main:1361 ] - [ ERROR ]  warning: parse error class QJSON_EXPORT ParserRunnable  : public QObject, public QRunnable
  {
    Q_OBJECT
    public:
      explicit ParserRunnable(QObject* parent = 0);
      ~ParserRunnable();

      void setData( const QByteArray& data );

      void run();

    Q_SIGNALS:
      /**
      * This signal is emitted when the parsing process has been completed
      * @param json contains the result of the parsing
      * @param ok if a parsing error occurs ok is set to false, otherwise it's set to true.
      * @param error_msg contains a string explaining the failure reason
      **/
      void parsingFinished(const QVariant& json, bool ok, const QString& error_msg);

    private:
      Q_DISABLE_COPY(ParserRunnable)
      class Private;
      Private* const d;
  };Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\parserrunnable.h:37
  2021-07-25 14:52:41  [ main:1365 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\parserrunnable.h
  2021-07-25 14:52:41  [ main:1366 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\parser_p.h
  2021-07-25 14:52:41  [ main:1366 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\position.hh
  2021-07-25 14:52:41  [ main:1375 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\qjson_debug.h
  2021-07-25 14:52:41  [ main:1376 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\qjson_export.h
  2021-07-25 14:52:41  [ main:1377 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\qobjecthelper.cpp
  2021-07-25 14:52:41  [ main:1384 ] - [ ERROR ]  parsing error 
QT_BEGIN_NAMESPACE
  2021-07-25 14:52:41  [ main:1384 ] - [ ERROR ]  warning: parse error QT_BEGIN_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\qobjecthelper.h:30
  2021-07-25 14:52:41  [ main:1384 ] - [ ERROR ]  parsing error 
QT_END_NAMESPACE
  2021-07-25 14:52:41  [ main:1384 ] - [ ERROR ]  warning: parse error QT_END_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\qobjecthelper.h:32
  2021-07-25 14:52:41  [ main:1384 ] - [ ERROR ]  parsing error 
class QJSON_EXPORT QObjectHelper {
    public:
      QObjectHelper();
      ~QObjectHelper();

    /**
    * This method converts a QObject instance into a QVariantMap.
    *
    * @param object The QObject instance to be converted.
    * @param ignoredProperties Properties that won't be converted.
    */
    static QVariantMap qobject2qvariant( const QObject* object,
                                  const QStringList& ignoredProperties = QStringList(QString(QLatin1String("objectName"))));

    /**
    * This method converts a QVariantMap instance into a QObject
    *
    * @param variant Attributes to assign to the object.
    * @param object The QObject instance to update.
    */
    static void qvariant2qobject(const QVariantMap& variant, QObject* object);

    private:
      Q_DISABLE_COPY(QObjectHelper)
      class QObjectHelperPrivate;
      QObjectHelperPrivate* const d;
  };
  2021-07-25 14:52:41  [ main:1384 ] - [ ERROR ]  warning: parse error class QJSON_EXPORT QObjectHelper {
    public:
      QObjectHelper();
      ~QObjectHelper();

    /**
    * This method converts a QObject instance into a QVariantMap.
    *
    * @param object The QObject instance to be converted.
    * @param ignoredProperties Properties that won't be converted.
    */
    static QVariantMap qobject2qvariant( const QObject* object,
                                  const QStringList& ignoredProperties = QStringList(QString(QLatin1String("objectName"))));

    /**
    * This method converts a QVariantMap instance into a QObject
    *
    * @param variant Attributes to assign to the object.
    * @param object The QObject instance to update.
    */
    static void qvariant2qobject(const QVariantMap& variant, QObject* object);

    private:
      Q_DISABLE_COPY(QObjectHelper)
      class QObjectHelperPrivate;
      QObjectHelperPrivate* const d;
  };Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\qobjecthelper.h:118
  2021-07-25 14:52:41  [ main:1390 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\qobjecthelper.h
  2021-07-25 14:52:41  [ main:1391 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\serializer.cpp
  2021-07-25 14:52:41  [ main:1408 ] - [ ERROR ]  warning: parse error Q_FOREACH( const QByteArray& i, list ) {
    if ( !res.isEmpty() )
      res += sep;
    res += i;
  }Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializer.cpp:55
  2021-07-25 14:52:41  [ main:1409 ] - [ ERROR ]  warning: parse error Q_FOREACH( const QVariant& var, list )
    {
      indentLevel++;
      QByteArray serializedValue = serialize( var, ok, indentLevel);
      indentLevel--;
      if ( !*ok ) {
        break;
      }
      values << serializedValue;
    }Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializer.cpp:72
  2021-07-25 14:52:41  [ main:1420 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\serializer.h
  2021-07-25 14:52:41  [ main:1421 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\serializerrunnable.cpp
  2021-07-25 14:52:41  [ main:1428 ] - [ ERROR ]  parsing error 
QT_BEGIN_NAMESPACE
  2021-07-25 14:52:41  [ main:1428 ] - [ ERROR ]  warning: parse error QT_BEGIN_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializerrunnable.h:29
  2021-07-25 14:52:41  [ main:1428 ] - [ ERROR ]  parsing error 
QT_END_NAMESPACE
  2021-07-25 14:52:41  [ main:1428 ] - [ ERROR ]  warning: parse error QT_END_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializerrunnable.h:33
  2021-07-25 14:52:41  [ main:1428 ] - [ ERROR ]  parsing error 
class QJSON_EXPORT SerializerRunnable  : public QObject, public QRunnable
  {
    Q_OBJECT
    public:
      explicit SerializerRunnable(QObject* parent = 0);
      ~SerializerRunnable();

      /**
       * Sets the json object to serialize.
       *
       * @param json QVariant containing the json representation to be serialized
       */
      void setJsonObject( const QVariant& json );

      /* reimp */ void run();

    Q_SIGNALS:
      /**
      * This signal is emitted when the serialization process has been completed
      * @param serialized contains the result of the serialization
      * @param ok if a serialization error occurs ok is set to false, otherwise it's set to true.
      * @param error_msg contains a string explaining the failure reason
      **/
      void parsingFinished(const QByteArray& serialized, bool ok, const QString& error_msg);

    private:
      Q_DISABLE_COPY(SerializerRunnable)
      class Private;
      Private* const d;
  };
  2021-07-25 14:52:41  [ main:1428 ] - [ ERROR ]  warning: parse error class QJSON_EXPORT SerializerRunnable  : public QObject, public QRunnable
  {
    Q_OBJECT
    public:
      explicit SerializerRunnable(QObject* parent = 0);
      ~SerializerRunnable();

      /**
       * Sets the json object to serialize.
       *
       * @param json QVariant containing the json representation to be serialized
       */
      void setJsonObject( const QVariant& json );

      /* reimp */ void run();

    Q_SIGNALS:
      /**
      * This signal is emitted when the serialization process has been completed
      * @param serialized contains the result of the serialization
      * @param ok if a serialization error occurs ok is set to false, otherwise it's set to true.
      * @param error_msg contains a string explaining the failure reason
      **/
      void parsingFinished(const QByteArray& serialized, bool ok, const QString& error_msg);

    private:
      Q_DISABLE_COPY(SerializerRunnable)
      class Private;
      Private* const d;
  };Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializerrunnable.h:39
  2021-07-25 14:52:41  [ main:1432 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\serializerrunnable.h
  2021-07-25 14:52:41  [ main:1432 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\stack.hh
  2021-07-25 14:52:41  [ main:1434 ] - [ INFO ]  start dependency
  2021-07-25 14:52:41  [ main:1512 ] - [ INFO ]  includenum:73
  2021-07-25 14:52:41  [ main:1512 ] - [ INFO ]  definenum:81
  2021-07-25 14:52:41  [ main:1512 ] - [ INFO ]  callnum:45
  2021-07-25 14:52:41  [ main:1512 ] - [ INFO ]  returnnum:159
  2021-07-25 14:52:41  [ main:1512 ] - [ INFO ]  parameternum:614
  2021-07-25 14:52:41  [ main:1512 ] - [ INFO ]  extendnum:1
  2021-07-25 14:52:41  [ main:1513 ] - [ INFO ]  overridenum:1
  2021-07-25 14:52:41  [ main:1621 ] - [ INFO ]  Process finish!
  2021-07-25 14:55:13  [ main:0 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\phantompy.cpp
  2021-07-25 14:55:14  [ main:442 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 14:55:14  [ main:490 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\frame.hpp:11
  2021-07-25 14:55:14  [ main:493 ] - [ ERROR ]  parsing error 
private slots:
    void loadFinished(bool ok);
  2021-07-25 14:55:14  [ main:493 ] - [ ERROR ]  warning: parse error private slots:
    void loadFinished(bool ok);Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\frame.hpp:38
  2021-07-25 14:55:14  [ main:497 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 14:55:14  [ main:497 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\image.hpp:9
  2021-07-25 14:55:14  [ main:514 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 14:55:14  [ main:515 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\timeout.hpp:9
  2021-07-25 14:55:14  [ main:515 ] - [ ERROR ]  parsing error 
private slots:
    void handleTimeout();
  2021-07-25 14:55:14  [ main:515 ] - [ ERROR ]  warning: parse error private slots:
    void handleTimeout();Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\timeout.hpp:22
  2021-07-25 14:55:14  [ main:524 ] - [ ERROR ]  parsing error 
QT_BEGIN_NAMESPACE
  2021-07-25 14:55:14  [ main:524 ] - [ ERROR ]  warning: parse error QT_BEGIN_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\parser.h:26
  2021-07-25 14:55:14  [ main:524 ] - [ ERROR ]  parsing error 
QT_END_NAMESPACE
  2021-07-25 14:55:14  [ main:524 ] - [ ERROR ]  warning: parse error QT_END_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\parser.h:29
  2021-07-25 14:55:14  [ main:525 ] - [ ERROR ]  parsing error 
class QJSON_EXPORT Parser
  {
    public:
      Parser();
      ~Parser();

      /**
      * Read JSON string from the I/O Device and converts it to a QVariant object
      * @param io Input output device
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true.
      * @returns a QVariant object generated from the JSON string
      */
      QVariant parse(QIODevice* io, bool* ok = 0);

      /**
      * This is a method provided for convenience.
      * @param jsonData data containing the JSON object representation
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true.
      * @returns a QVariant object generated from the JSON string
      * @sa errorString
      * @sa errorLine
      */
      QVariant parse(const QByteArray& jsonData, bool* ok = 0);

      /**
      * This method returns the error message
      * @returns a QString object containing the error message of the last parse operation
      * @sa errorLine
      */
      QString errorString() const;

      /**
      * This method returns line number where the error occurred
      * @returns the line number where the error occurred
      * @sa errorString
      */
      int errorLine() const;

      /**
       * Sets whether special numbers (Infinity, -Infinity, NaN) are allowed as an extension to
       * the standard
       * @param  allowSpecialNumbers new value of whether special numbers are allowed
       * @sa specialNumbersAllowed
       */
      void allowSpecialNumbers(bool allowSpecialNumbers);

      /**
       * @returns whether special numbers (Infinity, -Infinity, NaN) are allowed
       * @sa allowSpecialNumbers
       */
      bool specialNumbersAllowed() const;

    private:
      Q_DISABLE_COPY(Parser)
      ParserPrivate* const d;
  };
  2021-07-25 14:55:14  [ main:526 ] - [ ERROR ]  warning: parse error class QJSON_EXPORT Parser
  {
    public:
      Parser();
      ~Parser();

      /**
      * Read JSON string from the I/O Device and converts it to a QVariant object
      * @param io Input output device
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true.
      * @returns a QVariant object generated from the JSON string
      */
      QVariant parse(QIODevice* io, bool* ok = 0);

      /**
      * This is a method provided for convenience.
      * @param jsonData data containing the JSON object representation
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true.
      * @returns a QVariant object generated from the JSON string
      * @sa errorString
      * @sa errorLine
      */
      QVariant parse(const QByteArray& jsonData, bool* ok = 0);

      /**
      * This method returns the error message
      * @returns a QString object containing the error message of the last parse operation
      * @sa errorLine
      */
      QString errorString() const;

      /**
      * This method returns line number where the error occurred
      * @returns the line number where the error occurred
      * @sa errorString
      */
      int errorLine() const;

      /**
       * Sets whether special numbers (Infinity, -Infinity, NaN) are allowed as an extension to
       * the standard
       * @param  allowSpecialNumbers new value of whether special numbers are allowed
       * @sa specialNumbersAllowed
       */
      void allowSpecialNumbers(bool allowSpecialNumbers);

      /**
       * @returns whether special numbers (Infinity, -Infinity, NaN) are allowed
       * @sa allowSpecialNumbers
       */
      bool specialNumbersAllowed() const;

    private:
      Q_DISABLE_COPY(Parser)
      ParserPrivate* const d;
  };Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\parser.h:41
  2021-07-25 14:55:14  [ main:540 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 14:55:14  [ main:541 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\networkmanager.hpp:11
  2021-07-25 14:55:14  [ main:541 ] - [ ERROR ]  parsing error 
signals:
    void replyReceived(const QVariantMap &reply);
  2021-07-25 14:55:14  [ main:541 ] - [ ERROR ]  warning: parse error signals:
    void replyReceived(const QVariantMap &reply);Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\networkmanager.hpp:29
  2021-07-25 14:55:14  [ main:541 ] - [ ERROR ]  parsing error 
private slots:
    void provideAuthentication(QNetworkReply *reply, QAuthenticator *authenticator);
  2021-07-25 14:55:14  [ main:542 ] - [ ERROR ]  warning: parse error private slots:
    void provideAuthentication(QNetworkReply *reply, QAuthenticator *authenticator);Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\networkmanager.hpp:35
  2021-07-25 14:55:14  [ main:545 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 14:55:14  [ main:545 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\networkmanagerproxy.hpp:10
  2021-07-25 14:55:14  [ main:546 ] - [ ERROR ]  parsing error 
private slots:
    void finished();
  2021-07-25 14:55:14  [ main:546 ] - [ ERROR ]  warning: parse error private slots:
    void finished();Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\networkmanagerproxy.hpp:25
  2021-07-25 14:55:14  [ main:550 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 14:55:14  [ main:550 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\page.hpp:19
  2021-07-25 14:55:14  [ main:551 ] - [ ERROR ]  parsing error 
private slots:
    void loadFinished(bool ok);
  2021-07-25 14:55:14  [ main:551 ] - [ ERROR ]  warning: parse error private slots:
    void loadFinished(bool ok);Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\page.hpp:57
  2021-07-25 14:55:14  [ main:554 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 14:55:14  [ main:554 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\eventprocessor.hpp:9
  2021-07-25 14:55:14  [ main:555 ] - [ ERROR ]  parsing error 
private slots:
    void handleTimeout();
  2021-07-25 14:55:14  [ main:555 ] - [ ERROR ]  warning: parse error private slots:
    void handleTimeout();Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\eventprocessor.hpp:23
  2021-07-25 14:55:14  [ main:560 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 14:55:14  [ main:560 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\webelement.hpp:11
  2021-07-25 14:55:14  [ main:561 ] - [ ERROR ]  parsing error 
private slots:
    void loadFinished(bool ok);
  2021-07-25 14:55:14  [ main:561 ] - [ ERROR ]  warning: parse error private slots:
    void loadFinished(bool ok);Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\webelement.hpp:69
  2021-07-25 14:55:14  [ main:565 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 14:55:14  [ main:565 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\webelementcollection.hpp:11
  2021-07-25 14:55:14  [ main:584 ] - [ ERROR ]  parsing error 
QT_BEGIN_NAMESPACE
  2021-07-25 14:55:14  [ main:584 ] - [ ERROR ]  warning: parse error QT_BEGIN_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializer.h:26
  2021-07-25 14:55:14  [ main:584 ] - [ ERROR ]  parsing error 
QT_END_NAMESPACE
  2021-07-25 14:55:14  [ main:584 ] - [ ERROR ]  warning: parse error QT_END_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializer.h:30
  2021-07-25 14:55:14  [ main:584 ] - [ ERROR ]  parsing error 
class QJSON_EXPORT Serializer {
  public:
    Serializer();
    ~Serializer();

     /**
      * This method generates a textual JSON representation and outputs it to the
      * passed in I/O Device.
      * @param variant The JSON document in its in-memory representation as generated by the
      * parser.
      * @param out Input output device
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true
      */
    void serialize( const QVariant& variant, QIODevice* out, bool* ok);

    /**
      * This is a method provided for convenience. It turns the passed in in-memory
      * representation of the JSON document into a textual one, which is returned.
      * If the returned string is empty, the document was empty. If it was null, there
      * was a parsing error.
      *
      * @param variant The JSON document in its in-memory representation as generated by the
      * parser.
      *
      * \deprecated This method is going to be removed with the next major release of QJson.
      */
    QByteArray serialize( const QVariant& variant);

    /**
      * This is a method provided for convenience. It turns the passed in in-memory
      * representation of the JSON document into a textual one, which is returned.
      * If the returned string is empty, the document was empty. If it was null, there
      * was a parsing error.
      *
      * @param variant The JSON document in its in-memory representation as generated by the
      * parser.
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true
      */
    QByteArray serialize( const QVariant& variant, bool *ok);

    /**
     * Allow or disallow writing of NaN and/or Infinity (as an extension to QJson)
     */
    void allowSpecialNumbers(bool allow);

    /**
     * Is Nan and/or Infinity allowed?
     */
    bool specialNumbersAllowed() const;

    /**
     * set output indentation mode as defined in QJson::IndentMode
     */
    void setIndentMode(IndentMode mode = QJson::IndentNone);


    /**
    * set double precision used while converting Double
    * \sa QByteArray::number
    */
    void setDoublePrecision(int precision);

    /**
     * Returns one of the indentation modes defined in QJson::IndentMode
     */
    IndentMode indentMode() const;

    /**
     * Returns the error message
     */
    QString errorMessage() const;

  private:
    Q_DISABLE_COPY(Serializer)
    class SerializerPrivate;
    SerializerPrivate* const d;
  };
  2021-07-25 14:55:14  [ main:584 ] - [ ERROR ]  warning: parse error class QJSON_EXPORT Serializer {
  public:
    Serializer();
    ~Serializer();

     /**
      * This method generates a textual JSON representation and outputs it to the
      * passed in I/O Device.
      * @param variant The JSON document in its in-memory representation as generated by the
      * parser.
      * @param out Input output device
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true
      */
    void serialize( const QVariant& variant, QIODevice* out, bool* ok);

    /**
      * This is a method provided for convenience. It turns the passed in in-memory
      * representation of the JSON document into a textual one, which is returned.
      * If the returned string is empty, the document was empty. If it was null, there
      * was a parsing error.
      *
      * @param variant The JSON document in its in-memory representation as generated by the
      * parser.
      *
      * \deprecated This method is going to be removed with the next major release of QJson.
      */
    QByteArray serialize( const QVariant& variant);

    /**
      * This is a method provided for convenience. It turns the passed in in-memory
      * representation of the JSON document into a textual one, which is returned.
      * If the returned string is empty, the document was empty. If it was null, there
      * was a parsing error.
      *
      * @param variant The JSON document in its in-memory representation as generated by the
      * parser.
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true
      */
    QByteArray serialize( const QVariant& variant, bool *ok);

    /**
     * Allow or disallow writing of NaN and/or Infinity (as an extension to QJson)
     */
    void allowSpecialNumbers(bool allow);

    /**
     * Is Nan and/or Infinity allowed?
     */
    bool specialNumbersAllowed() const;

    /**
     * set output indentation mode as defined in QJson::IndentMode
     */
    void setIndentMode(IndentMode mode = QJson::IndentNone);


    /**
    * set double precision used while converting Double
    * \sa QByteArray::number
    */
    void setDoublePrecision(int precision);

    /**
     * Returns one of the indentation modes defined in QJson::IndentMode
     */
    IndentMode indentMode() const;

    /**
     * Returns the error message
     */
    QString errorMessage() const;

  private:
    Q_DISABLE_COPY(Serializer)
    class SerializerPrivate;
    SerializerPrivate* const d;
  };Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializer.h:112
  2021-07-25 14:55:14  [ main:587 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 14:55:14  [ main:588 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\cookiejar.hpp:14
  2021-07-25 14:55:14  [ main:650 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\phantompy.hpp
  2021-07-25 14:55:14  [ main:651 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\context.cpp
  2021-07-25 14:55:14  [ main:678 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\context.hpp
  2021-07-25 14:55:14  [ main:679 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\cookiejar.cpp
  2021-07-25 14:55:14  [ main:700 ] - [ ERROR ]  warning: parse error foreach(QNetworkCookie n_cookie, cookiesForUrl(QUrl(url))) {
        cookie["name"] = QString::fromUtf8(n_cookie.name());
        cookie["value"] = QString::fromUtf8(n_cookie.value());
        cookie["domain"] = n_cookie.domain();
        cookie["path"] = n_cookie.path();
        cookie["expires"] = n_cookie.expirationDate().toString(Qt::ISODate);

        cookiesList.append(cookie);
    }Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\cookiejar.cpp:112
  2021-07-25 14:55:14  [ main:700 ] - [ ERROR ]  warning: parse error foreach(QNetworkCookie n_cookie, allCookies()) {
        cookie["name"] = QString::fromUtf8(n_cookie.name());
        cookie["value"] = QString::fromUtf8(n_cookie.value());
        cookie["domain"] = n_cookie.domain();
        cookie["path"] = n_cookie.path();
        cookie["expires"] = n_cookie.expirationDate().toString(Qt::ISODate);

        cookiesList.append(cookie);
    }Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\cookiejar.cpp:129
  2021-07-25 14:55:14  [ main:701 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\cookiejar.hpp
  2021-07-25 14:55:14  [ main:702 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\eventprocessor.cpp
  2021-07-25 14:55:14  [ main:710 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\eventprocessor.hpp
  2021-07-25 14:55:14  [ main:711 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\frame.cpp
  2021-07-25 14:55:14  [ main:739 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\frame.hpp
  2021-07-25 14:55:14  [ main:740 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\image.cpp
  2021-07-25 14:55:14  [ main:746 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\image.hpp
  2021-07-25 14:55:14  [ main:747 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\networkmanager.cpp
  2021-07-25 14:55:14  [ main:755 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 14:55:14  [ main:755 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\networktimeout.hpp:10
  2021-07-25 14:55:14  [ main:762 ] - [ ERROR ]  warning: parse error foreach (QByteArray headerName, reply->rawHeaderList()) {
        QVariantMap header;
        header["name"] = QString::fromUtf8(headerName);
        header["value"] = QString::fromUtf8(reply->rawHeader(headerName));

        headers.append(header);
    }Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\networkmanager.cpp:69
  2021-07-25 14:55:14  [ main:764 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\networkmanager.hpp
  2021-07-25 14:55:14  [ main:765 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\networkmanagerproxy.cpp
  2021-07-25 14:55:14  [ main:772 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\networkmanagerproxy.hpp
  2021-07-25 14:55:14  [ main:772 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\networktimeout.cpp
  2021-07-25 14:55:14  [ main:778 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\networktimeout.hpp
  2021-07-25 14:55:14  [ main:778 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\page.cpp
  2021-07-25 14:55:14  [ main:789 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\page.hpp
  2021-07-25 14:55:14  [ main:790 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\timeout.cpp
  2021-07-25 14:55:14  [ main:796 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\timeout.hpp
  2021-07-25 14:55:14  [ main:797 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\webelement.cpp
  2021-07-25 14:55:14  [ main:807 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\webelement.hpp
  2021-07-25 14:55:14  [ main:808 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\webelementcollection.cpp
  2021-07-25 14:55:14  [ main:812 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\webelementcollection.hpp
  2021-07-25 14:55:14  [ main:813 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\FlexLexer.h
  2021-07-25 14:55:14  [ main:825 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\json_parser.cc
  2021-07-25 14:55:14  [ main:901 ] - [ ERROR ]  parsing error 
Q_DECLARE_METATYPE(QVector<QVariant>*)
  Q_DECLARE_METATYPE(QVariantMap*)


/* Line 33 of lalr1.cc  */
#line 72 "json_parser.hh"


#include <string>
#include <iostream>
#include "stack.hh"
#include "location.hh"

/* Enabling traces.  */
#ifndef YYDEBUG
# define YYDEBUG 1
#endif


namespace yy {
/* Line 33 of lalr1.cc  */
#line 88 "json_parser.hh"

  /// A Bison parser.
  class json_parser
  {
  public:
    /// Symbol semantic values.
#ifndef YYSTYPE
    typedef int semantic_type;
#else
    typedef YYSTYPE semantic_type;
#endif
    /// Symbol locations.
    typedef location location_type;
    /// Tokens.
    struct token
    {
      /* Tokens.  */
   enum yytokentype {
     END = 0,
     CURLY_BRACKET_OPEN = 1,
     CURLY_BRACKET_CLOSE = 2,
     SQUARE_BRACKET_OPEN = 3,
     SQUARE_BRACKET_CLOSE = 4,
     COLON = 5,
     COMMA = 6,
     NUMBER = 7,
     TRUE_VAL = 8,
     FALSE_VAL = 9,
     NULL_VAL = 10,
     STRING = 11,
     INVALID = 12
   };

    };
    /// Token type.
    typedef token::yytokentype token_type;

    /// Build a parser object.
    json_parser (QJson::ParserPrivate* driver_yyarg);
    virtual ~json_parser ();

    /// Parse.
    /// \returns  0 iff parsing succeeded.
    virtual int parse ();

#if YYDEBUG
    /// The current debugging stream.
    std::ostream& debug_stream () const;
    /// Set the current debugging stream.
    void set_debug_stream (std::ostream &);

    /// Type for debugging levels.
    typedef int debug_level_type;
    /// The current debugging level.
    debug_level_type debug_level () const;
    /// Set the current debugging level.
    void set_debug_level (debug_level_type l);
#endif

  private:
    /// Report a syntax error.
    /// \param loc    where the syntax error is found.
    /// \param msg    a description of the syntax error.
    virtual void error (const location_type& loc, const std::string& msg);

    /// Generate an error message.
    /// \param state   the state where the error occurred.
    /// \param tok     the lookahead token.
    virtual std::string yysyntax_error_ (int yystate, int tok);

#if YYDEBUG
    /// \brief Report a symbol value on the debug stream.
    /// \param yytype       The token type.
    /// \param yyvaluep     Its semantic value.
    /// \param yylocationp  Its location.
    virtual void yy_symbol_value_print_ (int yytype,
					 const semantic_type* yyvaluep,
					 const location_type* yylocationp);
    /// \brief Report a symbol on the debug stream.
    /// \param yytype       The token type.
    /// \param yyvaluep     Its semantic value.
    /// \param yylocationp  Its location.
    virtual void yy_symbol_print_ (int yytype,
				   const semantic_type* yyvaluep,
				   const location_type* yylocationp);
#endif


    /// State numbers.
    typedef int state_type;
    /// State stack type.
    typedef stack<state_type>    state_stack_type;
    /// Semantic value stack type.
    typedef stack<semantic_type> semantic_stack_type;
    /// location stack type.
    typedef stack<location_type> location_stack_type;

    /// The state stack.
    state_stack_type yystate_stack_;
    /// The semantic value stack.
    semantic_stack_type yysemantic_stack_;
    /// The location stack.
    location_stack_type yylocation_stack_;

    /// Whether the given \c yypact_ value indicates a defaulted state.
    /// \param yyvalue   the value to check
    static bool yy_pact_value_is_default_ (int yyvalue);

    /// Whether the given \c yytable_ value indicates a syntax error.
    /// \param yyvalue   the value to check
    static bool yy_table_value_is_error_ (int yyvalue);

    /// Internal symbol numbers.
    typedef unsigned char token_number_type;
    /* Tables.  */
    /// For a state, the index in \a yytable_ of its portion.
    static const signed char yypact_[];
    static const signed char yypact_ninf_;

    /// For a state, default reduction number.
    /// Unless\a  yytable_ specifies something else to do.
    /// Zero means the default is an error.
    static const unsigned char yydefact_[];

    static const signed char yypgoto_[];
    static const signed char yydefgoto_[];

    /// What to do in a state.
    /// \a yytable_[yypact_[s]]: what to do in state \a s.
    /// - if positive, shift that token.
    /// - if negative, reduce the rule which number is the opposite.
    /// - if zero, do what YYDEFACT says.
    static const unsigned char yytable_[];
    static const signed char yytable_ninf_;

    static const signed char yycheck_[];

    /// For a state, its accessing symbol.
    static const unsigned char yystos_[];

    /// For a rule, its LHS.
    static const unsigned char yyr1_[];
    /// For a rule, its RHS length.
    static const unsigned char yyr2_[]; 

    /// Convert the symbol name \a n to a form suitable for a diagnostic.
    static std::string yytnamerr_ (const char *n);


    /// For a symbol, its name in clear.
    static const char* const yytname_[];
#if YYDEBUG
    /// A type to store symbol numbers and -1.
    typedef signed char rhs_number_type;
    /// A `-1'-separated list of the rules' RHS.
    static const rhs_number_type yyrhs_[];
    /// For each rule, the index of the first RHS symbol in \a yyrhs_.
    static const unsigned char yyprhs_[];
    /// For each rule, its source line number.
    static const unsigned char yyrline_[];
    /// For each scanner token number, its symbol number.
    static const unsigned short int yytoken_number_[];
    /// Report on the debug stream that the rule \a r is going to be reduced.
    virtual void yy_reduce_print_ (int r);
    /// Print the state stack on the debug stream.
    virtual void yystack_print_ ();

    /* Debugging.  */
    int yydebug_;
    std::ostream* yycdebug_;
#endif

    /// Convert a scanner token number \a t to a symbol number.
    token_number_type yytranslate_ (int t);

    /// \brief Reclaim the memory associated to a symbol.
    /// \param yymsg        Why this token is reclaimed.
    ///                     If null, do not display the symbol, just free it.
    /// \param yytype       The symbol type.
    /// \param yyvaluep     Its semantic value.
    /// \param yylocationp  Its location.
    inline void yydestruct_ (const char* yymsg,
			     int yytype,
			     semantic_type* yyvaluep,
			     location_type* yylocationp);

    /// Pop \a n symbols the three stacks.
    inline void yypop_ (unsigned int n = 1);

    /* Constants.  */
    static const int yyeof_;
    /* LAST_ -- Last index in TABLE_.  */
    static const int yylast_;
    static const int yynnts_;
    static const int yyempty_;
    static const int yyfinal_;
    static const int yyterror_;
    static const int yyerrcode_;
    static const int yyntokens_;
    static const unsigned int yyuser_token_number_max_;
    static const token_number_type yyundef_token_;

    /* User arguments.  */
    QJson::ParserPrivate* driver;
  };

}
  2021-07-25 14:55:14  [ main:901 ] - [ ERROR ]  warning: parse error Q_DECLARE_METATYPE(QVector<QVariant>*)
  Q_DECLARE_METATYPE(QVariantMap*)


/* Line 33 of lalr1.cc  */
#line 72 "json_parser.hh"


#include <string>
#include <iostream>
#include "stack.hh"
#include "location.hh"

/* Enabling traces.  */
#ifndef YYDEBUG
# define YYDEBUG 1
#endif


namespace yy {
/* Line 33 of lalr1.cc  */
#line 88 "json_parser.hh"

  /// A Bison parser.
  class json_parser
  {
  public:
    /// Symbol semantic values.
#ifndef YYSTYPE
    typedef int semantic_type;
#else
    typedef YYSTYPE semantic_type;
#endif
    /// Symbol locations.
    typedef location location_type;
    /// Tokens.
    struct token
    {
      /* Tokens.  */
   enum yytokentype {
     END = 0,
     CURLY_BRACKET_OPEN = 1,
     CURLY_BRACKET_CLOSE = 2,
     SQUARE_BRACKET_OPEN = 3,
     SQUARE_BRACKET_CLOSE = 4,
     COLON = 5,
     COMMA = 6,
     NUMBER = 7,
     TRUE_VAL = 8,
     FALSE_VAL = 9,
     NULL_VAL = 10,
     STRING = 11,
     INVALID = 12
   };

    };
    /// Token type.
    typedef token::yytokentype token_type;

    /// Build a parser object.
    json_parser (QJson::ParserPrivate* driver_yyarg);
    virtual ~json_parser ();

    /// Parse.
    /// \returns  0 iff parsing succeeded.
    virtual int parse ();

#if YYDEBUG
    /// The current debugging stream.
    std::ostream& debug_stream () const;
    /// Set the current debugging stream.
    void set_debug_stream (std::ostream &);

    /// Type for debugging levels.
    typedef int debug_level_type;
    /// The current debugging level.
    debug_level_type debug_level () const;
    /// Set the current debugging level.
    void set_debug_level (debug_level_type l);
#endif

  private:
    /// Report a syntax error.
    /// \param loc    where the syntax error is found.
    /// \param msg    a description of the syntax error.
    virtual void error (const location_type& loc, const std::string& msg);

    /// Generate an error message.
    /// \param state   the state where the error occurred.
    /// \param tok     the lookahead token.
    virtual std::string yysyntax_error_ (int yystate, int tok);

#if YYDEBUG
    /// \brief Report a symbol value on the debug stream.
    /// \param yytype       The token type.
    /// \param yyvaluep     Its semantic value.
    /// \param yylocationp  Its location.
    virtual void yy_symbol_value_print_ (int yytype,
					 const semantic_type* yyvaluep,
					 const location_type* yylocationp);
    /// \brief Report a symbol on the debug stream.
    /// \param yytype       The token type.
    /// \param yyvaluep     Its semantic value.
    /// \param yylocationp  Its location.
    virtual void yy_symbol_print_ (int yytype,
				   const semantic_type* yyvaluep,
				   const location_type* yylocationp);
#endif


    /// State numbers.
    typedef int state_type;
    /// State stack type.
    typedef stack<state_type>    state_stack_type;
    /// Semantic value stack type.
    typedef stack<semantic_type> semantic_stack_type;
    /// location stack type.
    typedef stack<location_type> location_stack_type;

    /// The state stack.
    state_stack_type yystate_stack_;
    /// The semantic value stack.
    semantic_stack_type yysemantic_stack_;
    /// The location stack.
    location_stack_type yylocation_stack_;

    /// Whether the given \c yypact_ value indicates a defaulted state.
    /// \param yyvalue   the value to check
    static bool yy_pact_value_is_default_ (int yyvalue);

    /// Whether the given \c yytable_ value indicates a syntax error.
    /// \param yyvalue   the value to check
    static bool yy_table_value_is_error_ (int yyvalue);

    /// Internal symbol numbers.
    typedef unsigned char token_number_type;
    /* Tables.  */
    /// For a state, the index in \a yytable_ of its portion.
    static const signed char yypact_[];
    static const signed char yypact_ninf_;

    /// For a state, default reduction number.
    /// Unless\a  yytable_ specifies something else to do.
    /// Zero means the default is an error.
    static const unsigned char yydefact_[];

    static const signed char yypgoto_[];
    static const signed char yydefgoto_[];

    /// What to do in a state.
    /// \a yytable_[yypact_[s]]: what to do in state \a s.
    /// - if positive, shift that token.
    /// - if negative, reduce the rule which number is the opposite.
    /// - if zero, do what YYDEFACT says.
    static const unsigned char yytable_[];
    static const signed char yytable_ninf_;

    static const signed char yycheck_[];

    /// For a state, its accessing symbol.
    static const unsigned char yystos_[];

    /// For a rule, its LHS.
    static const unsigned char yyr1_[];
    /// For a rule, its RHS length.
    static const unsigned char yyr2_[]; 

    /// Convert the symbol name \a n to a form suitable for a diagnostic.
    static std::string yytnamerr_ (const char *n);


    /// For a symbol, its name in clear.
    static const char* const yytname_[];
#if YYDEBUG
    /// A type to store symbol numbers and -1.
    typedef signed char rhs_number_type;
    /// A `-1'-separated list of the rules' RHS.
    static const rhs_number_type yyrhs_[];
    /// For each rule, the index of the first RHS symbol in \a yyrhs_.
    static const unsigned char yyprhs_[];
    /// For each rule, its source line number.
    static const unsigned char yyrline_[];
    /// For each scanner token number, its symbol number.
    static const unsigned short int yytoken_number_[];
    /// Report on the debug stream that the rule \a r is going to be reduced.
    virtual void yy_reduce_print_ (int r);
    /// Print the state stack on the debug stream.
    virtual void yystack_print_ ();

    /* Debugging.  */
    int yydebug_;
    std::ostream* yycdebug_;
#endif

    /// Convert a scanner token number \a t to a symbol number.
    token_number_type yytranslate_ (int t);

    /// \brief Reclaim the memory associated to a symbol.
    /// \param yymsg        Why this token is reclaimed.
    ///                     If null, do not display the symbol, just free it.
    /// \param yytype       The symbol type.
    /// \param yyvaluep     Its semantic value.
    /// \param yylocationp  Its location.
    inline void yydestruct_ (const char* yymsg,
			     int yytype,
			     semantic_type* yyvaluep,
			     location_type* yylocationp);

    /// Pop \a n symbols the three stacks.
    inline void yypop_ (unsigned int n = 1);

    /* Constants.  */
    static const int yyeof_;
    /* LAST_ -- Last index in TABLE_.  */
    static const int yylast_;
    static const int yynnts_;
    static const int yyempty_;
    static const int yyfinal_;
    static const int yyterror_;
    static const int yyerrcode_;
    static const int yyntokens_;
    static const unsigned int yyuser_token_number_max_;
    static const token_number_type yyundef_token_;

    /* User arguments.  */
    QJson::ParserPrivate* driver;
  };

}Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\json_parser.hh:66
  2021-07-25 14:55:14  [ main:945 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\json_parser.hh
  2021-07-25 14:55:14  [ main:946 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\json_scanner.cc
  2021-07-25 14:55:14  [ main:1282 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\json_scanner.cpp
  2021-07-25 14:55:14  [ main:1289 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\json_scanner.h
  2021-07-25 14:55:14  [ main:1290 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\location.hh
  2021-07-25 14:55:14  [ main:1290 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\parser.cpp
  2021-07-25 14:55:14  [ main:1300 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\parser.h
  2021-07-25 14:55:14  [ main:1301 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\parserrunnable.cpp
  2021-07-25 14:55:14  [ main:1308 ] - [ ERROR ]  parsing error 
QT_BEGIN_NAMESPACE
  2021-07-25 14:55:14  [ main:1309 ] - [ ERROR ]  warning: parse error QT_BEGIN_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\parserrunnable.h:29
  2021-07-25 14:55:14  [ main:1309 ] - [ ERROR ]  parsing error 
QT_END_NAMESPACE
  2021-07-25 14:55:14  [ main:1309 ] - [ ERROR ]  warning: parse error QT_END_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\parserrunnable.h:31
  2021-07-25 14:55:14  [ main:1309 ] - [ ERROR ]  parsing error 
class QJSON_EXPORT ParserRunnable  : public QObject, public QRunnable
  {
    Q_OBJECT
    public:
      explicit ParserRunnable(QObject* parent = 0);
      ~ParserRunnable();

      void setData( const QByteArray& data );

      void run();

    Q_SIGNALS:
      /**
      * This signal is emitted when the parsing process has been completed
      * @param json contains the result of the parsing
      * @param ok if a parsing error occurs ok is set to false, otherwise it's set to true.
      * @param error_msg contains a string explaining the failure reason
      **/
      void parsingFinished(const QVariant& json, bool ok, const QString& error_msg);

    private:
      Q_DISABLE_COPY(ParserRunnable)
      class Private;
      Private* const d;
  };
  2021-07-25 14:55:14  [ main:1309 ] - [ ERROR ]  warning: parse error class QJSON_EXPORT ParserRunnable  : public QObject, public QRunnable
  {
    Q_OBJECT
    public:
      explicit ParserRunnable(QObject* parent = 0);
      ~ParserRunnable();

      void setData( const QByteArray& data );

      void run();

    Q_SIGNALS:
      /**
      * This signal is emitted when the parsing process has been completed
      * @param json contains the result of the parsing
      * @param ok if a parsing error occurs ok is set to false, otherwise it's set to true.
      * @param error_msg contains a string explaining the failure reason
      **/
      void parsingFinished(const QVariant& json, bool ok, const QString& error_msg);

    private:
      Q_DISABLE_COPY(ParserRunnable)
      class Private;
      Private* const d;
  };Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\parserrunnable.h:37
  2021-07-25 14:55:14  [ main:1314 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\parserrunnable.h
  2021-07-25 14:55:14  [ main:1315 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\parser_p.h
  2021-07-25 14:55:14  [ main:1315 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\position.hh
  2021-07-25 14:55:14  [ main:1324 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\qjson_debug.h
  2021-07-25 14:55:14  [ main:1325 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\qjson_export.h
  2021-07-25 14:55:14  [ main:1326 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\qobjecthelper.cpp
  2021-07-25 14:55:14  [ main:1333 ] - [ ERROR ]  parsing error 
QT_BEGIN_NAMESPACE
  2021-07-25 14:55:14  [ main:1333 ] - [ ERROR ]  warning: parse error QT_BEGIN_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\qobjecthelper.h:30
  2021-07-25 14:55:14  [ main:1333 ] - [ ERROR ]  parsing error 
QT_END_NAMESPACE
  2021-07-25 14:55:14  [ main:1333 ] - [ ERROR ]  warning: parse error QT_END_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\qobjecthelper.h:32
  2021-07-25 14:55:14  [ main:1333 ] - [ ERROR ]  parsing error 
class QJSON_EXPORT QObjectHelper {
    public:
      QObjectHelper();
      ~QObjectHelper();

    /**
    * This method converts a QObject instance into a QVariantMap.
    *
    * @param object The QObject instance to be converted.
    * @param ignoredProperties Properties that won't be converted.
    */
    static QVariantMap qobject2qvariant( const QObject* object,
                                  const QStringList& ignoredProperties = QStringList(QString(QLatin1String("objectName"))));

    /**
    * This method converts a QVariantMap instance into a QObject
    *
    * @param variant Attributes to assign to the object.
    * @param object The QObject instance to update.
    */
    static void qvariant2qobject(const QVariantMap& variant, QObject* object);

    private:
      Q_DISABLE_COPY(QObjectHelper)
      class QObjectHelperPrivate;
      QObjectHelperPrivate* const d;
  };
  2021-07-25 14:55:14  [ main:1333 ] - [ ERROR ]  warning: parse error class QJSON_EXPORT QObjectHelper {
    public:
      QObjectHelper();
      ~QObjectHelper();

    /**
    * This method converts a QObject instance into a QVariantMap.
    *
    * @param object The QObject instance to be converted.
    * @param ignoredProperties Properties that won't be converted.
    */
    static QVariantMap qobject2qvariant( const QObject* object,
                                  const QStringList& ignoredProperties = QStringList(QString(QLatin1String("objectName"))));

    /**
    * This method converts a QVariantMap instance into a QObject
    *
    * @param variant Attributes to assign to the object.
    * @param object The QObject instance to update.
    */
    static void qvariant2qobject(const QVariantMap& variant, QObject* object);

    private:
      Q_DISABLE_COPY(QObjectHelper)
      class QObjectHelperPrivate;
      QObjectHelperPrivate* const d;
  };Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\qobjecthelper.h:118
  2021-07-25 14:55:14  [ main:1339 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\qobjecthelper.h
  2021-07-25 14:55:14  [ main:1340 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\serializer.cpp
  2021-07-25 14:55:14  [ main:1356 ] - [ ERROR ]  warning: parse error Q_FOREACH( const QByteArray& i, list ) {
    if ( !res.isEmpty() )
      res += sep;
    res += i;
  }Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializer.cpp:55
  2021-07-25 14:55:14  [ main:1357 ] - [ ERROR ]  warning: parse error Q_FOREACH( const QVariant& var, list )
    {
      indentLevel++;
      QByteArray serializedValue = serialize( var, ok, indentLevel);
      indentLevel--;
      if ( !*ok ) {
        break;
      }
      values << serializedValue;
    }Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializer.cpp:72
  2021-07-25 14:55:15  [ main:1369 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\serializer.h
  2021-07-25 14:55:15  [ main:1370 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\serializerrunnable.cpp
  2021-07-25 14:55:15  [ main:1376 ] - [ ERROR ]  parsing error 
QT_BEGIN_NAMESPACE
  2021-07-25 14:55:15  [ main:1377 ] - [ ERROR ]  warning: parse error QT_BEGIN_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializerrunnable.h:29
  2021-07-25 14:55:15  [ main:1377 ] - [ ERROR ]  parsing error 
QT_END_NAMESPACE
  2021-07-25 14:55:15  [ main:1377 ] - [ ERROR ]  warning: parse error QT_END_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializerrunnable.h:33
  2021-07-25 14:55:15  [ main:1377 ] - [ ERROR ]  parsing error 
class QJSON_EXPORT SerializerRunnable  : public QObject, public QRunnable
  {
    Q_OBJECT
    public:
      explicit SerializerRunnable(QObject* parent = 0);
      ~SerializerRunnable();

      /**
       * Sets the json object to serialize.
       *
       * @param json QVariant containing the json representation to be serialized
       */
      void setJsonObject( const QVariant& json );

      /* reimp */ void run();

    Q_SIGNALS:
      /**
      * This signal is emitted when the serialization process has been completed
      * @param serialized contains the result of the serialization
      * @param ok if a serialization error occurs ok is set to false, otherwise it's set to true.
      * @param error_msg contains a string explaining the failure reason
      **/
      void parsingFinished(const QByteArray& serialized, bool ok, const QString& error_msg);

    private:
      Q_DISABLE_COPY(SerializerRunnable)
      class Private;
      Private* const d;
  };
  2021-07-25 14:55:15  [ main:1377 ] - [ ERROR ]  warning: parse error class QJSON_EXPORT SerializerRunnable  : public QObject, public QRunnable
  {
    Q_OBJECT
    public:
      explicit SerializerRunnable(QObject* parent = 0);
      ~SerializerRunnable();

      /**
       * Sets the json object to serialize.
       *
       * @param json QVariant containing the json representation to be serialized
       */
      void setJsonObject( const QVariant& json );

      /* reimp */ void run();

    Q_SIGNALS:
      /**
      * This signal is emitted when the serialization process has been completed
      * @param serialized contains the result of the serialization
      * @param ok if a serialization error occurs ok is set to false, otherwise it's set to true.
      * @param error_msg contains a string explaining the failure reason
      **/
      void parsingFinished(const QByteArray& serialized, bool ok, const QString& error_msg);

    private:
      Q_DISABLE_COPY(SerializerRunnable)
      class Private;
      Private* const d;
  };Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializerrunnable.h:39
  2021-07-25 14:55:15  [ main:1381 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\serializerrunnable.h
  2021-07-25 14:55:15  [ main:1381 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\stack.hh
  2021-07-25 14:55:15  [ main:1384 ] - [ INFO ]  start dependency
  2021-07-25 14:55:15  [ main:1460 ] - [ INFO ]  includenum:73
  2021-07-25 14:55:15  [ main:1461 ] - [ INFO ]  definenum:81
  2021-07-25 14:55:15  [ main:1461 ] - [ INFO ]  callnum:45
  2021-07-25 14:55:15  [ main:1461 ] - [ INFO ]  returnnum:159
  2021-07-25 14:55:15  [ main:1461 ] - [ INFO ]  parameternum:614
  2021-07-25 14:55:15  [ main:1461 ] - [ INFO ]  extendnum:1
  2021-07-25 14:55:15  [ main:1461 ] - [ INFO ]  overridenum:1
  2021-07-25 14:55:15  [ main:1571 ] - [ INFO ]  Process finish!
  2021-07-25 14:55:45  [ main:0 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\phantompy.cpp
  2021-07-25 14:55:45  [ main:453 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 14:55:45  [ main:500 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\frame.hpp:11
  2021-07-25 14:55:45  [ main:503 ] - [ ERROR ]  parsing error 
private slots:
    void loadFinished(bool ok);
  2021-07-25 14:55:45  [ main:503 ] - [ ERROR ]  warning: parse error private slots:
    void loadFinished(bool ok);Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\frame.hpp:38
  2021-07-25 14:55:45  [ main:508 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 14:55:45  [ main:508 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\image.hpp:9
  2021-07-25 14:55:45  [ main:526 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 14:55:45  [ main:526 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\timeout.hpp:9
  2021-07-25 14:55:45  [ main:526 ] - [ ERROR ]  parsing error 
private slots:
    void handleTimeout();
  2021-07-25 14:55:45  [ main:526 ] - [ ERROR ]  warning: parse error private slots:
    void handleTimeout();Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\timeout.hpp:22
  2021-07-25 14:55:45  [ main:535 ] - [ ERROR ]  parsing error 
QT_BEGIN_NAMESPACE
  2021-07-25 14:55:45  [ main:535 ] - [ ERROR ]  warning: parse error QT_BEGIN_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\parser.h:26
  2021-07-25 14:55:45  [ main:536 ] - [ ERROR ]  parsing error 
QT_END_NAMESPACE
  2021-07-25 14:55:45  [ main:536 ] - [ ERROR ]  warning: parse error QT_END_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\parser.h:29
  2021-07-25 14:55:45  [ main:537 ] - [ ERROR ]  parsing error 
class QJSON_EXPORT Parser
  {
    public:
      Parser();
      ~Parser();

      /**
      * Read JSON string from the I/O Device and converts it to a QVariant object
      * @param io Input output device
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true.
      * @returns a QVariant object generated from the JSON string
      */
      QVariant parse(QIODevice* io, bool* ok = 0);

      /**
      * This is a method provided for convenience.
      * @param jsonData data containing the JSON object representation
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true.
      * @returns a QVariant object generated from the JSON string
      * @sa errorString
      * @sa errorLine
      */
      QVariant parse(const QByteArray& jsonData, bool* ok = 0);

      /**
      * This method returns the error message
      * @returns a QString object containing the error message of the last parse operation
      * @sa errorLine
      */
      QString errorString() const;

      /**
      * This method returns line number where the error occurred
      * @returns the line number where the error occurred
      * @sa errorString
      */
      int errorLine() const;

      /**
       * Sets whether special numbers (Infinity, -Infinity, NaN) are allowed as an extension to
       * the standard
       * @param  allowSpecialNumbers new value of whether special numbers are allowed
       * @sa specialNumbersAllowed
       */
      void allowSpecialNumbers(bool allowSpecialNumbers);

      /**
       * @returns whether special numbers (Infinity, -Infinity, NaN) are allowed
       * @sa allowSpecialNumbers
       */
      bool specialNumbersAllowed() const;

    private:
      Q_DISABLE_COPY(Parser)
      ParserPrivate* const d;
  };
  2021-07-25 14:55:45  [ main:537 ] - [ ERROR ]  warning: parse error class QJSON_EXPORT Parser
  {
    public:
      Parser();
      ~Parser();

      /**
      * Read JSON string from the I/O Device and converts it to a QVariant object
      * @param io Input output device
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true.
      * @returns a QVariant object generated from the JSON string
      */
      QVariant parse(QIODevice* io, bool* ok = 0);

      /**
      * This is a method provided for convenience.
      * @param jsonData data containing the JSON object representation
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true.
      * @returns a QVariant object generated from the JSON string
      * @sa errorString
      * @sa errorLine
      */
      QVariant parse(const QByteArray& jsonData, bool* ok = 0);

      /**
      * This method returns the error message
      * @returns a QString object containing the error message of the last parse operation
      * @sa errorLine
      */
      QString errorString() const;

      /**
      * This method returns line number where the error occurred
      * @returns the line number where the error occurred
      * @sa errorString
      */
      int errorLine() const;

      /**
       * Sets whether special numbers (Infinity, -Infinity, NaN) are allowed as an extension to
       * the standard
       * @param  allowSpecialNumbers new value of whether special numbers are allowed
       * @sa specialNumbersAllowed
       */
      void allowSpecialNumbers(bool allowSpecialNumbers);

      /**
       * @returns whether special numbers (Infinity, -Infinity, NaN) are allowed
       * @sa allowSpecialNumbers
       */
      bool specialNumbersAllowed() const;

    private:
      Q_DISABLE_COPY(Parser)
      ParserPrivate* const d;
  };Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\parser.h:41
  2021-07-25 14:55:45  [ main:552 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 14:55:45  [ main:552 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\networkmanager.hpp:11
  2021-07-25 14:55:45  [ main:553 ] - [ ERROR ]  parsing error 
signals:
    void replyReceived(const QVariantMap &reply);
  2021-07-25 14:55:45  [ main:553 ] - [ ERROR ]  warning: parse error signals:
    void replyReceived(const QVariantMap &reply);Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\networkmanager.hpp:29
  2021-07-25 14:55:45  [ main:553 ] - [ ERROR ]  parsing error 
private slots:
    void provideAuthentication(QNetworkReply *reply, QAuthenticator *authenticator);
  2021-07-25 14:55:45  [ main:554 ] - [ ERROR ]  warning: parse error private slots:
    void provideAuthentication(QNetworkReply *reply, QAuthenticator *authenticator);Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\networkmanager.hpp:35
  2021-07-25 14:55:45  [ main:558 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 14:55:45  [ main:558 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\networkmanagerproxy.hpp:10
  2021-07-25 14:55:45  [ main:558 ] - [ ERROR ]  parsing error 
private slots:
    void finished();
  2021-07-25 14:55:45  [ main:558 ] - [ ERROR ]  warning: parse error private slots:
    void finished();Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\networkmanagerproxy.hpp:25
  2021-07-25 14:55:45  [ main:562 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 14:55:45  [ main:563 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\page.hpp:19
  2021-07-25 14:55:45  [ main:564 ] - [ ERROR ]  parsing error 
private slots:
    void loadFinished(bool ok);
  2021-07-25 14:55:45  [ main:564 ] - [ ERROR ]  warning: parse error private slots:
    void loadFinished(bool ok);Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\page.hpp:57
  2021-07-25 14:55:45  [ main:567 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 14:55:45  [ main:567 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\eventprocessor.hpp:9
  2021-07-25 14:55:45  [ main:567 ] - [ ERROR ]  parsing error 
private slots:
    void handleTimeout();
  2021-07-25 14:55:45  [ main:567 ] - [ ERROR ]  warning: parse error private slots:
    void handleTimeout();Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\eventprocessor.hpp:23
  2021-07-25 14:55:45  [ main:571 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 14:55:45  [ main:571 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\webelement.hpp:11
  2021-07-25 14:55:45  [ main:572 ] - [ ERROR ]  parsing error 
private slots:
    void loadFinished(bool ok);
  2021-07-25 14:55:45  [ main:573 ] - [ ERROR ]  warning: parse error private slots:
    void loadFinished(bool ok);Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\webelement.hpp:69
  2021-07-25 14:55:45  [ main:576 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 14:55:45  [ main:577 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\webelementcollection.hpp:11
  2021-07-25 14:55:45  [ main:594 ] - [ ERROR ]  parsing error 
QT_BEGIN_NAMESPACE
  2021-07-25 14:55:45  [ main:595 ] - [ ERROR ]  warning: parse error QT_BEGIN_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializer.h:26
  2021-07-25 14:55:45  [ main:595 ] - [ ERROR ]  parsing error 
QT_END_NAMESPACE
  2021-07-25 14:55:45  [ main:595 ] - [ ERROR ]  warning: parse error QT_END_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializer.h:30
  2021-07-25 14:55:45  [ main:595 ] - [ ERROR ]  parsing error 
class QJSON_EXPORT Serializer {
  public:
    Serializer();
    ~Serializer();

     /**
      * This method generates a textual JSON representation and outputs it to the
      * passed in I/O Device.
      * @param variant The JSON document in its in-memory representation as generated by the
      * parser.
      * @param out Input output device
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true
      */
    void serialize( const QVariant& variant, QIODevice* out, bool* ok);

    /**
      * This is a method provided for convenience. It turns the passed in in-memory
      * representation of the JSON document into a textual one, which is returned.
      * If the returned string is empty, the document was empty. If it was null, there
      * was a parsing error.
      *
      * @param variant The JSON document in its in-memory representation as generated by the
      * parser.
      *
      * \deprecated This method is going to be removed with the next major release of QJson.
      */
    QByteArray serialize( const QVariant& variant);

    /**
      * This is a method provided for convenience. It turns the passed in in-memory
      * representation of the JSON document into a textual one, which is returned.
      * If the returned string is empty, the document was empty. If it was null, there
      * was a parsing error.
      *
      * @param variant The JSON document in its in-memory representation as generated by the
      * parser.
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true
      */
    QByteArray serialize( const QVariant& variant, bool *ok);

    /**
     * Allow or disallow writing of NaN and/or Infinity (as an extension to QJson)
     */
    void allowSpecialNumbers(bool allow);

    /**
     * Is Nan and/or Infinity allowed?
     */
    bool specialNumbersAllowed() const;

    /**
     * set output indentation mode as defined in QJson::IndentMode
     */
    void setIndentMode(IndentMode mode = QJson::IndentNone);


    /**
    * set double precision used while converting Double
    * \sa QByteArray::number
    */
    void setDoublePrecision(int precision);

    /**
     * Returns one of the indentation modes defined in QJson::IndentMode
     */
    IndentMode indentMode() const;

    /**
     * Returns the error message
     */
    QString errorMessage() const;

  private:
    Q_DISABLE_COPY(Serializer)
    class SerializerPrivate;
    SerializerPrivate* const d;
  };
  2021-07-25 14:55:45  [ main:595 ] - [ ERROR ]  warning: parse error class QJSON_EXPORT Serializer {
  public:
    Serializer();
    ~Serializer();

     /**
      * This method generates a textual JSON representation and outputs it to the
      * passed in I/O Device.
      * @param variant The JSON document in its in-memory representation as generated by the
      * parser.
      * @param out Input output device
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true
      */
    void serialize( const QVariant& variant, QIODevice* out, bool* ok);

    /**
      * This is a method provided for convenience. It turns the passed in in-memory
      * representation of the JSON document into a textual one, which is returned.
      * If the returned string is empty, the document was empty. If it was null, there
      * was a parsing error.
      *
      * @param variant The JSON document in its in-memory representation as generated by the
      * parser.
      *
      * \deprecated This method is going to be removed with the next major release of QJson.
      */
    QByteArray serialize( const QVariant& variant);

    /**
      * This is a method provided for convenience. It turns the passed in in-memory
      * representation of the JSON document into a textual one, which is returned.
      * If the returned string is empty, the document was empty. If it was null, there
      * was a parsing error.
      *
      * @param variant The JSON document in its in-memory representation as generated by the
      * parser.
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true
      */
    QByteArray serialize( const QVariant& variant, bool *ok);

    /**
     * Allow or disallow writing of NaN and/or Infinity (as an extension to QJson)
     */
    void allowSpecialNumbers(bool allow);

    /**
     * Is Nan and/or Infinity allowed?
     */
    bool specialNumbersAllowed() const;

    /**
     * set output indentation mode as defined in QJson::IndentMode
     */
    void setIndentMode(IndentMode mode = QJson::IndentNone);


    /**
    * set double precision used while converting Double
    * \sa QByteArray::number
    */
    void setDoublePrecision(int precision);

    /**
     * Returns one of the indentation modes defined in QJson::IndentMode
     */
    IndentMode indentMode() const;

    /**
     * Returns the error message
     */
    QString errorMessage() const;

  private:
    Q_DISABLE_COPY(Serializer)
    class SerializerPrivate;
    SerializerPrivate* const d;
  };Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializer.h:112
  2021-07-25 14:55:45  [ main:598 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 14:55:45  [ main:598 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\cookiejar.hpp:14
  2021-07-25 14:55:46  [ main:658 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\phantompy.hpp
  2021-07-25 14:55:46  [ main:659 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\context.cpp
  2021-07-25 14:55:46  [ main:681 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\context.hpp
  2021-07-25 14:55:46  [ main:682 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\cookiejar.cpp
  2021-07-25 14:55:46  [ main:701 ] - [ ERROR ]  warning: parse error foreach(QNetworkCookie n_cookie, cookiesForUrl(QUrl(url))) {
        cookie["name"] = QString::fromUtf8(n_cookie.name());
        cookie["value"] = QString::fromUtf8(n_cookie.value());
        cookie["domain"] = n_cookie.domain();
        cookie["path"] = n_cookie.path();
        cookie["expires"] = n_cookie.expirationDate().toString(Qt::ISODate);

        cookiesList.append(cookie);
    }Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\cookiejar.cpp:112
  2021-07-25 14:55:46  [ main:702 ] - [ ERROR ]  warning: parse error foreach(QNetworkCookie n_cookie, allCookies()) {
        cookie["name"] = QString::fromUtf8(n_cookie.name());
        cookie["value"] = QString::fromUtf8(n_cookie.value());
        cookie["domain"] = n_cookie.domain();
        cookie["path"] = n_cookie.path();
        cookie["expires"] = n_cookie.expirationDate().toString(Qt::ISODate);

        cookiesList.append(cookie);
    }Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\cookiejar.cpp:129
  2021-07-25 14:55:46  [ main:703 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\cookiejar.hpp
  2021-07-25 14:55:46  [ main:704 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\eventprocessor.cpp
  2021-07-25 14:55:46  [ main:711 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\eventprocessor.hpp
  2021-07-25 14:55:46  [ main:712 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\frame.cpp
  2021-07-25 14:55:46  [ main:742 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\frame.hpp
  2021-07-25 14:55:46  [ main:743 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\image.cpp
  2021-07-25 14:55:46  [ main:748 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\image.hpp
  2021-07-25 14:55:46  [ main:749 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\networkmanager.cpp
  2021-07-25 14:55:46  [ main:756 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 14:55:46  [ main:757 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\networktimeout.hpp:10
  2021-07-25 14:55:46  [ main:762 ] - [ ERROR ]  warning: parse error foreach (QByteArray headerName, reply->rawHeaderList()) {
        QVariantMap header;
        header["name"] = QString::fromUtf8(headerName);
        header["value"] = QString::fromUtf8(reply->rawHeader(headerName));

        headers.append(header);
    }Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\networkmanager.cpp:69
  2021-07-25 14:55:46  [ main:764 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\networkmanager.hpp
  2021-07-25 14:55:46  [ main:765 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\networkmanagerproxy.cpp
  2021-07-25 14:55:46  [ main:772 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\networkmanagerproxy.hpp
  2021-07-25 14:55:46  [ main:773 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\networktimeout.cpp
  2021-07-25 14:55:46  [ main:777 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\networktimeout.hpp
  2021-07-25 14:55:46  [ main:778 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\page.cpp
  2021-07-25 14:55:46  [ main:792 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\page.hpp
  2021-07-25 14:55:46  [ main:793 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\timeout.cpp
  2021-07-25 14:55:46  [ main:798 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\timeout.hpp
  2021-07-25 14:55:46  [ main:799 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\webelement.cpp
  2021-07-25 14:55:46  [ main:809 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\webelement.hpp
  2021-07-25 14:55:46  [ main:810 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\webelementcollection.cpp
  2021-07-25 14:55:46  [ main:815 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\webelementcollection.hpp
  2021-07-25 14:55:46  [ main:816 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\FlexLexer.h
  2021-07-25 14:55:46  [ main:826 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\json_parser.cc
  2021-07-25 14:55:46  [ main:902 ] - [ ERROR ]  parsing error 
Q_DECLARE_METATYPE(QVector<QVariant>*)
  Q_DECLARE_METATYPE(QVariantMap*)


/* Line 33 of lalr1.cc  */
#line 72 "json_parser.hh"


#include <string>
#include <iostream>
#include "stack.hh"
#include "location.hh"

/* Enabling traces.  */
#ifndef YYDEBUG
# define YYDEBUG 1
#endif


namespace yy {
/* Line 33 of lalr1.cc  */
#line 88 "json_parser.hh"

  /// A Bison parser.
  class json_parser
  {
  public:
    /// Symbol semantic values.
#ifndef YYSTYPE
    typedef int semantic_type;
#else
    typedef YYSTYPE semantic_type;
#endif
    /// Symbol locations.
    typedef location location_type;
    /// Tokens.
    struct token
    {
      /* Tokens.  */
   enum yytokentype {
     END = 0,
     CURLY_BRACKET_OPEN = 1,
     CURLY_BRACKET_CLOSE = 2,
     SQUARE_BRACKET_OPEN = 3,
     SQUARE_BRACKET_CLOSE = 4,
     COLON = 5,
     COMMA = 6,
     NUMBER = 7,
     TRUE_VAL = 8,
     FALSE_VAL = 9,
     NULL_VAL = 10,
     STRING = 11,
     INVALID = 12
   };

    };
    /// Token type.
    typedef token::yytokentype token_type;

    /// Build a parser object.
    json_parser (QJson::ParserPrivate* driver_yyarg);
    virtual ~json_parser ();

    /// Parse.
    /// \returns  0 iff parsing succeeded.
    virtual int parse ();

#if YYDEBUG
    /// The current debugging stream.
    std::ostream& debug_stream () const;
    /// Set the current debugging stream.
    void set_debug_stream (std::ostream &);

    /// Type for debugging levels.
    typedef int debug_level_type;
    /// The current debugging level.
    debug_level_type debug_level () const;
    /// Set the current debugging level.
    void set_debug_level (debug_level_type l);
#endif

  private:
    /// Report a syntax error.
    /// \param loc    where the syntax error is found.
    /// \param msg    a description of the syntax error.
    virtual void error (const location_type& loc, const std::string& msg);

    /// Generate an error message.
    /// \param state   the state where the error occurred.
    /// \param tok     the lookahead token.
    virtual std::string yysyntax_error_ (int yystate, int tok);

#if YYDEBUG
    /// \brief Report a symbol value on the debug stream.
    /// \param yytype       The token type.
    /// \param yyvaluep     Its semantic value.
    /// \param yylocationp  Its location.
    virtual void yy_symbol_value_print_ (int yytype,
					 const semantic_type* yyvaluep,
					 const location_type* yylocationp);
    /// \brief Report a symbol on the debug stream.
    /// \param yytype       The token type.
    /// \param yyvaluep     Its semantic value.
    /// \param yylocationp  Its location.
    virtual void yy_symbol_print_ (int yytype,
				   const semantic_type* yyvaluep,
				   const location_type* yylocationp);
#endif


    /// State numbers.
    typedef int state_type;
    /// State stack type.
    typedef stack<state_type>    state_stack_type;
    /// Semantic value stack type.
    typedef stack<semantic_type> semantic_stack_type;
    /// location stack type.
    typedef stack<location_type> location_stack_type;

    /// The state stack.
    state_stack_type yystate_stack_;
    /// The semantic value stack.
    semantic_stack_type yysemantic_stack_;
    /// The location stack.
    location_stack_type yylocation_stack_;

    /// Whether the given \c yypact_ value indicates a defaulted state.
    /// \param yyvalue   the value to check
    static bool yy_pact_value_is_default_ (int yyvalue);

    /// Whether the given \c yytable_ value indicates a syntax error.
    /// \param yyvalue   the value to check
    static bool yy_table_value_is_error_ (int yyvalue);

    /// Internal symbol numbers.
    typedef unsigned char token_number_type;
    /* Tables.  */
    /// For a state, the index in \a yytable_ of its portion.
    static const signed char yypact_[];
    static const signed char yypact_ninf_;

    /// For a state, default reduction number.
    /// Unless\a  yytable_ specifies something else to do.
    /// Zero means the default is an error.
    static const unsigned char yydefact_[];

    static const signed char yypgoto_[];
    static const signed char yydefgoto_[];

    /// What to do in a state.
    /// \a yytable_[yypact_[s]]: what to do in state \a s.
    /// - if positive, shift that token.
    /// - if negative, reduce the rule which number is the opposite.
    /// - if zero, do what YYDEFACT says.
    static const unsigned char yytable_[];
    static const signed char yytable_ninf_;

    static const signed char yycheck_[];

    /// For a state, its accessing symbol.
    static const unsigned char yystos_[];

    /// For a rule, its LHS.
    static const unsigned char yyr1_[];
    /// For a rule, its RHS length.
    static const unsigned char yyr2_[]; 

    /// Convert the symbol name \a n to a form suitable for a diagnostic.
    static std::string yytnamerr_ (const char *n);


    /// For a symbol, its name in clear.
    static const char* const yytname_[];
#if YYDEBUG
    /// A type to store symbol numbers and -1.
    typedef signed char rhs_number_type;
    /// A `-1'-separated list of the rules' RHS.
    static const rhs_number_type yyrhs_[];
    /// For each rule, the index of the first RHS symbol in \a yyrhs_.
    static const unsigned char yyprhs_[];
    /// For each rule, its source line number.
    static const unsigned char yyrline_[];
    /// For each scanner token number, its symbol number.
    static const unsigned short int yytoken_number_[];
    /// Report on the debug stream that the rule \a r is going to be reduced.
    virtual void yy_reduce_print_ (int r);
    /// Print the state stack on the debug stream.
    virtual void yystack_print_ ();

    /* Debugging.  */
    int yydebug_;
    std::ostream* yycdebug_;
#endif

    /// Convert a scanner token number \a t to a symbol number.
    token_number_type yytranslate_ (int t);

    /// \brief Reclaim the memory associated to a symbol.
    /// \param yymsg        Why this token is reclaimed.
    ///                     If null, do not display the symbol, just free it.
    /// \param yytype       The symbol type.
    /// \param yyvaluep     Its semantic value.
    /// \param yylocationp  Its location.
    inline void yydestruct_ (const char* yymsg,
			     int yytype,
			     semantic_type* yyvaluep,
			     location_type* yylocationp);

    /// Pop \a n symbols the three stacks.
    inline void yypop_ (unsigned int n = 1);

    /* Constants.  */
    static const int yyeof_;
    /* LAST_ -- Last index in TABLE_.  */
    static const int yylast_;
    static const int yynnts_;
    static const int yyempty_;
    static const int yyfinal_;
    static const int yyterror_;
    static const int yyerrcode_;
    static const int yyntokens_;
    static const unsigned int yyuser_token_number_max_;
    static const token_number_type yyundef_token_;

    /* User arguments.  */
    QJson::ParserPrivate* driver;
  };

}
  2021-07-25 14:55:46  [ main:902 ] - [ ERROR ]  warning: parse error Q_DECLARE_METATYPE(QVector<QVariant>*)
  Q_DECLARE_METATYPE(QVariantMap*)


/* Line 33 of lalr1.cc  */
#line 72 "json_parser.hh"


#include <string>
#include <iostream>
#include "stack.hh"
#include "location.hh"

/* Enabling traces.  */
#ifndef YYDEBUG
# define YYDEBUG 1
#endif


namespace yy {
/* Line 33 of lalr1.cc  */
#line 88 "json_parser.hh"

  /// A Bison parser.
  class json_parser
  {
  public:
    /// Symbol semantic values.
#ifndef YYSTYPE
    typedef int semantic_type;
#else
    typedef YYSTYPE semantic_type;
#endif
    /// Symbol locations.
    typedef location location_type;
    /// Tokens.
    struct token
    {
      /* Tokens.  */
   enum yytokentype {
     END = 0,
     CURLY_BRACKET_OPEN = 1,
     CURLY_BRACKET_CLOSE = 2,
     SQUARE_BRACKET_OPEN = 3,
     SQUARE_BRACKET_CLOSE = 4,
     COLON = 5,
     COMMA = 6,
     NUMBER = 7,
     TRUE_VAL = 8,
     FALSE_VAL = 9,
     NULL_VAL = 10,
     STRING = 11,
     INVALID = 12
   };

    };
    /// Token type.
    typedef token::yytokentype token_type;

    /// Build a parser object.
    json_parser (QJson::ParserPrivate* driver_yyarg);
    virtual ~json_parser ();

    /// Parse.
    /// \returns  0 iff parsing succeeded.
    virtual int parse ();

#if YYDEBUG
    /// The current debugging stream.
    std::ostream& debug_stream () const;
    /// Set the current debugging stream.
    void set_debug_stream (std::ostream &);

    /// Type for debugging levels.
    typedef int debug_level_type;
    /// The current debugging level.
    debug_level_type debug_level () const;
    /// Set the current debugging level.
    void set_debug_level (debug_level_type l);
#endif

  private:
    /// Report a syntax error.
    /// \param loc    where the syntax error is found.
    /// \param msg    a description of the syntax error.
    virtual void error (const location_type& loc, const std::string& msg);

    /// Generate an error message.
    /// \param state   the state where the error occurred.
    /// \param tok     the lookahead token.
    virtual std::string yysyntax_error_ (int yystate, int tok);

#if YYDEBUG
    /// \brief Report a symbol value on the debug stream.
    /// \param yytype       The token type.
    /// \param yyvaluep     Its semantic value.
    /// \param yylocationp  Its location.
    virtual void yy_symbol_value_print_ (int yytype,
					 const semantic_type* yyvaluep,
					 const location_type* yylocationp);
    /// \brief Report a symbol on the debug stream.
    /// \param yytype       The token type.
    /// \param yyvaluep     Its semantic value.
    /// \param yylocationp  Its location.
    virtual void yy_symbol_print_ (int yytype,
				   const semantic_type* yyvaluep,
				   const location_type* yylocationp);
#endif


    /// State numbers.
    typedef int state_type;
    /// State stack type.
    typedef stack<state_type>    state_stack_type;
    /// Semantic value stack type.
    typedef stack<semantic_type> semantic_stack_type;
    /// location stack type.
    typedef stack<location_type> location_stack_type;

    /// The state stack.
    state_stack_type yystate_stack_;
    /// The semantic value stack.
    semantic_stack_type yysemantic_stack_;
    /// The location stack.
    location_stack_type yylocation_stack_;

    /// Whether the given \c yypact_ value indicates a defaulted state.
    /// \param yyvalue   the value to check
    static bool yy_pact_value_is_default_ (int yyvalue);

    /// Whether the given \c yytable_ value indicates a syntax error.
    /// \param yyvalue   the value to check
    static bool yy_table_value_is_error_ (int yyvalue);

    /// Internal symbol numbers.
    typedef unsigned char token_number_type;
    /* Tables.  */
    /// For a state, the index in \a yytable_ of its portion.
    static const signed char yypact_[];
    static const signed char yypact_ninf_;

    /// For a state, default reduction number.
    /// Unless\a  yytable_ specifies something else to do.
    /// Zero means the default is an error.
    static const unsigned char yydefact_[];

    static const signed char yypgoto_[];
    static const signed char yydefgoto_[];

    /// What to do in a state.
    /// \a yytable_[yypact_[s]]: what to do in state \a s.
    /// - if positive, shift that token.
    /// - if negative, reduce the rule which number is the opposite.
    /// - if zero, do what YYDEFACT says.
    static const unsigned char yytable_[];
    static const signed char yytable_ninf_;

    static const signed char yycheck_[];

    /// For a state, its accessing symbol.
    static const unsigned char yystos_[];

    /// For a rule, its LHS.
    static const unsigned char yyr1_[];
    /// For a rule, its RHS length.
    static const unsigned char yyr2_[]; 

    /// Convert the symbol name \a n to a form suitable for a diagnostic.
    static std::string yytnamerr_ (const char *n);


    /// For a symbol, its name in clear.
    static const char* const yytname_[];
#if YYDEBUG
    /// A type to store symbol numbers and -1.
    typedef signed char rhs_number_type;
    /// A `-1'-separated list of the rules' RHS.
    static const rhs_number_type yyrhs_[];
    /// For each rule, the index of the first RHS symbol in \a yyrhs_.
    static const unsigned char yyprhs_[];
    /// For each rule, its source line number.
    static const unsigned char yyrline_[];
    /// For each scanner token number, its symbol number.
    static const unsigned short int yytoken_number_[];
    /// Report on the debug stream that the rule \a r is going to be reduced.
    virtual void yy_reduce_print_ (int r);
    /// Print the state stack on the debug stream.
    virtual void yystack_print_ ();

    /* Debugging.  */
    int yydebug_;
    std::ostream* yycdebug_;
#endif

    /// Convert a scanner token number \a t to a symbol number.
    token_number_type yytranslate_ (int t);

    /// \brief Reclaim the memory associated to a symbol.
    /// \param yymsg        Why this token is reclaimed.
    ///                     If null, do not display the symbol, just free it.
    /// \param yytype       The symbol type.
    /// \param yyvaluep     Its semantic value.
    /// \param yylocationp  Its location.
    inline void yydestruct_ (const char* yymsg,
			     int yytype,
			     semantic_type* yyvaluep,
			     location_type* yylocationp);

    /// Pop \a n symbols the three stacks.
    inline void yypop_ (unsigned int n = 1);

    /* Constants.  */
    static const int yyeof_;
    /* LAST_ -- Last index in TABLE_.  */
    static const int yylast_;
    static const int yynnts_;
    static const int yyempty_;
    static const int yyfinal_;
    static const int yyterror_;
    static const int yyerrcode_;
    static const int yyntokens_;
    static const unsigned int yyuser_token_number_max_;
    static const token_number_type yyundef_token_;

    /* User arguments.  */
    QJson::ParserPrivate* driver;
  };

}Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\json_parser.hh:66
  2021-07-25 14:55:46  [ main:951 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\json_parser.hh
  2021-07-25 14:55:46  [ main:952 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\json_scanner.cc
  2021-07-25 14:55:46  [ main:1283 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\json_scanner.cpp
  2021-07-25 14:55:46  [ main:1289 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\json_scanner.h
  2021-07-25 14:55:46  [ main:1290 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\location.hh
  2021-07-25 14:55:46  [ main:1291 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\parser.cpp
  2021-07-25 14:55:46  [ main:1300 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\parser.h
  2021-07-25 14:55:46  [ main:1301 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\parserrunnable.cpp
  2021-07-25 14:55:46  [ main:1308 ] - [ ERROR ]  parsing error 
QT_BEGIN_NAMESPACE
  2021-07-25 14:55:46  [ main:1308 ] - [ ERROR ]  warning: parse error QT_BEGIN_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\parserrunnable.h:29
  2021-07-25 14:55:46  [ main:1309 ] - [ ERROR ]  parsing error 
QT_END_NAMESPACE
  2021-07-25 14:55:46  [ main:1309 ] - [ ERROR ]  warning: parse error QT_END_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\parserrunnable.h:31
  2021-07-25 14:55:46  [ main:1309 ] - [ ERROR ]  parsing error 
class QJSON_EXPORT ParserRunnable  : public QObject, public QRunnable
  {
    Q_OBJECT
    public:
      explicit ParserRunnable(QObject* parent = 0);
      ~ParserRunnable();

      void setData( const QByteArray& data );

      void run();

    Q_SIGNALS:
      /**
      * This signal is emitted when the parsing process has been completed
      * @param json contains the result of the parsing
      * @param ok if a parsing error occurs ok is set to false, otherwise it's set to true.
      * @param error_msg contains a string explaining the failure reason
      **/
      void parsingFinished(const QVariant& json, bool ok, const QString& error_msg);

    private:
      Q_DISABLE_COPY(ParserRunnable)
      class Private;
      Private* const d;
  };
  2021-07-25 14:55:46  [ main:1309 ] - [ ERROR ]  warning: parse error class QJSON_EXPORT ParserRunnable  : public QObject, public QRunnable
  {
    Q_OBJECT
    public:
      explicit ParserRunnable(QObject* parent = 0);
      ~ParserRunnable();

      void setData( const QByteArray& data );

      void run();

    Q_SIGNALS:
      /**
      * This signal is emitted when the parsing process has been completed
      * @param json contains the result of the parsing
      * @param ok if a parsing error occurs ok is set to false, otherwise it's set to true.
      * @param error_msg contains a string explaining the failure reason
      **/
      void parsingFinished(const QVariant& json, bool ok, const QString& error_msg);

    private:
      Q_DISABLE_COPY(ParserRunnable)
      class Private;
      Private* const d;
  };Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\parserrunnable.h:37
  2021-07-25 14:55:46  [ main:1313 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\parserrunnable.h
  2021-07-25 14:55:46  [ main:1314 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\parser_p.h
  2021-07-25 14:55:46  [ main:1314 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\position.hh
  2021-07-25 14:55:46  [ main:1323 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\qjson_debug.h
  2021-07-25 14:55:46  [ main:1323 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\qjson_export.h
  2021-07-25 14:55:46  [ main:1324 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\qobjecthelper.cpp
  2021-07-25 14:55:46  [ main:1331 ] - [ ERROR ]  parsing error 
QT_BEGIN_NAMESPACE
  2021-07-25 14:55:46  [ main:1331 ] - [ ERROR ]  warning: parse error QT_BEGIN_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\qobjecthelper.h:30
  2021-07-25 14:55:46  [ main:1331 ] - [ ERROR ]  parsing error 
QT_END_NAMESPACE
  2021-07-25 14:55:46  [ main:1332 ] - [ ERROR ]  warning: parse error QT_END_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\qobjecthelper.h:32
  2021-07-25 14:55:46  [ main:1332 ] - [ ERROR ]  parsing error 
class QJSON_EXPORT QObjectHelper {
    public:
      QObjectHelper();
      ~QObjectHelper();

    /**
    * This method converts a QObject instance into a QVariantMap.
    *
    * @param object The QObject instance to be converted.
    * @param ignoredProperties Properties that won't be converted.
    */
    static QVariantMap qobject2qvariant( const QObject* object,
                                  const QStringList& ignoredProperties = QStringList(QString(QLatin1String("objectName"))));

    /**
    * This method converts a QVariantMap instance into a QObject
    *
    * @param variant Attributes to assign to the object.
    * @param object The QObject instance to update.
    */
    static void qvariant2qobject(const QVariantMap& variant, QObject* object);

    private:
      Q_DISABLE_COPY(QObjectHelper)
      class QObjectHelperPrivate;
      QObjectHelperPrivate* const d;
  };
  2021-07-25 14:55:46  [ main:1332 ] - [ ERROR ]  warning: parse error class QJSON_EXPORT QObjectHelper {
    public:
      QObjectHelper();
      ~QObjectHelper();

    /**
    * This method converts a QObject instance into a QVariantMap.
    *
    * @param object The QObject instance to be converted.
    * @param ignoredProperties Properties that won't be converted.
    */
    static QVariantMap qobject2qvariant( const QObject* object,
                                  const QStringList& ignoredProperties = QStringList(QString(QLatin1String("objectName"))));

    /**
    * This method converts a QVariantMap instance into a QObject
    *
    * @param variant Attributes to assign to the object.
    * @param object The QObject instance to update.
    */
    static void qvariant2qobject(const QVariantMap& variant, QObject* object);

    private:
      Q_DISABLE_COPY(QObjectHelper)
      class QObjectHelperPrivate;
      QObjectHelperPrivate* const d;
  };Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\qobjecthelper.h:118
  2021-07-25 14:55:46  [ main:1337 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\qobjecthelper.h
  2021-07-25 14:55:46  [ main:1337 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\serializer.cpp
  2021-07-25 14:55:46  [ main:1354 ] - [ ERROR ]  warning: parse error Q_FOREACH( const QByteArray& i, list ) {
    if ( !res.isEmpty() )
      res += sep;
    res += i;
  }Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializer.cpp:55
  2021-07-25 14:55:46  [ main:1354 ] - [ ERROR ]  warning: parse error Q_FOREACH( const QVariant& var, list )
    {
      indentLevel++;
      QByteArray serializedValue = serialize( var, ok, indentLevel);
      indentLevel--;
      if ( !*ok ) {
        break;
      }
      values << serializedValue;
    }Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializer.cpp:72
  2021-07-25 14:55:46  [ main:1366 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\serializer.h
  2021-07-25 14:55:46  [ main:1367 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\serializerrunnable.cpp
  2021-07-25 14:55:46  [ main:1373 ] - [ ERROR ]  parsing error 
QT_BEGIN_NAMESPACE
  2021-07-25 14:55:46  [ main:1373 ] - [ ERROR ]  warning: parse error QT_BEGIN_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializerrunnable.h:29
  2021-07-25 14:55:46  [ main:1373 ] - [ ERROR ]  parsing error 
QT_END_NAMESPACE
  2021-07-25 14:55:46  [ main:1373 ] - [ ERROR ]  warning: parse error QT_END_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializerrunnable.h:33
  2021-07-25 14:55:46  [ main:1373 ] - [ ERROR ]  parsing error 
class QJSON_EXPORT SerializerRunnable  : public QObject, public QRunnable
  {
    Q_OBJECT
    public:
      explicit SerializerRunnable(QObject* parent = 0);
      ~SerializerRunnable();

      /**
       * Sets the json object to serialize.
       *
       * @param json QVariant containing the json representation to be serialized
       */
      void setJsonObject( const QVariant& json );

      /* reimp */ void run();

    Q_SIGNALS:
      /**
      * This signal is emitted when the serialization process has been completed
      * @param serialized contains the result of the serialization
      * @param ok if a serialization error occurs ok is set to false, otherwise it's set to true.
      * @param error_msg contains a string explaining the failure reason
      **/
      void parsingFinished(const QByteArray& serialized, bool ok, const QString& error_msg);

    private:
      Q_DISABLE_COPY(SerializerRunnable)
      class Private;
      Private* const d;
  };
  2021-07-25 14:55:46  [ main:1373 ] - [ ERROR ]  warning: parse error class QJSON_EXPORT SerializerRunnable  : public QObject, public QRunnable
  {
    Q_OBJECT
    public:
      explicit SerializerRunnable(QObject* parent = 0);
      ~SerializerRunnable();

      /**
       * Sets the json object to serialize.
       *
       * @param json QVariant containing the json representation to be serialized
       */
      void setJsonObject( const QVariant& json );

      /* reimp */ void run();

    Q_SIGNALS:
      /**
      * This signal is emitted when the serialization process has been completed
      * @param serialized contains the result of the serialization
      * @param ok if a serialization error occurs ok is set to false, otherwise it's set to true.
      * @param error_msg contains a string explaining the failure reason
      **/
      void parsingFinished(const QByteArray& serialized, bool ok, const QString& error_msg);

    private:
      Q_DISABLE_COPY(SerializerRunnable)
      class Private;
      Private* const d;
  };Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializerrunnable.h:39
  2021-07-25 14:55:46  [ main:1377 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\serializerrunnable.h
  2021-07-25 14:55:46  [ main:1377 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\stack.hh
  2021-07-25 14:55:46  [ main:1380 ] - [ INFO ]  start dependency
  2021-07-25 14:55:46  [ main:1454 ] - [ INFO ]  includenum:73
  2021-07-25 14:55:46  [ main:1454 ] - [ INFO ]  definenum:81
  2021-07-25 14:55:46  [ main:1455 ] - [ INFO ]  callnum:45
  2021-07-25 14:55:46  [ main:1455 ] - [ INFO ]  returnnum:159
  2021-07-25 14:55:46  [ main:1455 ] - [ INFO ]  parameternum:614
  2021-07-25 14:55:46  [ main:1455 ] - [ INFO ]  extendnum:1
  2021-07-25 14:55:46  [ main:1455 ] - [ INFO ]  overridenum:1
  2021-07-25 14:55:46  [ main:1563 ] - [ INFO ]  Process finish!
  2021-07-25 14:56:10  [ main:0 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\phantompy.cpp
  2021-07-25 14:56:10  [ main:442 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 14:56:10  [ main:489 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\frame.hpp:11
  2021-07-25 14:56:10  [ main:491 ] - [ ERROR ]  parsing error 
private slots:
    void loadFinished(bool ok);
  2021-07-25 14:56:10  [ main:491 ] - [ ERROR ]  warning: parse error private slots:
    void loadFinished(bool ok);Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\frame.hpp:38
  2021-07-25 14:56:10  [ main:494 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 14:56:10  [ main:495 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\image.hpp:9
  2021-07-25 14:56:10  [ main:511 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 14:56:10  [ main:512 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\timeout.hpp:9
  2021-07-25 14:56:10  [ main:512 ] - [ ERROR ]  parsing error 
private slots:
    void handleTimeout();
  2021-07-25 14:56:10  [ main:512 ] - [ ERROR ]  warning: parse error private slots:
    void handleTimeout();Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\timeout.hpp:22
  2021-07-25 14:56:10  [ main:522 ] - [ ERROR ]  parsing error 
QT_BEGIN_NAMESPACE
  2021-07-25 14:56:10  [ main:522 ] - [ ERROR ]  warning: parse error QT_BEGIN_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\parser.h:26
  2021-07-25 14:56:10  [ main:522 ] - [ ERROR ]  parsing error 
QT_END_NAMESPACE
  2021-07-25 14:56:10  [ main:522 ] - [ ERROR ]  warning: parse error QT_END_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\parser.h:29
  2021-07-25 14:56:10  [ main:523 ] - [ ERROR ]  parsing error 
class QJSON_EXPORT Parser
  {
    public:
      Parser();
      ~Parser();

      /**
      * Read JSON string from the I/O Device and converts it to a QVariant object
      * @param io Input output device
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true.
      * @returns a QVariant object generated from the JSON string
      */
      QVariant parse(QIODevice* io, bool* ok = 0);

      /**
      * This is a method provided for convenience.
      * @param jsonData data containing the JSON object representation
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true.
      * @returns a QVariant object generated from the JSON string
      * @sa errorString
      * @sa errorLine
      */
      QVariant parse(const QByteArray& jsonData, bool* ok = 0);

      /**
      * This method returns the error message
      * @returns a QString object containing the error message of the last parse operation
      * @sa errorLine
      */
      QString errorString() const;

      /**
      * This method returns line number where the error occurred
      * @returns the line number where the error occurred
      * @sa errorString
      */
      int errorLine() const;

      /**
       * Sets whether special numbers (Infinity, -Infinity, NaN) are allowed as an extension to
       * the standard
       * @param  allowSpecialNumbers new value of whether special numbers are allowed
       * @sa specialNumbersAllowed
       */
      void allowSpecialNumbers(bool allowSpecialNumbers);

      /**
       * @returns whether special numbers (Infinity, -Infinity, NaN) are allowed
       * @sa allowSpecialNumbers
       */
      bool specialNumbersAllowed() const;

    private:
      Q_DISABLE_COPY(Parser)
      ParserPrivate* const d;
  };
  2021-07-25 14:56:10  [ main:523 ] - [ ERROR ]  warning: parse error class QJSON_EXPORT Parser
  {
    public:
      Parser();
      ~Parser();

      /**
      * Read JSON string from the I/O Device and converts it to a QVariant object
      * @param io Input output device
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true.
      * @returns a QVariant object generated from the JSON string
      */
      QVariant parse(QIODevice* io, bool* ok = 0);

      /**
      * This is a method provided for convenience.
      * @param jsonData data containing the JSON object representation
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true.
      * @returns a QVariant object generated from the JSON string
      * @sa errorString
      * @sa errorLine
      */
      QVariant parse(const QByteArray& jsonData, bool* ok = 0);

      /**
      * This method returns the error message
      * @returns a QString object containing the error message of the last parse operation
      * @sa errorLine
      */
      QString errorString() const;

      /**
      * This method returns line number where the error occurred
      * @returns the line number where the error occurred
      * @sa errorString
      */
      int errorLine() const;

      /**
       * Sets whether special numbers (Infinity, -Infinity, NaN) are allowed as an extension to
       * the standard
       * @param  allowSpecialNumbers new value of whether special numbers are allowed
       * @sa specialNumbersAllowed
       */
      void allowSpecialNumbers(bool allowSpecialNumbers);

      /**
       * @returns whether special numbers (Infinity, -Infinity, NaN) are allowed
       * @sa allowSpecialNumbers
       */
      bool specialNumbersAllowed() const;

    private:
      Q_DISABLE_COPY(Parser)
      ParserPrivate* const d;
  };Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\parser.h:41
  2021-07-25 14:56:10  [ main:539 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 14:56:10  [ main:539 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\networkmanager.hpp:11
  2021-07-25 14:56:10  [ main:539 ] - [ ERROR ]  parsing error 
signals:
    void replyReceived(const QVariantMap &reply);
  2021-07-25 14:56:10  [ main:539 ] - [ ERROR ]  warning: parse error signals:
    void replyReceived(const QVariantMap &reply);Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\networkmanager.hpp:29
  2021-07-25 14:56:10  [ main:540 ] - [ ERROR ]  parsing error 
private slots:
    void provideAuthentication(QNetworkReply *reply, QAuthenticator *authenticator);
  2021-07-25 14:56:10  [ main:540 ] - [ ERROR ]  warning: parse error private slots:
    void provideAuthentication(QNetworkReply *reply, QAuthenticator *authenticator);Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\networkmanager.hpp:35
  2021-07-25 14:56:10  [ main:543 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 14:56:10  [ main:543 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\networkmanagerproxy.hpp:10
  2021-07-25 14:56:10  [ main:543 ] - [ ERROR ]  parsing error 
private slots:
    void finished();
  2021-07-25 14:56:10  [ main:544 ] - [ ERROR ]  warning: parse error private slots:
    void finished();Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\networkmanagerproxy.hpp:25
  2021-07-25 14:56:10  [ main:548 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 14:56:10  [ main:548 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\page.hpp:19
  2021-07-25 14:56:10  [ main:549 ] - [ ERROR ]  parsing error 
private slots:
    void loadFinished(bool ok);
  2021-07-25 14:56:10  [ main:549 ] - [ ERROR ]  warning: parse error private slots:
    void loadFinished(bool ok);Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\page.hpp:57
  2021-07-25 14:56:10  [ main:553 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 14:56:10  [ main:553 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\eventprocessor.hpp:9
  2021-07-25 14:56:10  [ main:554 ] - [ ERROR ]  parsing error 
private slots:
    void handleTimeout();
  2021-07-25 14:56:10  [ main:554 ] - [ ERROR ]  warning: parse error private slots:
    void handleTimeout();Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\eventprocessor.hpp:23
  2021-07-25 14:56:10  [ main:557 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 14:56:10  [ main:558 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\webelement.hpp:11
  2021-07-25 14:56:10  [ main:559 ] - [ ERROR ]  parsing error 
private slots:
    void loadFinished(bool ok);
  2021-07-25 14:56:10  [ main:559 ] - [ ERROR ]  warning: parse error private slots:
    void loadFinished(bool ok);Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\webelement.hpp:69
  2021-07-25 14:56:10  [ main:562 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 14:56:10  [ main:563 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\webelementcollection.hpp:11
  2021-07-25 14:56:10  [ main:581 ] - [ ERROR ]  parsing error 
QT_BEGIN_NAMESPACE
  2021-07-25 14:56:10  [ main:582 ] - [ ERROR ]  warning: parse error QT_BEGIN_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializer.h:26
  2021-07-25 14:56:10  [ main:582 ] - [ ERROR ]  parsing error 
QT_END_NAMESPACE
  2021-07-25 14:56:10  [ main:582 ] - [ ERROR ]  warning: parse error QT_END_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializer.h:30
  2021-07-25 14:56:10  [ main:582 ] - [ ERROR ]  parsing error 
class QJSON_EXPORT Serializer {
  public:
    Serializer();
    ~Serializer();

     /**
      * This method generates a textual JSON representation and outputs it to the
      * passed in I/O Device.
      * @param variant The JSON document in its in-memory representation as generated by the
      * parser.
      * @param out Input output device
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true
      */
    void serialize( const QVariant& variant, QIODevice* out, bool* ok);

    /**
      * This is a method provided for convenience. It turns the passed in in-memory
      * representation of the JSON document into a textual one, which is returned.
      * If the returned string is empty, the document was empty. If it was null, there
      * was a parsing error.
      *
      * @param variant The JSON document in its in-memory representation as generated by the
      * parser.
      *
      * \deprecated This method is going to be removed with the next major release of QJson.
      */
    QByteArray serialize( const QVariant& variant);

    /**
      * This is a method provided for convenience. It turns the passed in in-memory
      * representation of the JSON document into a textual one, which is returned.
      * If the returned string is empty, the document was empty. If it was null, there
      * was a parsing error.
      *
      * @param variant The JSON document in its in-memory representation as generated by the
      * parser.
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true
      */
    QByteArray serialize( const QVariant& variant, bool *ok);

    /**
     * Allow or disallow writing of NaN and/or Infinity (as an extension to QJson)
     */
    void allowSpecialNumbers(bool allow);

    /**
     * Is Nan and/or Infinity allowed?
     */
    bool specialNumbersAllowed() const;

    /**
     * set output indentation mode as defined in QJson::IndentMode
     */
    void setIndentMode(IndentMode mode = QJson::IndentNone);


    /**
    * set double precision used while converting Double
    * \sa QByteArray::number
    */
    void setDoublePrecision(int precision);

    /**
     * Returns one of the indentation modes defined in QJson::IndentMode
     */
    IndentMode indentMode() const;

    /**
     * Returns the error message
     */
    QString errorMessage() const;

  private:
    Q_DISABLE_COPY(Serializer)
    class SerializerPrivate;
    SerializerPrivate* const d;
  };
  2021-07-25 14:56:10  [ main:582 ] - [ ERROR ]  warning: parse error class QJSON_EXPORT Serializer {
  public:
    Serializer();
    ~Serializer();

     /**
      * This method generates a textual JSON representation and outputs it to the
      * passed in I/O Device.
      * @param variant The JSON document in its in-memory representation as generated by the
      * parser.
      * @param out Input output device
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true
      */
    void serialize( const QVariant& variant, QIODevice* out, bool* ok);

    /**
      * This is a method provided for convenience. It turns the passed in in-memory
      * representation of the JSON document into a textual one, which is returned.
      * If the returned string is empty, the document was empty. If it was null, there
      * was a parsing error.
      *
      * @param variant The JSON document in its in-memory representation as generated by the
      * parser.
      *
      * \deprecated This method is going to be removed with the next major release of QJson.
      */
    QByteArray serialize( const QVariant& variant);

    /**
      * This is a method provided for convenience. It turns the passed in in-memory
      * representation of the JSON document into a textual one, which is returned.
      * If the returned string is empty, the document was empty. If it was null, there
      * was a parsing error.
      *
      * @param variant The JSON document in its in-memory representation as generated by the
      * parser.
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true
      */
    QByteArray serialize( const QVariant& variant, bool *ok);

    /**
     * Allow or disallow writing of NaN and/or Infinity (as an extension to QJson)
     */
    void allowSpecialNumbers(bool allow);

    /**
     * Is Nan and/or Infinity allowed?
     */
    bool specialNumbersAllowed() const;

    /**
     * set output indentation mode as defined in QJson::IndentMode
     */
    void setIndentMode(IndentMode mode = QJson::IndentNone);


    /**
    * set double precision used while converting Double
    * \sa QByteArray::number
    */
    void setDoublePrecision(int precision);

    /**
     * Returns one of the indentation modes defined in QJson::IndentMode
     */
    IndentMode indentMode() const;

    /**
     * Returns the error message
     */
    QString errorMessage() const;

  private:
    Q_DISABLE_COPY(Serializer)
    class SerializerPrivate;
    SerializerPrivate* const d;
  };Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializer.h:112
  2021-07-25 14:56:10  [ main:585 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 14:56:10  [ main:586 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\cookiejar.hpp:14
  2021-07-25 14:56:10  [ main:646 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\phantompy.hpp
  2021-07-25 14:56:10  [ main:647 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\context.cpp
  2021-07-25 14:56:10  [ main:669 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\context.hpp
  2021-07-25 14:56:10  [ main:670 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\cookiejar.cpp
  2021-07-25 14:56:10  [ main:691 ] - [ ERROR ]  warning: parse error foreach(QNetworkCookie n_cookie, cookiesForUrl(QUrl(url))) {
        cookie["name"] = QString::fromUtf8(n_cookie.name());
        cookie["value"] = QString::fromUtf8(n_cookie.value());
        cookie["domain"] = n_cookie.domain();
        cookie["path"] = n_cookie.path();
        cookie["expires"] = n_cookie.expirationDate().toString(Qt::ISODate);

        cookiesList.append(cookie);
    }Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\cookiejar.cpp:112
  2021-07-25 14:56:10  [ main:692 ] - [ ERROR ]  warning: parse error foreach(QNetworkCookie n_cookie, allCookies()) {
        cookie["name"] = QString::fromUtf8(n_cookie.name());
        cookie["value"] = QString::fromUtf8(n_cookie.value());
        cookie["domain"] = n_cookie.domain();
        cookie["path"] = n_cookie.path();
        cookie["expires"] = n_cookie.expirationDate().toString(Qt::ISODate);

        cookiesList.append(cookie);
    }Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\cookiejar.cpp:129
  2021-07-25 14:56:10  [ main:692 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\cookiejar.hpp
  2021-07-25 14:56:10  [ main:694 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\eventprocessor.cpp
  2021-07-25 14:56:10  [ main:701 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\eventprocessor.hpp
  2021-07-25 14:56:10  [ main:702 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\frame.cpp
  2021-07-25 14:56:10  [ main:731 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\frame.hpp
  2021-07-25 14:56:10  [ main:732 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\image.cpp
  2021-07-25 14:56:10  [ main:737 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\image.hpp
  2021-07-25 14:56:10  [ main:738 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\networkmanager.cpp
  2021-07-25 14:56:10  [ main:747 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 14:56:10  [ main:747 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\networktimeout.hpp:10
  2021-07-25 14:56:10  [ main:753 ] - [ ERROR ]  warning: parse error foreach (QByteArray headerName, reply->rawHeaderList()) {
        QVariantMap header;
        header["name"] = QString::fromUtf8(headerName);
        header["value"] = QString::fromUtf8(reply->rawHeader(headerName));

        headers.append(header);
    }Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\networkmanager.cpp:69
  2021-07-25 14:56:10  [ main:755 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\networkmanager.hpp
  2021-07-25 14:56:10  [ main:756 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\networkmanagerproxy.cpp
  2021-07-25 14:56:10  [ main:762 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\networkmanagerproxy.hpp
  2021-07-25 14:56:10  [ main:763 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\networktimeout.cpp
  2021-07-25 14:56:10  [ main:766 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\networktimeout.hpp
  2021-07-25 14:56:10  [ main:767 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\page.cpp
  2021-07-25 14:56:10  [ main:778 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\page.hpp
  2021-07-25 14:56:10  [ main:779 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\timeout.cpp
  2021-07-25 14:56:10  [ main:784 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\timeout.hpp
  2021-07-25 14:56:10  [ main:785 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\webelement.cpp
  2021-07-25 14:56:10  [ main:795 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\webelement.hpp
  2021-07-25 14:56:10  [ main:796 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\webelementcollection.cpp
  2021-07-25 14:56:10  [ main:802 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\webelementcollection.hpp
  2021-07-25 14:56:10  [ main:803 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\FlexLexer.h
  2021-07-25 14:56:10  [ main:814 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\json_parser.cc
  2021-07-25 14:56:10  [ main:889 ] - [ ERROR ]  parsing error 
Q_DECLARE_METATYPE(QVector<QVariant>*)
  Q_DECLARE_METATYPE(QVariantMap*)


/* Line 33 of lalr1.cc  */
#line 72 "json_parser.hh"


#include <string>
#include <iostream>
#include "stack.hh"
#include "location.hh"

/* Enabling traces.  */
#ifndef YYDEBUG
# define YYDEBUG 1
#endif


namespace yy {
/* Line 33 of lalr1.cc  */
#line 88 "json_parser.hh"

  /// A Bison parser.
  class json_parser
  {
  public:
    /// Symbol semantic values.
#ifndef YYSTYPE
    typedef int semantic_type;
#else
    typedef YYSTYPE semantic_type;
#endif
    /// Symbol locations.
    typedef location location_type;
    /// Tokens.
    struct token
    {
      /* Tokens.  */
   enum yytokentype {
     END = 0,
     CURLY_BRACKET_OPEN = 1,
     CURLY_BRACKET_CLOSE = 2,
     SQUARE_BRACKET_OPEN = 3,
     SQUARE_BRACKET_CLOSE = 4,
     COLON = 5,
     COMMA = 6,
     NUMBER = 7,
     TRUE_VAL = 8,
     FALSE_VAL = 9,
     NULL_VAL = 10,
     STRING = 11,
     INVALID = 12
   };

    };
    /// Token type.
    typedef token::yytokentype token_type;

    /// Build a parser object.
    json_parser (QJson::ParserPrivate* driver_yyarg);
    virtual ~json_parser ();

    /// Parse.
    /// \returns  0 iff parsing succeeded.
    virtual int parse ();

#if YYDEBUG
    /// The current debugging stream.
    std::ostream& debug_stream () const;
    /// Set the current debugging stream.
    void set_debug_stream (std::ostream &);

    /// Type for debugging levels.
    typedef int debug_level_type;
    /// The current debugging level.
    debug_level_type debug_level () const;
    /// Set the current debugging level.
    void set_debug_level (debug_level_type l);
#endif

  private:
    /// Report a syntax error.
    /// \param loc    where the syntax error is found.
    /// \param msg    a description of the syntax error.
    virtual void error (const location_type& loc, const std::string& msg);

    /// Generate an error message.
    /// \param state   the state where the error occurred.
    /// \param tok     the lookahead token.
    virtual std::string yysyntax_error_ (int yystate, int tok);

#if YYDEBUG
    /// \brief Report a symbol value on the debug stream.
    /// \param yytype       The token type.
    /// \param yyvaluep     Its semantic value.
    /// \param yylocationp  Its location.
    virtual void yy_symbol_value_print_ (int yytype,
					 const semantic_type* yyvaluep,
					 const location_type* yylocationp);
    /// \brief Report a symbol on the debug stream.
    /// \param yytype       The token type.
    /// \param yyvaluep     Its semantic value.
    /// \param yylocationp  Its location.
    virtual void yy_symbol_print_ (int yytype,
				   const semantic_type* yyvaluep,
				   const location_type* yylocationp);
#endif


    /// State numbers.
    typedef int state_type;
    /// State stack type.
    typedef stack<state_type>    state_stack_type;
    /// Semantic value stack type.
    typedef stack<semantic_type> semantic_stack_type;
    /// location stack type.
    typedef stack<location_type> location_stack_type;

    /// The state stack.
    state_stack_type yystate_stack_;
    /// The semantic value stack.
    semantic_stack_type yysemantic_stack_;
    /// The location stack.
    location_stack_type yylocation_stack_;

    /// Whether the given \c yypact_ value indicates a defaulted state.
    /// \param yyvalue   the value to check
    static bool yy_pact_value_is_default_ (int yyvalue);

    /// Whether the given \c yytable_ value indicates a syntax error.
    /// \param yyvalue   the value to check
    static bool yy_table_value_is_error_ (int yyvalue);

    /// Internal symbol numbers.
    typedef unsigned char token_number_type;
    /* Tables.  */
    /// For a state, the index in \a yytable_ of its portion.
    static const signed char yypact_[];
    static const signed char yypact_ninf_;

    /// For a state, default reduction number.
    /// Unless\a  yytable_ specifies something else to do.
    /// Zero means the default is an error.
    static const unsigned char yydefact_[];

    static const signed char yypgoto_[];
    static const signed char yydefgoto_[];

    /// What to do in a state.
    /// \a yytable_[yypact_[s]]: what to do in state \a s.
    /// - if positive, shift that token.
    /// - if negative, reduce the rule which number is the opposite.
    /// - if zero, do what YYDEFACT says.
    static const unsigned char yytable_[];
    static const signed char yytable_ninf_;

    static const signed char yycheck_[];

    /// For a state, its accessing symbol.
    static const unsigned char yystos_[];

    /// For a rule, its LHS.
    static const unsigned char yyr1_[];
    /// For a rule, its RHS length.
    static const unsigned char yyr2_[]; 

    /// Convert the symbol name \a n to a form suitable for a diagnostic.
    static std::string yytnamerr_ (const char *n);


    /// For a symbol, its name in clear.
    static const char* const yytname_[];
#if YYDEBUG
    /// A type to store symbol numbers and -1.
    typedef signed char rhs_number_type;
    /// A `-1'-separated list of the rules' RHS.
    static const rhs_number_type yyrhs_[];
    /// For each rule, the index of the first RHS symbol in \a yyrhs_.
    static const unsigned char yyprhs_[];
    /// For each rule, its source line number.
    static const unsigned char yyrline_[];
    /// For each scanner token number, its symbol number.
    static const unsigned short int yytoken_number_[];
    /// Report on the debug stream that the rule \a r is going to be reduced.
    virtual void yy_reduce_print_ (int r);
    /// Print the state stack on the debug stream.
    virtual void yystack_print_ ();

    /* Debugging.  */
    int yydebug_;
    std::ostream* yycdebug_;
#endif

    /// Convert a scanner token number \a t to a symbol number.
    token_number_type yytranslate_ (int t);

    /// \brief Reclaim the memory associated to a symbol.
    /// \param yymsg        Why this token is reclaimed.
    ///                     If null, do not display the symbol, just free it.
    /// \param yytype       The symbol type.
    /// \param yyvaluep     Its semantic value.
    /// \param yylocationp  Its location.
    inline void yydestruct_ (const char* yymsg,
			     int yytype,
			     semantic_type* yyvaluep,
			     location_type* yylocationp);

    /// Pop \a n symbols the three stacks.
    inline void yypop_ (unsigned int n = 1);

    /* Constants.  */
    static const int yyeof_;
    /* LAST_ -- Last index in TABLE_.  */
    static const int yylast_;
    static const int yynnts_;
    static const int yyempty_;
    static const int yyfinal_;
    static const int yyterror_;
    static const int yyerrcode_;
    static const int yyntokens_;
    static const unsigned int yyuser_token_number_max_;
    static const token_number_type yyundef_token_;

    /* User arguments.  */
    QJson::ParserPrivate* driver;
  };

}
  2021-07-25 14:56:10  [ main:889 ] - [ ERROR ]  warning: parse error Q_DECLARE_METATYPE(QVector<QVariant>*)
  Q_DECLARE_METATYPE(QVariantMap*)


/* Line 33 of lalr1.cc  */
#line 72 "json_parser.hh"


#include <string>
#include <iostream>
#include "stack.hh"
#include "location.hh"

/* Enabling traces.  */
#ifndef YYDEBUG
# define YYDEBUG 1
#endif


namespace yy {
/* Line 33 of lalr1.cc  */
#line 88 "json_parser.hh"

  /// A Bison parser.
  class json_parser
  {
  public:
    /// Symbol semantic values.
#ifndef YYSTYPE
    typedef int semantic_type;
#else
    typedef YYSTYPE semantic_type;
#endif
    /// Symbol locations.
    typedef location location_type;
    /// Tokens.
    struct token
    {
      /* Tokens.  */
   enum yytokentype {
     END = 0,
     CURLY_BRACKET_OPEN = 1,
     CURLY_BRACKET_CLOSE = 2,
     SQUARE_BRACKET_OPEN = 3,
     SQUARE_BRACKET_CLOSE = 4,
     COLON = 5,
     COMMA = 6,
     NUMBER = 7,
     TRUE_VAL = 8,
     FALSE_VAL = 9,
     NULL_VAL = 10,
     STRING = 11,
     INVALID = 12
   };

    };
    /// Token type.
    typedef token::yytokentype token_type;

    /// Build a parser object.
    json_parser (QJson::ParserPrivate* driver_yyarg);
    virtual ~json_parser ();

    /// Parse.
    /// \returns  0 iff parsing succeeded.
    virtual int parse ();

#if YYDEBUG
    /// The current debugging stream.
    std::ostream& debug_stream () const;
    /// Set the current debugging stream.
    void set_debug_stream (std::ostream &);

    /// Type for debugging levels.
    typedef int debug_level_type;
    /// The current debugging level.
    debug_level_type debug_level () const;
    /// Set the current debugging level.
    void set_debug_level (debug_level_type l);
#endif

  private:
    /// Report a syntax error.
    /// \param loc    where the syntax error is found.
    /// \param msg    a description of the syntax error.
    virtual void error (const location_type& loc, const std::string& msg);

    /// Generate an error message.
    /// \param state   the state where the error occurred.
    /// \param tok     the lookahead token.
    virtual std::string yysyntax_error_ (int yystate, int tok);

#if YYDEBUG
    /// \brief Report a symbol value on the debug stream.
    /// \param yytype       The token type.
    /// \param yyvaluep     Its semantic value.
    /// \param yylocationp  Its location.
    virtual void yy_symbol_value_print_ (int yytype,
					 const semantic_type* yyvaluep,
					 const location_type* yylocationp);
    /// \brief Report a symbol on the debug stream.
    /// \param yytype       The token type.
    /// \param yyvaluep     Its semantic value.
    /// \param yylocationp  Its location.
    virtual void yy_symbol_print_ (int yytype,
				   const semantic_type* yyvaluep,
				   const location_type* yylocationp);
#endif


    /// State numbers.
    typedef int state_type;
    /// State stack type.
    typedef stack<state_type>    state_stack_type;
    /// Semantic value stack type.
    typedef stack<semantic_type> semantic_stack_type;
    /// location stack type.
    typedef stack<location_type> location_stack_type;

    /// The state stack.
    state_stack_type yystate_stack_;
    /// The semantic value stack.
    semantic_stack_type yysemantic_stack_;
    /// The location stack.
    location_stack_type yylocation_stack_;

    /// Whether the given \c yypact_ value indicates a defaulted state.
    /// \param yyvalue   the value to check
    static bool yy_pact_value_is_default_ (int yyvalue);

    /// Whether the given \c yytable_ value indicates a syntax error.
    /// \param yyvalue   the value to check
    static bool yy_table_value_is_error_ (int yyvalue);

    /// Internal symbol numbers.
    typedef unsigned char token_number_type;
    /* Tables.  */
    /// For a state, the index in \a yytable_ of its portion.
    static const signed char yypact_[];
    static const signed char yypact_ninf_;

    /// For a state, default reduction number.
    /// Unless\a  yytable_ specifies something else to do.
    /// Zero means the default is an error.
    static const unsigned char yydefact_[];

    static const signed char yypgoto_[];
    static const signed char yydefgoto_[];

    /// What to do in a state.
    /// \a yytable_[yypact_[s]]: what to do in state \a s.
    /// - if positive, shift that token.
    /// - if negative, reduce the rule which number is the opposite.
    /// - if zero, do what YYDEFACT says.
    static const unsigned char yytable_[];
    static const signed char yytable_ninf_;

    static const signed char yycheck_[];

    /// For a state, its accessing symbol.
    static const unsigned char yystos_[];

    /// For a rule, its LHS.
    static const unsigned char yyr1_[];
    /// For a rule, its RHS length.
    static const unsigned char yyr2_[]; 

    /// Convert the symbol name \a n to a form suitable for a diagnostic.
    static std::string yytnamerr_ (const char *n);


    /// For a symbol, its name in clear.
    static const char* const yytname_[];
#if YYDEBUG
    /// A type to store symbol numbers and -1.
    typedef signed char rhs_number_type;
    /// A `-1'-separated list of the rules' RHS.
    static const rhs_number_type yyrhs_[];
    /// For each rule, the index of the first RHS symbol in \a yyrhs_.
    static const unsigned char yyprhs_[];
    /// For each rule, its source line number.
    static const unsigned char yyrline_[];
    /// For each scanner token number, its symbol number.
    static const unsigned short int yytoken_number_[];
    /// Report on the debug stream that the rule \a r is going to be reduced.
    virtual void yy_reduce_print_ (int r);
    /// Print the state stack on the debug stream.
    virtual void yystack_print_ ();

    /* Debugging.  */
    int yydebug_;
    std::ostream* yycdebug_;
#endif

    /// Convert a scanner token number \a t to a symbol number.
    token_number_type yytranslate_ (int t);

    /// \brief Reclaim the memory associated to a symbol.
    /// \param yymsg        Why this token is reclaimed.
    ///                     If null, do not display the symbol, just free it.
    /// \param yytype       The symbol type.
    /// \param yyvaluep     Its semantic value.
    /// \param yylocationp  Its location.
    inline void yydestruct_ (const char* yymsg,
			     int yytype,
			     semantic_type* yyvaluep,
			     location_type* yylocationp);

    /// Pop \a n symbols the three stacks.
    inline void yypop_ (unsigned int n = 1);

    /* Constants.  */
    static const int yyeof_;
    /* LAST_ -- Last index in TABLE_.  */
    static const int yylast_;
    static const int yynnts_;
    static const int yyempty_;
    static const int yyfinal_;
    static const int yyterror_;
    static const int yyerrcode_;
    static const int yyntokens_;
    static const unsigned int yyuser_token_number_max_;
    static const token_number_type yyundef_token_;

    /* User arguments.  */
    QJson::ParserPrivate* driver;
  };

}Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\json_parser.hh:66
  2021-07-25 14:56:11  [ main:933 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\json_parser.hh
  2021-07-25 14:56:11  [ main:934 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\json_scanner.cc
  2021-07-25 14:56:11  [ main:1368 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\json_scanner.cpp
  2021-07-25 14:56:11  [ main:1375 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\json_scanner.h
  2021-07-25 14:56:11  [ main:1376 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\location.hh
  2021-07-25 14:56:11  [ main:1377 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\parser.cpp
  2021-07-25 14:56:11  [ main:1387 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\parser.h
  2021-07-25 14:56:11  [ main:1388 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\parserrunnable.cpp
  2021-07-25 14:56:11  [ main:1394 ] - [ ERROR ]  parsing error 
QT_BEGIN_NAMESPACE
  2021-07-25 14:56:11  [ main:1394 ] - [ ERROR ]  warning: parse error QT_BEGIN_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\parserrunnable.h:29
  2021-07-25 14:56:11  [ main:1395 ] - [ ERROR ]  parsing error 
QT_END_NAMESPACE
  2021-07-25 14:56:11  [ main:1395 ] - [ ERROR ]  warning: parse error QT_END_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\parserrunnable.h:31
  2021-07-25 14:56:11  [ main:1395 ] - [ ERROR ]  parsing error 
class QJSON_EXPORT ParserRunnable  : public QObject, public QRunnable
  {
    Q_OBJECT
    public:
      explicit ParserRunnable(QObject* parent = 0);
      ~ParserRunnable();

      void setData( const QByteArray& data );

      void run();

    Q_SIGNALS:
      /**
      * This signal is emitted when the parsing process has been completed
      * @param json contains the result of the parsing
      * @param ok if a parsing error occurs ok is set to false, otherwise it's set to true.
      * @param error_msg contains a string explaining the failure reason
      **/
      void parsingFinished(const QVariant& json, bool ok, const QString& error_msg);

    private:
      Q_DISABLE_COPY(ParserRunnable)
      class Private;
      Private* const d;
  };
  2021-07-25 14:56:11  [ main:1395 ] - [ ERROR ]  warning: parse error class QJSON_EXPORT ParserRunnable  : public QObject, public QRunnable
  {
    Q_OBJECT
    public:
      explicit ParserRunnable(QObject* parent = 0);
      ~ParserRunnable();

      void setData( const QByteArray& data );

      void run();

    Q_SIGNALS:
      /**
      * This signal is emitted when the parsing process has been completed
      * @param json contains the result of the parsing
      * @param ok if a parsing error occurs ok is set to false, otherwise it's set to true.
      * @param error_msg contains a string explaining the failure reason
      **/
      void parsingFinished(const QVariant& json, bool ok, const QString& error_msg);

    private:
      Q_DISABLE_COPY(ParserRunnable)
      class Private;
      Private* const d;
  };Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\parserrunnable.h:37
  2021-07-25 14:56:11  [ main:1399 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\parserrunnable.h
  2021-07-25 14:56:11  [ main:1400 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\parser_p.h
  2021-07-25 14:56:11  [ main:1401 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\position.hh
  2021-07-25 14:56:11  [ main:1410 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\qjson_debug.h
  2021-07-25 14:56:11  [ main:1412 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\qjson_export.h
  2021-07-25 14:56:11  [ main:1412 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\qobjecthelper.cpp
  2021-07-25 14:56:11  [ main:1419 ] - [ ERROR ]  parsing error 
QT_BEGIN_NAMESPACE
  2021-07-25 14:56:11  [ main:1420 ] - [ ERROR ]  warning: parse error QT_BEGIN_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\qobjecthelper.h:30
  2021-07-25 14:56:11  [ main:1420 ] - [ ERROR ]  parsing error 
QT_END_NAMESPACE
  2021-07-25 14:56:11  [ main:1420 ] - [ ERROR ]  warning: parse error QT_END_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\qobjecthelper.h:32
  2021-07-25 14:56:11  [ main:1420 ] - [ ERROR ]  parsing error 
class QJSON_EXPORT QObjectHelper {
    public:
      QObjectHelper();
      ~QObjectHelper();

    /**
    * This method converts a QObject instance into a QVariantMap.
    *
    * @param object The QObject instance to be converted.
    * @param ignoredProperties Properties that won't be converted.
    */
    static QVariantMap qobject2qvariant( const QObject* object,
                                  const QStringList& ignoredProperties = QStringList(QString(QLatin1String("objectName"))));

    /**
    * This method converts a QVariantMap instance into a QObject
    *
    * @param variant Attributes to assign to the object.
    * @param object The QObject instance to update.
    */
    static void qvariant2qobject(const QVariantMap& variant, QObject* object);

    private:
      Q_DISABLE_COPY(QObjectHelper)
      class QObjectHelperPrivate;
      QObjectHelperPrivate* const d;
  };
  2021-07-25 14:56:11  [ main:1420 ] - [ ERROR ]  warning: parse error class QJSON_EXPORT QObjectHelper {
    public:
      QObjectHelper();
      ~QObjectHelper();

    /**
    * This method converts a QObject instance into a QVariantMap.
    *
    * @param object The QObject instance to be converted.
    * @param ignoredProperties Properties that won't be converted.
    */
    static QVariantMap qobject2qvariant( const QObject* object,
                                  const QStringList& ignoredProperties = QStringList(QString(QLatin1String("objectName"))));

    /**
    * This method converts a QVariantMap instance into a QObject
    *
    * @param variant Attributes to assign to the object.
    * @param object The QObject instance to update.
    */
    static void qvariant2qobject(const QVariantMap& variant, QObject* object);

    private:
      Q_DISABLE_COPY(QObjectHelper)
      class QObjectHelperPrivate;
      QObjectHelperPrivate* const d;
  };Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\qobjecthelper.h:118
  2021-07-25 14:56:11  [ main:1425 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\qobjecthelper.h
  2021-07-25 14:56:11  [ main:1426 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\serializer.cpp
  2021-07-25 14:56:11  [ main:1441 ] - [ ERROR ]  warning: parse error Q_FOREACH( const QByteArray& i, list ) {
    if ( !res.isEmpty() )
      res += sep;
    res += i;
  }Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializer.cpp:55
  2021-07-25 14:56:11  [ main:1442 ] - [ ERROR ]  warning: parse error Q_FOREACH( const QVariant& var, list )
    {
      indentLevel++;
      QByteArray serializedValue = serialize( var, ok, indentLevel);
      indentLevel--;
      if ( !*ok ) {
        break;
      }
      values << serializedValue;
    }Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializer.cpp:72
  2021-07-25 14:56:11  [ main:1454 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\serializer.h
  2021-07-25 14:56:11  [ main:1455 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\serializerrunnable.cpp
  2021-07-25 14:56:11  [ main:1461 ] - [ ERROR ]  parsing error 
QT_BEGIN_NAMESPACE
  2021-07-25 14:56:11  [ main:1461 ] - [ ERROR ]  warning: parse error QT_BEGIN_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializerrunnable.h:29
  2021-07-25 14:56:11  [ main:1461 ] - [ ERROR ]  parsing error 
QT_END_NAMESPACE
  2021-07-25 14:56:11  [ main:1461 ] - [ ERROR ]  warning: parse error QT_END_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializerrunnable.h:33
  2021-07-25 14:56:11  [ main:1461 ] - [ ERROR ]  parsing error 
class QJSON_EXPORT SerializerRunnable  : public QObject, public QRunnable
  {
    Q_OBJECT
    public:
      explicit SerializerRunnable(QObject* parent = 0);
      ~SerializerRunnable();

      /**
       * Sets the json object to serialize.
       *
       * @param json QVariant containing the json representation to be serialized
       */
      void setJsonObject( const QVariant& json );

      /* reimp */ void run();

    Q_SIGNALS:
      /**
      * This signal is emitted when the serialization process has been completed
      * @param serialized contains the result of the serialization
      * @param ok if a serialization error occurs ok is set to false, otherwise it's set to true.
      * @param error_msg contains a string explaining the failure reason
      **/
      void parsingFinished(const QByteArray& serialized, bool ok, const QString& error_msg);

    private:
      Q_DISABLE_COPY(SerializerRunnable)
      class Private;
      Private* const d;
  };
  2021-07-25 14:56:11  [ main:1461 ] - [ ERROR ]  warning: parse error class QJSON_EXPORT SerializerRunnable  : public QObject, public QRunnable
  {
    Q_OBJECT
    public:
      explicit SerializerRunnable(QObject* parent = 0);
      ~SerializerRunnable();

      /**
       * Sets the json object to serialize.
       *
       * @param json QVariant containing the json representation to be serialized
       */
      void setJsonObject( const QVariant& json );

      /* reimp */ void run();

    Q_SIGNALS:
      /**
      * This signal is emitted when the serialization process has been completed
      * @param serialized contains the result of the serialization
      * @param ok if a serialization error occurs ok is set to false, otherwise it's set to true.
      * @param error_msg contains a string explaining the failure reason
      **/
      void parsingFinished(const QByteArray& serialized, bool ok, const QString& error_msg);

    private:
      Q_DISABLE_COPY(SerializerRunnable)
      class Private;
      Private* const d;
  };Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializerrunnable.h:39
  2021-07-25 14:56:11  [ main:1465 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\serializerrunnable.h
  2021-07-25 14:56:11  [ main:1466 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\stack.hh
  2021-07-25 14:56:11  [ main:1468 ] - [ INFO ]  start dependency
  2021-07-25 14:56:11  [ main:1539 ] - [ INFO ]  includenum:73
  2021-07-25 14:56:11  [ main:1539 ] - [ INFO ]  definenum:81
  2021-07-25 14:56:11  [ main:1539 ] - [ INFO ]  callnum:45
  2021-07-25 14:56:11  [ main:1540 ] - [ INFO ]  returnnum:159
  2021-07-25 14:56:11  [ main:1540 ] - [ INFO ]  parameternum:614
  2021-07-25 14:56:11  [ main:1540 ] - [ INFO ]  extendnum:1
  2021-07-25 14:56:11  [ main:1540 ] - [ INFO ]  overridenum:1
  2021-07-25 14:56:11  [ main:1646 ] - [ INFO ]  Process finish!
  2021-07-25 14:56:23  [ main:0 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\phantompy.cpp
  2021-07-25 14:56:24  [ main:449 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 14:56:24  [ main:495 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\frame.hpp:11
  2021-07-25 14:56:24  [ main:497 ] - [ ERROR ]  parsing error 
private slots:
    void loadFinished(bool ok);
  2021-07-25 14:56:24  [ main:497 ] - [ ERROR ]  warning: parse error private slots:
    void loadFinished(bool ok);Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\frame.hpp:38
  2021-07-25 14:56:24  [ main:500 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 14:56:24  [ main:501 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\image.hpp:9
  2021-07-25 14:56:24  [ main:518 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 14:56:24  [ main:519 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\timeout.hpp:9
  2021-07-25 14:56:24  [ main:519 ] - [ ERROR ]  parsing error 
private slots:
    void handleTimeout();
  2021-07-25 14:56:24  [ main:519 ] - [ ERROR ]  warning: parse error private slots:
    void handleTimeout();Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\timeout.hpp:22
  2021-07-25 14:56:24  [ main:530 ] - [ ERROR ]  parsing error 
QT_BEGIN_NAMESPACE
  2021-07-25 14:56:24  [ main:530 ] - [ ERROR ]  warning: parse error QT_BEGIN_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\parser.h:26
  2021-07-25 14:56:24  [ main:530 ] - [ ERROR ]  parsing error 
QT_END_NAMESPACE
  2021-07-25 14:56:24  [ main:530 ] - [ ERROR ]  warning: parse error QT_END_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\parser.h:29
  2021-07-25 14:56:24  [ main:532 ] - [ ERROR ]  parsing error 
class QJSON_EXPORT Parser
  {
    public:
      Parser();
      ~Parser();

      /**
      * Read JSON string from the I/O Device and converts it to a QVariant object
      * @param io Input output device
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true.
      * @returns a QVariant object generated from the JSON string
      */
      QVariant parse(QIODevice* io, bool* ok = 0);

      /**
      * This is a method provided for convenience.
      * @param jsonData data containing the JSON object representation
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true.
      * @returns a QVariant object generated from the JSON string
      * @sa errorString
      * @sa errorLine
      */
      QVariant parse(const QByteArray& jsonData, bool* ok = 0);

      /**
      * This method returns the error message
      * @returns a QString object containing the error message of the last parse operation
      * @sa errorLine
      */
      QString errorString() const;

      /**
      * This method returns line number where the error occurred
      * @returns the line number where the error occurred
      * @sa errorString
      */
      int errorLine() const;

      /**
       * Sets whether special numbers (Infinity, -Infinity, NaN) are allowed as an extension to
       * the standard
       * @param  allowSpecialNumbers new value of whether special numbers are allowed
       * @sa specialNumbersAllowed
       */
      void allowSpecialNumbers(bool allowSpecialNumbers);

      /**
       * @returns whether special numbers (Infinity, -Infinity, NaN) are allowed
       * @sa allowSpecialNumbers
       */
      bool specialNumbersAllowed() const;

    private:
      Q_DISABLE_COPY(Parser)
      ParserPrivate* const d;
  };
  2021-07-25 14:56:24  [ main:532 ] - [ ERROR ]  warning: parse error class QJSON_EXPORT Parser
  {
    public:
      Parser();
      ~Parser();

      /**
      * Read JSON string from the I/O Device and converts it to a QVariant object
      * @param io Input output device
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true.
      * @returns a QVariant object generated from the JSON string
      */
      QVariant parse(QIODevice* io, bool* ok = 0);

      /**
      * This is a method provided for convenience.
      * @param jsonData data containing the JSON object representation
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true.
      * @returns a QVariant object generated from the JSON string
      * @sa errorString
      * @sa errorLine
      */
      QVariant parse(const QByteArray& jsonData, bool* ok = 0);

      /**
      * This method returns the error message
      * @returns a QString object containing the error message of the last parse operation
      * @sa errorLine
      */
      QString errorString() const;

      /**
      * This method returns line number where the error occurred
      * @returns the line number where the error occurred
      * @sa errorString
      */
      int errorLine() const;

      /**
       * Sets whether special numbers (Infinity, -Infinity, NaN) are allowed as an extension to
       * the standard
       * @param  allowSpecialNumbers new value of whether special numbers are allowed
       * @sa specialNumbersAllowed
       */
      void allowSpecialNumbers(bool allowSpecialNumbers);

      /**
       * @returns whether special numbers (Infinity, -Infinity, NaN) are allowed
       * @sa allowSpecialNumbers
       */
      bool specialNumbersAllowed() const;

    private:
      Q_DISABLE_COPY(Parser)
      ParserPrivate* const d;
  };Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\parser.h:41
  2021-07-25 14:56:24  [ main:546 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 14:56:24  [ main:546 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\networkmanager.hpp:11
  2021-07-25 14:56:24  [ main:547 ] - [ ERROR ]  parsing error 
signals:
    void replyReceived(const QVariantMap &reply);
  2021-07-25 14:56:24  [ main:547 ] - [ ERROR ]  warning: parse error signals:
    void replyReceived(const QVariantMap &reply);Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\networkmanager.hpp:29
  2021-07-25 14:56:24  [ main:547 ] - [ ERROR ]  parsing error 
private slots:
    void provideAuthentication(QNetworkReply *reply, QAuthenticator *authenticator);
  2021-07-25 14:56:24  [ main:547 ] - [ ERROR ]  warning: parse error private slots:
    void provideAuthentication(QNetworkReply *reply, QAuthenticator *authenticator);Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\networkmanager.hpp:35
  2021-07-25 14:56:24  [ main:550 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 14:56:24  [ main:550 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\networkmanagerproxy.hpp:10
  2021-07-25 14:56:24  [ main:551 ] - [ ERROR ]  parsing error 
private slots:
    void finished();
  2021-07-25 14:56:24  [ main:551 ] - [ ERROR ]  warning: parse error private slots:
    void finished();Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\networkmanagerproxy.hpp:25
  2021-07-25 14:56:24  [ main:556 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 14:56:24  [ main:557 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\page.hpp:19
  2021-07-25 14:56:24  [ main:557 ] - [ ERROR ]  parsing error 
private slots:
    void loadFinished(bool ok);
  2021-07-25 14:56:24  [ main:558 ] - [ ERROR ]  warning: parse error private slots:
    void loadFinished(bool ok);Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\page.hpp:57
  2021-07-25 14:56:24  [ main:561 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 14:56:24  [ main:561 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\eventprocessor.hpp:9
  2021-07-25 14:56:24  [ main:561 ] - [ ERROR ]  parsing error 
private slots:
    void handleTimeout();
  2021-07-25 14:56:24  [ main:561 ] - [ ERROR ]  warning: parse error private slots:
    void handleTimeout();Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\eventprocessor.hpp:23
  2021-07-25 14:56:24  [ main:565 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 14:56:24  [ main:566 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\webelement.hpp:11
  2021-07-25 14:56:24  [ main:567 ] - [ ERROR ]  parsing error 
private slots:
    void loadFinished(bool ok);
  2021-07-25 14:56:24  [ main:567 ] - [ ERROR ]  warning: parse error private slots:
    void loadFinished(bool ok);Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\webelement.hpp:69
  2021-07-25 14:56:24  [ main:570 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 14:56:24  [ main:571 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\webelementcollection.hpp:11
  2021-07-25 14:56:24  [ main:587 ] - [ ERROR ]  parsing error 
QT_BEGIN_NAMESPACE
  2021-07-25 14:56:24  [ main:587 ] - [ ERROR ]  warning: parse error QT_BEGIN_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializer.h:26
  2021-07-25 14:56:24  [ main:588 ] - [ ERROR ]  parsing error 
QT_END_NAMESPACE
  2021-07-25 14:56:24  [ main:588 ] - [ ERROR ]  warning: parse error QT_END_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializer.h:30
  2021-07-25 14:56:24  [ main:588 ] - [ ERROR ]  parsing error 
class QJSON_EXPORT Serializer {
  public:
    Serializer();
    ~Serializer();

     /**
      * This method generates a textual JSON representation and outputs it to the
      * passed in I/O Device.
      * @param variant The JSON document in its in-memory representation as generated by the
      * parser.
      * @param out Input output device
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true
      */
    void serialize( const QVariant& variant, QIODevice* out, bool* ok);

    /**
      * This is a method provided for convenience. It turns the passed in in-memory
      * representation of the JSON document into a textual one, which is returned.
      * If the returned string is empty, the document was empty. If it was null, there
      * was a parsing error.
      *
      * @param variant The JSON document in its in-memory representation as generated by the
      * parser.
      *
      * \deprecated This method is going to be removed with the next major release of QJson.
      */
    QByteArray serialize( const QVariant& variant);

    /**
      * This is a method provided for convenience. It turns the passed in in-memory
      * representation of the JSON document into a textual one, which is returned.
      * If the returned string is empty, the document was empty. If it was null, there
      * was a parsing error.
      *
      * @param variant The JSON document in its in-memory representation as generated by the
      * parser.
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true
      */
    QByteArray serialize( const QVariant& variant, bool *ok);

    /**
     * Allow or disallow writing of NaN and/or Infinity (as an extension to QJson)
     */
    void allowSpecialNumbers(bool allow);

    /**
     * Is Nan and/or Infinity allowed?
     */
    bool specialNumbersAllowed() const;

    /**
     * set output indentation mode as defined in QJson::IndentMode
     */
    void setIndentMode(IndentMode mode = QJson::IndentNone);


    /**
    * set double precision used while converting Double
    * \sa QByteArray::number
    */
    void setDoublePrecision(int precision);

    /**
     * Returns one of the indentation modes defined in QJson::IndentMode
     */
    IndentMode indentMode() const;

    /**
     * Returns the error message
     */
    QString errorMessage() const;

  private:
    Q_DISABLE_COPY(Serializer)
    class SerializerPrivate;
    SerializerPrivate* const d;
  };
  2021-07-25 14:56:24  [ main:588 ] - [ ERROR ]  warning: parse error class QJSON_EXPORT Serializer {
  public:
    Serializer();
    ~Serializer();

     /**
      * This method generates a textual JSON representation and outputs it to the
      * passed in I/O Device.
      * @param variant The JSON document in its in-memory representation as generated by the
      * parser.
      * @param out Input output device
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true
      */
    void serialize( const QVariant& variant, QIODevice* out, bool* ok);

    /**
      * This is a method provided for convenience. It turns the passed in in-memory
      * representation of the JSON document into a textual one, which is returned.
      * If the returned string is empty, the document was empty. If it was null, there
      * was a parsing error.
      *
      * @param variant The JSON document in its in-memory representation as generated by the
      * parser.
      *
      * \deprecated This method is going to be removed with the next major release of QJson.
      */
    QByteArray serialize( const QVariant& variant);

    /**
      * This is a method provided for convenience. It turns the passed in in-memory
      * representation of the JSON document into a textual one, which is returned.
      * If the returned string is empty, the document was empty. If it was null, there
      * was a parsing error.
      *
      * @param variant The JSON document in its in-memory representation as generated by the
      * parser.
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true
      */
    QByteArray serialize( const QVariant& variant, bool *ok);

    /**
     * Allow or disallow writing of NaN and/or Infinity (as an extension to QJson)
     */
    void allowSpecialNumbers(bool allow);

    /**
     * Is Nan and/or Infinity allowed?
     */
    bool specialNumbersAllowed() const;

    /**
     * set output indentation mode as defined in QJson::IndentMode
     */
    void setIndentMode(IndentMode mode = QJson::IndentNone);


    /**
    * set double precision used while converting Double
    * \sa QByteArray::number
    */
    void setDoublePrecision(int precision);

    /**
     * Returns one of the indentation modes defined in QJson::IndentMode
     */
    IndentMode indentMode() const;

    /**
     * Returns the error message
     */
    QString errorMessage() const;

  private:
    Q_DISABLE_COPY(Serializer)
    class SerializerPrivate;
    SerializerPrivate* const d;
  };Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializer.h:112
  2021-07-25 14:56:24  [ main:591 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 14:56:24  [ main:591 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\cookiejar.hpp:14
  2021-07-25 14:56:24  [ main:651 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\phantompy.hpp
  2021-07-25 14:56:24  [ main:652 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\context.cpp
  2021-07-25 14:56:24  [ main:675 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\context.hpp
  2021-07-25 14:56:24  [ main:676 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\cookiejar.cpp
  2021-07-25 14:56:24  [ main:698 ] - [ ERROR ]  warning: parse error foreach(QNetworkCookie n_cookie, cookiesForUrl(QUrl(url))) {
        cookie["name"] = QString::fromUtf8(n_cookie.name());
        cookie["value"] = QString::fromUtf8(n_cookie.value());
        cookie["domain"] = n_cookie.domain();
        cookie["path"] = n_cookie.path();
        cookie["expires"] = n_cookie.expirationDate().toString(Qt::ISODate);

        cookiesList.append(cookie);
    }Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\cookiejar.cpp:112
  2021-07-25 14:56:24  [ main:698 ] - [ ERROR ]  warning: parse error foreach(QNetworkCookie n_cookie, allCookies()) {
        cookie["name"] = QString::fromUtf8(n_cookie.name());
        cookie["value"] = QString::fromUtf8(n_cookie.value());
        cookie["domain"] = n_cookie.domain();
        cookie["path"] = n_cookie.path();
        cookie["expires"] = n_cookie.expirationDate().toString(Qt::ISODate);

        cookiesList.append(cookie);
    }Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\cookiejar.cpp:129
  2021-07-25 14:56:24  [ main:699 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\cookiejar.hpp
  2021-07-25 14:56:24  [ main:700 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\eventprocessor.cpp
  2021-07-25 14:56:24  [ main:708 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\eventprocessor.hpp
  2021-07-25 14:56:24  [ main:709 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\frame.cpp
  2021-07-25 14:56:24  [ main:738 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\frame.hpp
  2021-07-25 14:56:24  [ main:739 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\image.cpp
  2021-07-25 14:56:24  [ main:744 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\image.hpp
  2021-07-25 14:56:24  [ main:745 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\networkmanager.cpp
  2021-07-25 14:56:24  [ main:753 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 14:56:24  [ main:753 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\networktimeout.hpp:10
  2021-07-25 14:56:24  [ main:759 ] - [ ERROR ]  warning: parse error foreach (QByteArray headerName, reply->rawHeaderList()) {
        QVariantMap header;
        header["name"] = QString::fromUtf8(headerName);
        header["value"] = QString::fromUtf8(reply->rawHeader(headerName));

        headers.append(header);
    }Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\networkmanager.cpp:69
  2021-07-25 14:56:24  [ main:762 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\networkmanager.hpp
  2021-07-25 14:56:24  [ main:763 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\networkmanagerproxy.cpp
  2021-07-25 14:56:24  [ main:770 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\networkmanagerproxy.hpp
  2021-07-25 14:56:24  [ main:772 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\networktimeout.cpp
  2021-07-25 14:56:24  [ main:776 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\networktimeout.hpp
  2021-07-25 14:56:24  [ main:777 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\page.cpp
  2021-07-25 14:56:24  [ main:788 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\page.hpp
  2021-07-25 14:56:24  [ main:789 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\timeout.cpp
  2021-07-25 14:56:24  [ main:794 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\timeout.hpp
  2021-07-25 14:56:24  [ main:795 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\webelement.cpp
  2021-07-25 14:56:24  [ main:805 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\webelement.hpp
  2021-07-25 14:56:24  [ main:806 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\webelementcollection.cpp
  2021-07-25 14:56:24  [ main:811 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\webelementcollection.hpp
  2021-07-25 14:56:24  [ main:812 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\FlexLexer.h
  2021-07-25 14:56:24  [ main:825 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\json_parser.cc
  2021-07-25 14:56:24  [ main:914 ] - [ ERROR ]  parsing error 
Q_DECLARE_METATYPE(QVector<QVariant>*)
  Q_DECLARE_METATYPE(QVariantMap*)


/* Line 33 of lalr1.cc  */
#line 72 "json_parser.hh"


#include <string>
#include <iostream>
#include "stack.hh"
#include "location.hh"

/* Enabling traces.  */
#ifndef YYDEBUG
# define YYDEBUG 1
#endif


namespace yy {
/* Line 33 of lalr1.cc  */
#line 88 "json_parser.hh"

  /// A Bison parser.
  class json_parser
  {
  public:
    /// Symbol semantic values.
#ifndef YYSTYPE
    typedef int semantic_type;
#else
    typedef YYSTYPE semantic_type;
#endif
    /// Symbol locations.
    typedef location location_type;
    /// Tokens.
    struct token
    {
      /* Tokens.  */
   enum yytokentype {
     END = 0,
     CURLY_BRACKET_OPEN = 1,
     CURLY_BRACKET_CLOSE = 2,
     SQUARE_BRACKET_OPEN = 3,
     SQUARE_BRACKET_CLOSE = 4,
     COLON = 5,
     COMMA = 6,
     NUMBER = 7,
     TRUE_VAL = 8,
     FALSE_VAL = 9,
     NULL_VAL = 10,
     STRING = 11,
     INVALID = 12
   };

    };
    /// Token type.
    typedef token::yytokentype token_type;

    /// Build a parser object.
    json_parser (QJson::ParserPrivate* driver_yyarg);
    virtual ~json_parser ();

    /// Parse.
    /// \returns  0 iff parsing succeeded.
    virtual int parse ();

#if YYDEBUG
    /// The current debugging stream.
    std::ostream& debug_stream () const;
    /// Set the current debugging stream.
    void set_debug_stream (std::ostream &);

    /// Type for debugging levels.
    typedef int debug_level_type;
    /// The current debugging level.
    debug_level_type debug_level () const;
    /// Set the current debugging level.
    void set_debug_level (debug_level_type l);
#endif

  private:
    /// Report a syntax error.
    /// \param loc    where the syntax error is found.
    /// \param msg    a description of the syntax error.
    virtual void error (const location_type& loc, const std::string& msg);

    /// Generate an error message.
    /// \param state   the state where the error occurred.
    /// \param tok     the lookahead token.
    virtual std::string yysyntax_error_ (int yystate, int tok);

#if YYDEBUG
    /// \brief Report a symbol value on the debug stream.
    /// \param yytype       The token type.
    /// \param yyvaluep     Its semantic value.
    /// \param yylocationp  Its location.
    virtual void yy_symbol_value_print_ (int yytype,
					 const semantic_type* yyvaluep,
					 const location_type* yylocationp);
    /// \brief Report a symbol on the debug stream.
    /// \param yytype       The token type.
    /// \param yyvaluep     Its semantic value.
    /// \param yylocationp  Its location.
    virtual void yy_symbol_print_ (int yytype,
				   const semantic_type* yyvaluep,
				   const location_type* yylocationp);
#endif


    /// State numbers.
    typedef int state_type;
    /// State stack type.
    typedef stack<state_type>    state_stack_type;
    /// Semantic value stack type.
    typedef stack<semantic_type> semantic_stack_type;
    /// location stack type.
    typedef stack<location_type> location_stack_type;

    /// The state stack.
    state_stack_type yystate_stack_;
    /// The semantic value stack.
    semantic_stack_type yysemantic_stack_;
    /// The location stack.
    location_stack_type yylocation_stack_;

    /// Whether the given \c yypact_ value indicates a defaulted state.
    /// \param yyvalue   the value to check
    static bool yy_pact_value_is_default_ (int yyvalue);

    /// Whether the given \c yytable_ value indicates a syntax error.
    /// \param yyvalue   the value to check
    static bool yy_table_value_is_error_ (int yyvalue);

    /// Internal symbol numbers.
    typedef unsigned char token_number_type;
    /* Tables.  */
    /// For a state, the index in \a yytable_ of its portion.
    static const signed char yypact_[];
    static const signed char yypact_ninf_;

    /// For a state, default reduction number.
    /// Unless\a  yytable_ specifies something else to do.
    /// Zero means the default is an error.
    static const unsigned char yydefact_[];

    static const signed char yypgoto_[];
    static const signed char yydefgoto_[];

    /// What to do in a state.
    /// \a yytable_[yypact_[s]]: what to do in state \a s.
    /// - if positive, shift that token.
    /// - if negative, reduce the rule which number is the opposite.
    /// - if zero, do what YYDEFACT says.
    static const unsigned char yytable_[];
    static const signed char yytable_ninf_;

    static const signed char yycheck_[];

    /// For a state, its accessing symbol.
    static const unsigned char yystos_[];

    /// For a rule, its LHS.
    static const unsigned char yyr1_[];
    /// For a rule, its RHS length.
    static const unsigned char yyr2_[]; 

    /// Convert the symbol name \a n to a form suitable for a diagnostic.
    static std::string yytnamerr_ (const char *n);


    /// For a symbol, its name in clear.
    static const char* const yytname_[];
#if YYDEBUG
    /// A type to store symbol numbers and -1.
    typedef signed char rhs_number_type;
    /// A `-1'-separated list of the rules' RHS.
    static const rhs_number_type yyrhs_[];
    /// For each rule, the index of the first RHS symbol in \a yyrhs_.
    static const unsigned char yyprhs_[];
    /// For each rule, its source line number.
    static const unsigned char yyrline_[];
    /// For each scanner token number, its symbol number.
    static const unsigned short int yytoken_number_[];
    /// Report on the debug stream that the rule \a r is going to be reduced.
    virtual void yy_reduce_print_ (int r);
    /// Print the state stack on the debug stream.
    virtual void yystack_print_ ();

    /* Debugging.  */
    int yydebug_;
    std::ostream* yycdebug_;
#endif

    /// Convert a scanner token number \a t to a symbol number.
    token_number_type yytranslate_ (int t);

    /// \brief Reclaim the memory associated to a symbol.
    /// \param yymsg        Why this token is reclaimed.
    ///                     If null, do not display the symbol, just free it.
    /// \param yytype       The symbol type.
    /// \param yyvaluep     Its semantic value.
    /// \param yylocationp  Its location.
    inline void yydestruct_ (const char* yymsg,
			     int yytype,
			     semantic_type* yyvaluep,
			     location_type* yylocationp);

    /// Pop \a n symbols the three stacks.
    inline void yypop_ (unsigned int n = 1);

    /* Constants.  */
    static const int yyeof_;
    /* LAST_ -- Last index in TABLE_.  */
    static const int yylast_;
    static const int yynnts_;
    static const int yyempty_;
    static const int yyfinal_;
    static const int yyterror_;
    static const int yyerrcode_;
    static const int yyntokens_;
    static const unsigned int yyuser_token_number_max_;
    static const token_number_type yyundef_token_;

    /* User arguments.  */
    QJson::ParserPrivate* driver;
  };

}
  2021-07-25 14:56:24  [ main:914 ] - [ ERROR ]  warning: parse error Q_DECLARE_METATYPE(QVector<QVariant>*)
  Q_DECLARE_METATYPE(QVariantMap*)


/* Line 33 of lalr1.cc  */
#line 72 "json_parser.hh"


#include <string>
#include <iostream>
#include "stack.hh"
#include "location.hh"

/* Enabling traces.  */
#ifndef YYDEBUG
# define YYDEBUG 1
#endif


namespace yy {
/* Line 33 of lalr1.cc  */
#line 88 "json_parser.hh"

  /// A Bison parser.
  class json_parser
  {
  public:
    /// Symbol semantic values.
#ifndef YYSTYPE
    typedef int semantic_type;
#else
    typedef YYSTYPE semantic_type;
#endif
    /// Symbol locations.
    typedef location location_type;
    /// Tokens.
    struct token
    {
      /* Tokens.  */
   enum yytokentype {
     END = 0,
     CURLY_BRACKET_OPEN = 1,
     CURLY_BRACKET_CLOSE = 2,
     SQUARE_BRACKET_OPEN = 3,
     SQUARE_BRACKET_CLOSE = 4,
     COLON = 5,
     COMMA = 6,
     NUMBER = 7,
     TRUE_VAL = 8,
     FALSE_VAL = 9,
     NULL_VAL = 10,
     STRING = 11,
     INVALID = 12
   };

    };
    /// Token type.
    typedef token::yytokentype token_type;

    /// Build a parser object.
    json_parser (QJson::ParserPrivate* driver_yyarg);
    virtual ~json_parser ();

    /// Parse.
    /// \returns  0 iff parsing succeeded.
    virtual int parse ();

#if YYDEBUG
    /// The current debugging stream.
    std::ostream& debug_stream () const;
    /// Set the current debugging stream.
    void set_debug_stream (std::ostream &);

    /// Type for debugging levels.
    typedef int debug_level_type;
    /// The current debugging level.
    debug_level_type debug_level () const;
    /// Set the current debugging level.
    void set_debug_level (debug_level_type l);
#endif

  private:
    /// Report a syntax error.
    /// \param loc    where the syntax error is found.
    /// \param msg    a description of the syntax error.
    virtual void error (const location_type& loc, const std::string& msg);

    /// Generate an error message.
    /// \param state   the state where the error occurred.
    /// \param tok     the lookahead token.
    virtual std::string yysyntax_error_ (int yystate, int tok);

#if YYDEBUG
    /// \brief Report a symbol value on the debug stream.
    /// \param yytype       The token type.
    /// \param yyvaluep     Its semantic value.
    /// \param yylocationp  Its location.
    virtual void yy_symbol_value_print_ (int yytype,
					 const semantic_type* yyvaluep,
					 const location_type* yylocationp);
    /// \brief Report a symbol on the debug stream.
    /// \param yytype       The token type.
    /// \param yyvaluep     Its semantic value.
    /// \param yylocationp  Its location.
    virtual void yy_symbol_print_ (int yytype,
				   const semantic_type* yyvaluep,
				   const location_type* yylocationp);
#endif


    /// State numbers.
    typedef int state_type;
    /// State stack type.
    typedef stack<state_type>    state_stack_type;
    /// Semantic value stack type.
    typedef stack<semantic_type> semantic_stack_type;
    /// location stack type.
    typedef stack<location_type> location_stack_type;

    /// The state stack.
    state_stack_type yystate_stack_;
    /// The semantic value stack.
    semantic_stack_type yysemantic_stack_;
    /// The location stack.
    location_stack_type yylocation_stack_;

    /// Whether the given \c yypact_ value indicates a defaulted state.
    /// \param yyvalue   the value to check
    static bool yy_pact_value_is_default_ (int yyvalue);

    /// Whether the given \c yytable_ value indicates a syntax error.
    /// \param yyvalue   the value to check
    static bool yy_table_value_is_error_ (int yyvalue);

    /// Internal symbol numbers.
    typedef unsigned char token_number_type;
    /* Tables.  */
    /// For a state, the index in \a yytable_ of its portion.
    static const signed char yypact_[];
    static const signed char yypact_ninf_;

    /// For a state, default reduction number.
    /// Unless\a  yytable_ specifies something else to do.
    /// Zero means the default is an error.
    static const unsigned char yydefact_[];

    static const signed char yypgoto_[];
    static const signed char yydefgoto_[];

    /// What to do in a state.
    /// \a yytable_[yypact_[s]]: what to do in state \a s.
    /// - if positive, shift that token.
    /// - if negative, reduce the rule which number is the opposite.
    /// - if zero, do what YYDEFACT says.
    static const unsigned char yytable_[];
    static const signed char yytable_ninf_;

    static const signed char yycheck_[];

    /// For a state, its accessing symbol.
    static const unsigned char yystos_[];

    /// For a rule, its LHS.
    static const unsigned char yyr1_[];
    /// For a rule, its RHS length.
    static const unsigned char yyr2_[]; 

    /// Convert the symbol name \a n to a form suitable for a diagnostic.
    static std::string yytnamerr_ (const char *n);


    /// For a symbol, its name in clear.
    static const char* const yytname_[];
#if YYDEBUG
    /// A type to store symbol numbers and -1.
    typedef signed char rhs_number_type;
    /// A `-1'-separated list of the rules' RHS.
    static const rhs_number_type yyrhs_[];
    /// For each rule, the index of the first RHS symbol in \a yyrhs_.
    static const unsigned char yyprhs_[];
    /// For each rule, its source line number.
    static const unsigned char yyrline_[];
    /// For each scanner token number, its symbol number.
    static const unsigned short int yytoken_number_[];
    /// Report on the debug stream that the rule \a r is going to be reduced.
    virtual void yy_reduce_print_ (int r);
    /// Print the state stack on the debug stream.
    virtual void yystack_print_ ();

    /* Debugging.  */
    int yydebug_;
    std::ostream* yycdebug_;
#endif

    /// Convert a scanner token number \a t to a symbol number.
    token_number_type yytranslate_ (int t);

    /// \brief Reclaim the memory associated to a symbol.
    /// \param yymsg        Why this token is reclaimed.
    ///                     If null, do not display the symbol, just free it.
    /// \param yytype       The symbol type.
    /// \param yyvaluep     Its semantic value.
    /// \param yylocationp  Its location.
    inline void yydestruct_ (const char* yymsg,
			     int yytype,
			     semantic_type* yyvaluep,
			     location_type* yylocationp);

    /// Pop \a n symbols the three stacks.
    inline void yypop_ (unsigned int n = 1);

    /* Constants.  */
    static const int yyeof_;
    /* LAST_ -- Last index in TABLE_.  */
    static const int yylast_;
    static const int yynnts_;
    static const int yyempty_;
    static const int yyfinal_;
    static const int yyterror_;
    static const int yyerrcode_;
    static const int yyntokens_;
    static const unsigned int yyuser_token_number_max_;
    static const token_number_type yyundef_token_;

    /* User arguments.  */
    QJson::ParserPrivate* driver;
  };

}Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\json_parser.hh:66
  2021-07-25 14:56:24  [ main:960 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\json_parser.hh
  2021-07-25 14:56:24  [ main:960 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\json_scanner.cc
  2021-07-25 14:56:25  [ main:1316 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\json_scanner.cpp
  2021-07-25 14:56:25  [ main:1323 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\json_scanner.h
  2021-07-25 14:56:25  [ main:1324 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\location.hh
  2021-07-25 14:56:25  [ main:1324 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\parser.cpp
  2021-07-25 14:56:25  [ main:1334 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\parser.h
  2021-07-25 14:56:25  [ main:1335 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\parserrunnable.cpp
  2021-07-25 14:56:25  [ main:1342 ] - [ ERROR ]  parsing error 
QT_BEGIN_NAMESPACE
  2021-07-25 14:56:25  [ main:1342 ] - [ ERROR ]  warning: parse error QT_BEGIN_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\parserrunnable.h:29
  2021-07-25 14:56:25  [ main:1342 ] - [ ERROR ]  parsing error 
QT_END_NAMESPACE
  2021-07-25 14:56:25  [ main:1342 ] - [ ERROR ]  warning: parse error QT_END_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\parserrunnable.h:31
  2021-07-25 14:56:25  [ main:1342 ] - [ ERROR ]  parsing error 
class QJSON_EXPORT ParserRunnable  : public QObject, public QRunnable
  {
    Q_OBJECT
    public:
      explicit ParserRunnable(QObject* parent = 0);
      ~ParserRunnable();

      void setData( const QByteArray& data );

      void run();

    Q_SIGNALS:
      /**
      * This signal is emitted when the parsing process has been completed
      * @param json contains the result of the parsing
      * @param ok if a parsing error occurs ok is set to false, otherwise it's set to true.
      * @param error_msg contains a string explaining the failure reason
      **/
      void parsingFinished(const QVariant& json, bool ok, const QString& error_msg);

    private:
      Q_DISABLE_COPY(ParserRunnable)
      class Private;
      Private* const d;
  };
  2021-07-25 14:56:25  [ main:1342 ] - [ ERROR ]  warning: parse error class QJSON_EXPORT ParserRunnable  : public QObject, public QRunnable
  {
    Q_OBJECT
    public:
      explicit ParserRunnable(QObject* parent = 0);
      ~ParserRunnable();

      void setData( const QByteArray& data );

      void run();

    Q_SIGNALS:
      /**
      * This signal is emitted when the parsing process has been completed
      * @param json contains the result of the parsing
      * @param ok if a parsing error occurs ok is set to false, otherwise it's set to true.
      * @param error_msg contains a string explaining the failure reason
      **/
      void parsingFinished(const QVariant& json, bool ok, const QString& error_msg);

    private:
      Q_DISABLE_COPY(ParserRunnable)
      class Private;
      Private* const d;
  };Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\parserrunnable.h:37
  2021-07-25 14:56:25  [ main:1346 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\parserrunnable.h
  2021-07-25 14:56:25  [ main:1347 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\parser_p.h
  2021-07-25 14:56:25  [ main:1348 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\position.hh
  2021-07-25 14:56:25  [ main:1356 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\qjson_debug.h
  2021-07-25 14:56:25  [ main:1357 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\qjson_export.h
  2021-07-25 14:56:25  [ main:1358 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\qobjecthelper.cpp
  2021-07-25 14:56:25  [ main:1365 ] - [ ERROR ]  parsing error 
QT_BEGIN_NAMESPACE
  2021-07-25 14:56:25  [ main:1365 ] - [ ERROR ]  warning: parse error QT_BEGIN_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\qobjecthelper.h:30
  2021-07-25 14:56:25  [ main:1365 ] - [ ERROR ]  parsing error 
QT_END_NAMESPACE
  2021-07-25 14:56:25  [ main:1365 ] - [ ERROR ]  warning: parse error QT_END_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\qobjecthelper.h:32
  2021-07-25 14:56:25  [ main:1365 ] - [ ERROR ]  parsing error 
class QJSON_EXPORT QObjectHelper {
    public:
      QObjectHelper();
      ~QObjectHelper();

    /**
    * This method converts a QObject instance into a QVariantMap.
    *
    * @param object The QObject instance to be converted.
    * @param ignoredProperties Properties that won't be converted.
    */
    static QVariantMap qobject2qvariant( const QObject* object,
                                  const QStringList& ignoredProperties = QStringList(QString(QLatin1String("objectName"))));

    /**
    * This method converts a QVariantMap instance into a QObject
    *
    * @param variant Attributes to assign to the object.
    * @param object The QObject instance to update.
    */
    static void qvariant2qobject(const QVariantMap& variant, QObject* object);

    private:
      Q_DISABLE_COPY(QObjectHelper)
      class QObjectHelperPrivate;
      QObjectHelperPrivate* const d;
  };
  2021-07-25 14:56:25  [ main:1365 ] - [ ERROR ]  warning: parse error class QJSON_EXPORT QObjectHelper {
    public:
      QObjectHelper();
      ~QObjectHelper();

    /**
    * This method converts a QObject instance into a QVariantMap.
    *
    * @param object The QObject instance to be converted.
    * @param ignoredProperties Properties that won't be converted.
    */
    static QVariantMap qobject2qvariant( const QObject* object,
                                  const QStringList& ignoredProperties = QStringList(QString(QLatin1String("objectName"))));

    /**
    * This method converts a QVariantMap instance into a QObject
    *
    * @param variant Attributes to assign to the object.
    * @param object The QObject instance to update.
    */
    static void qvariant2qobject(const QVariantMap& variant, QObject* object);

    private:
      Q_DISABLE_COPY(QObjectHelper)
      class QObjectHelperPrivate;
      QObjectHelperPrivate* const d;
  };Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\qobjecthelper.h:118
  2021-07-25 14:56:25  [ main:1370 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\qobjecthelper.h
  2021-07-25 14:56:25  [ main:1371 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\serializer.cpp
  2021-07-25 14:56:25  [ main:1386 ] - [ ERROR ]  warning: parse error Q_FOREACH( const QByteArray& i, list ) {
    if ( !res.isEmpty() )
      res += sep;
    res += i;
  }Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializer.cpp:55
  2021-07-25 14:56:25  [ main:1387 ] - [ ERROR ]  warning: parse error Q_FOREACH( const QVariant& var, list )
    {
      indentLevel++;
      QByteArray serializedValue = serialize( var, ok, indentLevel);
      indentLevel--;
      if ( !*ok ) {
        break;
      }
      values << serializedValue;
    }Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializer.cpp:72
  2021-07-25 14:56:25  [ main:1398 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\serializer.h
  2021-07-25 14:56:25  [ main:1399 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\serializerrunnable.cpp
  2021-07-25 14:56:25  [ main:1405 ] - [ ERROR ]  parsing error 
QT_BEGIN_NAMESPACE
  2021-07-25 14:56:25  [ main:1405 ] - [ ERROR ]  warning: parse error QT_BEGIN_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializerrunnable.h:29
  2021-07-25 14:56:25  [ main:1405 ] - [ ERROR ]  parsing error 
QT_END_NAMESPACE
  2021-07-25 14:56:25  [ main:1406 ] - [ ERROR ]  warning: parse error QT_END_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializerrunnable.h:33
  2021-07-25 14:56:25  [ main:1406 ] - [ ERROR ]  parsing error 
class QJSON_EXPORT SerializerRunnable  : public QObject, public QRunnable
  {
    Q_OBJECT
    public:
      explicit SerializerRunnable(QObject* parent = 0);
      ~SerializerRunnable();

      /**
       * Sets the json object to serialize.
       *
       * @param json QVariant containing the json representation to be serialized
       */
      void setJsonObject( const QVariant& json );

      /* reimp */ void run();

    Q_SIGNALS:
      /**
      * This signal is emitted when the serialization process has been completed
      * @param serialized contains the result of the serialization
      * @param ok if a serialization error occurs ok is set to false, otherwise it's set to true.
      * @param error_msg contains a string explaining the failure reason
      **/
      void parsingFinished(const QByteArray& serialized, bool ok, const QString& error_msg);

    private:
      Q_DISABLE_COPY(SerializerRunnable)
      class Private;
      Private* const d;
  };
  2021-07-25 14:56:25  [ main:1406 ] - [ ERROR ]  warning: parse error class QJSON_EXPORT SerializerRunnable  : public QObject, public QRunnable
  {
    Q_OBJECT
    public:
      explicit SerializerRunnable(QObject* parent = 0);
      ~SerializerRunnable();

      /**
       * Sets the json object to serialize.
       *
       * @param json QVariant containing the json representation to be serialized
       */
      void setJsonObject( const QVariant& json );

      /* reimp */ void run();

    Q_SIGNALS:
      /**
      * This signal is emitted when the serialization process has been completed
      * @param serialized contains the result of the serialization
      * @param ok if a serialization error occurs ok is set to false, otherwise it's set to true.
      * @param error_msg contains a string explaining the failure reason
      **/
      void parsingFinished(const QByteArray& serialized, bool ok, const QString& error_msg);

    private:
      Q_DISABLE_COPY(SerializerRunnable)
      class Private;
      Private* const d;
  };Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializerrunnable.h:39
  2021-07-25 14:56:25  [ main:1409 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\serializerrunnable.h
  2021-07-25 14:56:25  [ main:1410 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\stack.hh
  2021-07-25 14:56:25  [ main:1412 ] - [ INFO ]  start dependency
  2021-07-25 14:56:25  [ main:1480 ] - [ INFO ]  includenum:73
  2021-07-25 14:56:25  [ main:1480 ] - [ INFO ]  definenum:81
  2021-07-25 14:56:25  [ main:1480 ] - [ INFO ]  callnum:45
  2021-07-25 14:56:25  [ main:1480 ] - [ INFO ]  returnnum:159
  2021-07-25 14:56:25  [ main:1480 ] - [ INFO ]  parameternum:614
  2021-07-25 14:56:25  [ main:1480 ] - [ INFO ]  extendnum:1
  2021-07-25 14:56:25  [ main:1480 ] - [ INFO ]  overridenum:1
  2021-07-25 14:56:25  [ main:1587 ] - [ INFO ]  Process finish!
  2021-07-25 14:56:45  [ main:0 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\phantompy.cpp
  2021-07-25 14:56:46  [ main:449 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 14:56:46  [ main:495 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\frame.hpp:11
  2021-07-25 14:56:46  [ main:498 ] - [ ERROR ]  parsing error 
private slots:
    void loadFinished(bool ok);
  2021-07-25 14:56:46  [ main:498 ] - [ ERROR ]  warning: parse error private slots:
    void loadFinished(bool ok);Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\frame.hpp:38
  2021-07-25 14:56:46  [ main:501 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 14:56:46  [ main:501 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\image.hpp:9
  2021-07-25 14:56:46  [ main:517 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 14:56:46  [ main:517 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\timeout.hpp:9
  2021-07-25 14:56:46  [ main:517 ] - [ ERROR ]  parsing error 
private slots:
    void handleTimeout();
  2021-07-25 14:56:46  [ main:518 ] - [ ERROR ]  warning: parse error private slots:
    void handleTimeout();Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\timeout.hpp:22
  2021-07-25 14:56:46  [ main:526 ] - [ ERROR ]  parsing error 
QT_BEGIN_NAMESPACE
  2021-07-25 14:56:46  [ main:526 ] - [ ERROR ]  warning: parse error QT_BEGIN_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\parser.h:26
  2021-07-25 14:56:46  [ main:526 ] - [ ERROR ]  parsing error 
QT_END_NAMESPACE
  2021-07-25 14:56:46  [ main:527 ] - [ ERROR ]  warning: parse error QT_END_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\parser.h:29
  2021-07-25 14:56:46  [ main:527 ] - [ ERROR ]  parsing error 
class QJSON_EXPORT Parser
  {
    public:
      Parser();
      ~Parser();

      /**
      * Read JSON string from the I/O Device and converts it to a QVariant object
      * @param io Input output device
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true.
      * @returns a QVariant object generated from the JSON string
      */
      QVariant parse(QIODevice* io, bool* ok = 0);

      /**
      * This is a method provided for convenience.
      * @param jsonData data containing the JSON object representation
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true.
      * @returns a QVariant object generated from the JSON string
      * @sa errorString
      * @sa errorLine
      */
      QVariant parse(const QByteArray& jsonData, bool* ok = 0);

      /**
      * This method returns the error message
      * @returns a QString object containing the error message of the last parse operation
      * @sa errorLine
      */
      QString errorString() const;

      /**
      * This method returns line number where the error occurred
      * @returns the line number where the error occurred
      * @sa errorString
      */
      int errorLine() const;

      /**
       * Sets whether special numbers (Infinity, -Infinity, NaN) are allowed as an extension to
       * the standard
       * @param  allowSpecialNumbers new value of whether special numbers are allowed
       * @sa specialNumbersAllowed
       */
      void allowSpecialNumbers(bool allowSpecialNumbers);

      /**
       * @returns whether special numbers (Infinity, -Infinity, NaN) are allowed
       * @sa allowSpecialNumbers
       */
      bool specialNumbersAllowed() const;

    private:
      Q_DISABLE_COPY(Parser)
      ParserPrivate* const d;
  };
  2021-07-25 14:56:46  [ main:528 ] - [ ERROR ]  warning: parse error class QJSON_EXPORT Parser
  {
    public:
      Parser();
      ~Parser();

      /**
      * Read JSON string from the I/O Device and converts it to a QVariant object
      * @param io Input output device
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true.
      * @returns a QVariant object generated from the JSON string
      */
      QVariant parse(QIODevice* io, bool* ok = 0);

      /**
      * This is a method provided for convenience.
      * @param jsonData data containing the JSON object representation
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true.
      * @returns a QVariant object generated from the JSON string
      * @sa errorString
      * @sa errorLine
      */
      QVariant parse(const QByteArray& jsonData, bool* ok = 0);

      /**
      * This method returns the error message
      * @returns a QString object containing the error message of the last parse operation
      * @sa errorLine
      */
      QString errorString() const;

      /**
      * This method returns line number where the error occurred
      * @returns the line number where the error occurred
      * @sa errorString
      */
      int errorLine() const;

      /**
       * Sets whether special numbers (Infinity, -Infinity, NaN) are allowed as an extension to
       * the standard
       * @param  allowSpecialNumbers new value of whether special numbers are allowed
       * @sa specialNumbersAllowed
       */
      void allowSpecialNumbers(bool allowSpecialNumbers);

      /**
       * @returns whether special numbers (Infinity, -Infinity, NaN) are allowed
       * @sa allowSpecialNumbers
       */
      bool specialNumbersAllowed() const;

    private:
      Q_DISABLE_COPY(Parser)
      ParserPrivate* const d;
  };Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\parser.h:41
  2021-07-25 14:56:46  [ main:542 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 14:56:46  [ main:542 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\networkmanager.hpp:11
  2021-07-25 14:56:46  [ main:543 ] - [ ERROR ]  parsing error 
signals:
    void replyReceived(const QVariantMap &reply);
  2021-07-25 14:56:46  [ main:543 ] - [ ERROR ]  warning: parse error signals:
    void replyReceived(const QVariantMap &reply);Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\networkmanager.hpp:29
  2021-07-25 14:56:46  [ main:543 ] - [ ERROR ]  parsing error 
private slots:
    void provideAuthentication(QNetworkReply *reply, QAuthenticator *authenticator);
  2021-07-25 14:56:46  [ main:543 ] - [ ERROR ]  warning: parse error private slots:
    void provideAuthentication(QNetworkReply *reply, QAuthenticator *authenticator);Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\networkmanager.hpp:35
  2021-07-25 14:56:46  [ main:546 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 14:56:46  [ main:546 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\networkmanagerproxy.hpp:10
  2021-07-25 14:56:46  [ main:547 ] - [ ERROR ]  parsing error 
private slots:
    void finished();
  2021-07-25 14:56:46  [ main:547 ] - [ ERROR ]  warning: parse error private slots:
    void finished();Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\networkmanagerproxy.hpp:25
  2021-07-25 14:56:46  [ main:550 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 14:56:46  [ main:550 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\page.hpp:19
  2021-07-25 14:56:46  [ main:551 ] - [ ERROR ]  parsing error 
private slots:
    void loadFinished(bool ok);
  2021-07-25 14:56:46  [ main:551 ] - [ ERROR ]  warning: parse error private slots:
    void loadFinished(bool ok);Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\page.hpp:57
  2021-07-25 14:56:46  [ main:554 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 14:56:46  [ main:555 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\eventprocessor.hpp:9
  2021-07-25 14:56:46  [ main:555 ] - [ ERROR ]  parsing error 
private slots:
    void handleTimeout();
  2021-07-25 14:56:46  [ main:555 ] - [ ERROR ]  warning: parse error private slots:
    void handleTimeout();Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\eventprocessor.hpp:23
  2021-07-25 14:56:46  [ main:559 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 14:56:46  [ main:559 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\webelement.hpp:11
  2021-07-25 14:56:46  [ main:560 ] - [ ERROR ]  parsing error 
private slots:
    void loadFinished(bool ok);
  2021-07-25 14:56:46  [ main:560 ] - [ ERROR ]  warning: parse error private slots:
    void loadFinished(bool ok);Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\webelement.hpp:69
  2021-07-25 14:56:46  [ main:564 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 14:56:46  [ main:564 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\webelementcollection.hpp:11
  2021-07-25 14:56:46  [ main:585 ] - [ ERROR ]  parsing error 
QT_BEGIN_NAMESPACE
  2021-07-25 14:56:46  [ main:585 ] - [ ERROR ]  warning: parse error QT_BEGIN_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializer.h:26
  2021-07-25 14:56:46  [ main:585 ] - [ ERROR ]  parsing error 
QT_END_NAMESPACE
  2021-07-25 14:56:46  [ main:585 ] - [ ERROR ]  warning: parse error QT_END_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializer.h:30
  2021-07-25 14:56:46  [ main:585 ] - [ ERROR ]  parsing error 
class QJSON_EXPORT Serializer {
  public:
    Serializer();
    ~Serializer();

     /**
      * This method generates a textual JSON representation and outputs it to the
      * passed in I/O Device.
      * @param variant The JSON document in its in-memory representation as generated by the
      * parser.
      * @param out Input output device
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true
      */
    void serialize( const QVariant& variant, QIODevice* out, bool* ok);

    /**
      * This is a method provided for convenience. It turns the passed in in-memory
      * representation of the JSON document into a textual one, which is returned.
      * If the returned string is empty, the document was empty. If it was null, there
      * was a parsing error.
      *
      * @param variant The JSON document in its in-memory representation as generated by the
      * parser.
      *
      * \deprecated This method is going to be removed with the next major release of QJson.
      */
    QByteArray serialize( const QVariant& variant);

    /**
      * This is a method provided for convenience. It turns the passed in in-memory
      * representation of the JSON document into a textual one, which is returned.
      * If the returned string is empty, the document was empty. If it was null, there
      * was a parsing error.
      *
      * @param variant The JSON document in its in-memory representation as generated by the
      * parser.
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true
      */
    QByteArray serialize( const QVariant& variant, bool *ok);

    /**
     * Allow or disallow writing of NaN and/or Infinity (as an extension to QJson)
     */
    void allowSpecialNumbers(bool allow);

    /**
     * Is Nan and/or Infinity allowed?
     */
    bool specialNumbersAllowed() const;

    /**
     * set output indentation mode as defined in QJson::IndentMode
     */
    void setIndentMode(IndentMode mode = QJson::IndentNone);


    /**
    * set double precision used while converting Double
    * \sa QByteArray::number
    */
    void setDoublePrecision(int precision);

    /**
     * Returns one of the indentation modes defined in QJson::IndentMode
     */
    IndentMode indentMode() const;

    /**
     * Returns the error message
     */
    QString errorMessage() const;

  private:
    Q_DISABLE_COPY(Serializer)
    class SerializerPrivate;
    SerializerPrivate* const d;
  };
  2021-07-25 14:56:46  [ main:586 ] - [ ERROR ]  warning: parse error class QJSON_EXPORT Serializer {
  public:
    Serializer();
    ~Serializer();

     /**
      * This method generates a textual JSON representation and outputs it to the
      * passed in I/O Device.
      * @param variant The JSON document in its in-memory representation as generated by the
      * parser.
      * @param out Input output device
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true
      */
    void serialize( const QVariant& variant, QIODevice* out, bool* ok);

    /**
      * This is a method provided for convenience. It turns the passed in in-memory
      * representation of the JSON document into a textual one, which is returned.
      * If the returned string is empty, the document was empty. If it was null, there
      * was a parsing error.
      *
      * @param variant The JSON document in its in-memory representation as generated by the
      * parser.
      *
      * \deprecated This method is going to be removed with the next major release of QJson.
      */
    QByteArray serialize( const QVariant& variant);

    /**
      * This is a method provided for convenience. It turns the passed in in-memory
      * representation of the JSON document into a textual one, which is returned.
      * If the returned string is empty, the document was empty. If it was null, there
      * was a parsing error.
      *
      * @param variant The JSON document in its in-memory representation as generated by the
      * parser.
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true
      */
    QByteArray serialize( const QVariant& variant, bool *ok);

    /**
     * Allow or disallow writing of NaN and/or Infinity (as an extension to QJson)
     */
    void allowSpecialNumbers(bool allow);

    /**
     * Is Nan and/or Infinity allowed?
     */
    bool specialNumbersAllowed() const;

    /**
     * set output indentation mode as defined in QJson::IndentMode
     */
    void setIndentMode(IndentMode mode = QJson::IndentNone);


    /**
    * set double precision used while converting Double
    * \sa QByteArray::number
    */
    void setDoublePrecision(int precision);

    /**
     * Returns one of the indentation modes defined in QJson::IndentMode
     */
    IndentMode indentMode() const;

    /**
     * Returns the error message
     */
    QString errorMessage() const;

  private:
    Q_DISABLE_COPY(Serializer)
    class SerializerPrivate;
    SerializerPrivate* const d;
  };Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializer.h:112
  2021-07-25 14:56:46  [ main:589 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 14:56:46  [ main:589 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\cookiejar.hpp:14
  2021-07-25 14:56:46  [ main:652 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\phantompy.hpp
  2021-07-25 14:56:46  [ main:653 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\context.cpp
  2021-07-25 14:56:46  [ main:678 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\context.hpp
  2021-07-25 14:56:46  [ main:679 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\cookiejar.cpp
  2021-07-25 14:56:46  [ main:700 ] - [ ERROR ]  warning: parse error foreach(QNetworkCookie n_cookie, cookiesForUrl(QUrl(url))) {
        cookie["name"] = QString::fromUtf8(n_cookie.name());
        cookie["value"] = QString::fromUtf8(n_cookie.value());
        cookie["domain"] = n_cookie.domain();
        cookie["path"] = n_cookie.path();
        cookie["expires"] = n_cookie.expirationDate().toString(Qt::ISODate);

        cookiesList.append(cookie);
    }Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\cookiejar.cpp:112
  2021-07-25 14:56:46  [ main:700 ] - [ ERROR ]  warning: parse error foreach(QNetworkCookie n_cookie, allCookies()) {
        cookie["name"] = QString::fromUtf8(n_cookie.name());
        cookie["value"] = QString::fromUtf8(n_cookie.value());
        cookie["domain"] = n_cookie.domain();
        cookie["path"] = n_cookie.path();
        cookie["expires"] = n_cookie.expirationDate().toString(Qt::ISODate);

        cookiesList.append(cookie);
    }Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\cookiejar.cpp:129
  2021-07-25 14:56:46  [ main:701 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\cookiejar.hpp
  2021-07-25 14:56:46  [ main:702 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\eventprocessor.cpp
  2021-07-25 14:56:46  [ main:714 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\eventprocessor.hpp
  2021-07-25 14:56:46  [ main:716 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\frame.cpp
  2021-07-25 14:56:46  [ main:745 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\frame.hpp
  2021-07-25 14:56:46  [ main:746 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\image.cpp
  2021-07-25 14:56:46  [ main:752 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\image.hpp
  2021-07-25 14:56:46  [ main:753 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\networkmanager.cpp
  2021-07-25 14:56:46  [ main:761 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 14:56:46  [ main:761 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\networktimeout.hpp:10
  2021-07-25 14:56:46  [ main:768 ] - [ ERROR ]  warning: parse error foreach (QByteArray headerName, reply->rawHeaderList()) {
        QVariantMap header;
        header["name"] = QString::fromUtf8(headerName);
        header["value"] = QString::fromUtf8(reply->rawHeader(headerName));

        headers.append(header);
    }Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\networkmanager.cpp:69
  2021-07-25 14:56:46  [ main:769 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\networkmanager.hpp
  2021-07-25 14:56:46  [ main:771 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\networkmanagerproxy.cpp
  2021-07-25 14:56:46  [ main:779 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\networkmanagerproxy.hpp
  2021-07-25 14:56:46  [ main:780 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\networktimeout.cpp
  2021-07-25 14:56:46  [ main:784 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\networktimeout.hpp
  2021-07-25 14:56:46  [ main:785 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\page.cpp
  2021-07-25 14:56:46  [ main:795 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\page.hpp
  2021-07-25 14:56:46  [ main:796 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\timeout.cpp
  2021-07-25 14:56:46  [ main:801 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\timeout.hpp
  2021-07-25 14:56:46  [ main:802 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\webelement.cpp
  2021-07-25 14:56:46  [ main:813 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\webelement.hpp
  2021-07-25 14:56:46  [ main:814 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\webelementcollection.cpp
  2021-07-25 14:56:46  [ main:819 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\webelementcollection.hpp
  2021-07-25 14:56:46  [ main:821 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\FlexLexer.h
  2021-07-25 14:56:46  [ main:831 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\json_parser.cc
  2021-07-25 14:56:46  [ main:909 ] - [ ERROR ]  parsing error 
Q_DECLARE_METATYPE(QVector<QVariant>*)
  Q_DECLARE_METATYPE(QVariantMap*)


/* Line 33 of lalr1.cc  */
#line 72 "json_parser.hh"


#include <string>
#include <iostream>
#include "stack.hh"
#include "location.hh"

/* Enabling traces.  */
#ifndef YYDEBUG
# define YYDEBUG 1
#endif


namespace yy {
/* Line 33 of lalr1.cc  */
#line 88 "json_parser.hh"

  /// A Bison parser.
  class json_parser
  {
  public:
    /// Symbol semantic values.
#ifndef YYSTYPE
    typedef int semantic_type;
#else
    typedef YYSTYPE semantic_type;
#endif
    /// Symbol locations.
    typedef location location_type;
    /// Tokens.
    struct token
    {
      /* Tokens.  */
   enum yytokentype {
     END = 0,
     CURLY_BRACKET_OPEN = 1,
     CURLY_BRACKET_CLOSE = 2,
     SQUARE_BRACKET_OPEN = 3,
     SQUARE_BRACKET_CLOSE = 4,
     COLON = 5,
     COMMA = 6,
     NUMBER = 7,
     TRUE_VAL = 8,
     FALSE_VAL = 9,
     NULL_VAL = 10,
     STRING = 11,
     INVALID = 12
   };

    };
    /// Token type.
    typedef token::yytokentype token_type;

    /// Build a parser object.
    json_parser (QJson::ParserPrivate* driver_yyarg);
    virtual ~json_parser ();

    /// Parse.
    /// \returns  0 iff parsing succeeded.
    virtual int parse ();

#if YYDEBUG
    /// The current debugging stream.
    std::ostream& debug_stream () const;
    /// Set the current debugging stream.
    void set_debug_stream (std::ostream &);

    /// Type for debugging levels.
    typedef int debug_level_type;
    /// The current debugging level.
    debug_level_type debug_level () const;
    /// Set the current debugging level.
    void set_debug_level (debug_level_type l);
#endif

  private:
    /// Report a syntax error.
    /// \param loc    where the syntax error is found.
    /// \param msg    a description of the syntax error.
    virtual void error (const location_type& loc, const std::string& msg);

    /// Generate an error message.
    /// \param state   the state where the error occurred.
    /// \param tok     the lookahead token.
    virtual std::string yysyntax_error_ (int yystate, int tok);

#if YYDEBUG
    /// \brief Report a symbol value on the debug stream.
    /// \param yytype       The token type.
    /// \param yyvaluep     Its semantic value.
    /// \param yylocationp  Its location.
    virtual void yy_symbol_value_print_ (int yytype,
					 const semantic_type* yyvaluep,
					 const location_type* yylocationp);
    /// \brief Report a symbol on the debug stream.
    /// \param yytype       The token type.
    /// \param yyvaluep     Its semantic value.
    /// \param yylocationp  Its location.
    virtual void yy_symbol_print_ (int yytype,
				   const semantic_type* yyvaluep,
				   const location_type* yylocationp);
#endif


    /// State numbers.
    typedef int state_type;
    /// State stack type.
    typedef stack<state_type>    state_stack_type;
    /// Semantic value stack type.
    typedef stack<semantic_type> semantic_stack_type;
    /// location stack type.
    typedef stack<location_type> location_stack_type;

    /// The state stack.
    state_stack_type yystate_stack_;
    /// The semantic value stack.
    semantic_stack_type yysemantic_stack_;
    /// The location stack.
    location_stack_type yylocation_stack_;

    /// Whether the given \c yypact_ value indicates a defaulted state.
    /// \param yyvalue   the value to check
    static bool yy_pact_value_is_default_ (int yyvalue);

    /// Whether the given \c yytable_ value indicates a syntax error.
    /// \param yyvalue   the value to check
    static bool yy_table_value_is_error_ (int yyvalue);

    /// Internal symbol numbers.
    typedef unsigned char token_number_type;
    /* Tables.  */
    /// For a state, the index in \a yytable_ of its portion.
    static const signed char yypact_[];
    static const signed char yypact_ninf_;

    /// For a state, default reduction number.
    /// Unless\a  yytable_ specifies something else to do.
    /// Zero means the default is an error.
    static const unsigned char yydefact_[];

    static const signed char yypgoto_[];
    static const signed char yydefgoto_[];

    /// What to do in a state.
    /// \a yytable_[yypact_[s]]: what to do in state \a s.
    /// - if positive, shift that token.
    /// - if negative, reduce the rule which number is the opposite.
    /// - if zero, do what YYDEFACT says.
    static const unsigned char yytable_[];
    static const signed char yytable_ninf_;

    static const signed char yycheck_[];

    /// For a state, its accessing symbol.
    static const unsigned char yystos_[];

    /// For a rule, its LHS.
    static const unsigned char yyr1_[];
    /// For a rule, its RHS length.
    static const unsigned char yyr2_[]; 

    /// Convert the symbol name \a n to a form suitable for a diagnostic.
    static std::string yytnamerr_ (const char *n);


    /// For a symbol, its name in clear.
    static const char* const yytname_[];
#if YYDEBUG
    /// A type to store symbol numbers and -1.
    typedef signed char rhs_number_type;
    /// A `-1'-separated list of the rules' RHS.
    static const rhs_number_type yyrhs_[];
    /// For each rule, the index of the first RHS symbol in \a yyrhs_.
    static const unsigned char yyprhs_[];
    /// For each rule, its source line number.
    static const unsigned char yyrline_[];
    /// For each scanner token number, its symbol number.
    static const unsigned short int yytoken_number_[];
    /// Report on the debug stream that the rule \a r is going to be reduced.
    virtual void yy_reduce_print_ (int r);
    /// Print the state stack on the debug stream.
    virtual void yystack_print_ ();

    /* Debugging.  */
    int yydebug_;
    std::ostream* yycdebug_;
#endif

    /// Convert a scanner token number \a t to a symbol number.
    token_number_type yytranslate_ (int t);

    /// \brief Reclaim the memory associated to a symbol.
    /// \param yymsg        Why this token is reclaimed.
    ///                     If null, do not display the symbol, just free it.
    /// \param yytype       The symbol type.
    /// \param yyvaluep     Its semantic value.
    /// \param yylocationp  Its location.
    inline void yydestruct_ (const char* yymsg,
			     int yytype,
			     semantic_type* yyvaluep,
			     location_type* yylocationp);

    /// Pop \a n symbols the three stacks.
    inline void yypop_ (unsigned int n = 1);

    /* Constants.  */
    static const int yyeof_;
    /* LAST_ -- Last index in TABLE_.  */
    static const int yylast_;
    static const int yynnts_;
    static const int yyempty_;
    static const int yyfinal_;
    static const int yyterror_;
    static const int yyerrcode_;
    static const int yyntokens_;
    static const unsigned int yyuser_token_number_max_;
    static const token_number_type yyundef_token_;

    /* User arguments.  */
    QJson::ParserPrivate* driver;
  };

}
  2021-07-25 14:56:46  [ main:910 ] - [ ERROR ]  warning: parse error Q_DECLARE_METATYPE(QVector<QVariant>*)
  Q_DECLARE_METATYPE(QVariantMap*)


/* Line 33 of lalr1.cc  */
#line 72 "json_parser.hh"


#include <string>
#include <iostream>
#include "stack.hh"
#include "location.hh"

/* Enabling traces.  */
#ifndef YYDEBUG
# define YYDEBUG 1
#endif


namespace yy {
/* Line 33 of lalr1.cc  */
#line 88 "json_parser.hh"

  /// A Bison parser.
  class json_parser
  {
  public:
    /// Symbol semantic values.
#ifndef YYSTYPE
    typedef int semantic_type;
#else
    typedef YYSTYPE semantic_type;
#endif
    /// Symbol locations.
    typedef location location_type;
    /// Tokens.
    struct token
    {
      /* Tokens.  */
   enum yytokentype {
     END = 0,
     CURLY_BRACKET_OPEN = 1,
     CURLY_BRACKET_CLOSE = 2,
     SQUARE_BRACKET_OPEN = 3,
     SQUARE_BRACKET_CLOSE = 4,
     COLON = 5,
     COMMA = 6,
     NUMBER = 7,
     TRUE_VAL = 8,
     FALSE_VAL = 9,
     NULL_VAL = 10,
     STRING = 11,
     INVALID = 12
   };

    };
    /// Token type.
    typedef token::yytokentype token_type;

    /// Build a parser object.
    json_parser (QJson::ParserPrivate* driver_yyarg);
    virtual ~json_parser ();

    /// Parse.
    /// \returns  0 iff parsing succeeded.
    virtual int parse ();

#if YYDEBUG
    /// The current debugging stream.
    std::ostream& debug_stream () const;
    /// Set the current debugging stream.
    void set_debug_stream (std::ostream &);

    /// Type for debugging levels.
    typedef int debug_level_type;
    /// The current debugging level.
    debug_level_type debug_level () const;
    /// Set the current debugging level.
    void set_debug_level (debug_level_type l);
#endif

  private:
    /// Report a syntax error.
    /// \param loc    where the syntax error is found.
    /// \param msg    a description of the syntax error.
    virtual void error (const location_type& loc, const std::string& msg);

    /// Generate an error message.
    /// \param state   the state where the error occurred.
    /// \param tok     the lookahead token.
    virtual std::string yysyntax_error_ (int yystate, int tok);

#if YYDEBUG
    /// \brief Report a symbol value on the debug stream.
    /// \param yytype       The token type.
    /// \param yyvaluep     Its semantic value.
    /// \param yylocationp  Its location.
    virtual void yy_symbol_value_print_ (int yytype,
					 const semantic_type* yyvaluep,
					 const location_type* yylocationp);
    /// \brief Report a symbol on the debug stream.
    /// \param yytype       The token type.
    /// \param yyvaluep     Its semantic value.
    /// \param yylocationp  Its location.
    virtual void yy_symbol_print_ (int yytype,
				   const semantic_type* yyvaluep,
				   const location_type* yylocationp);
#endif


    /// State numbers.
    typedef int state_type;
    /// State stack type.
    typedef stack<state_type>    state_stack_type;
    /// Semantic value stack type.
    typedef stack<semantic_type> semantic_stack_type;
    /// location stack type.
    typedef stack<location_type> location_stack_type;

    /// The state stack.
    state_stack_type yystate_stack_;
    /// The semantic value stack.
    semantic_stack_type yysemantic_stack_;
    /// The location stack.
    location_stack_type yylocation_stack_;

    /// Whether the given \c yypact_ value indicates a defaulted state.
    /// \param yyvalue   the value to check
    static bool yy_pact_value_is_default_ (int yyvalue);

    /// Whether the given \c yytable_ value indicates a syntax error.
    /// \param yyvalue   the value to check
    static bool yy_table_value_is_error_ (int yyvalue);

    /// Internal symbol numbers.
    typedef unsigned char token_number_type;
    /* Tables.  */
    /// For a state, the index in \a yytable_ of its portion.
    static const signed char yypact_[];
    static const signed char yypact_ninf_;

    /// For a state, default reduction number.
    /// Unless\a  yytable_ specifies something else to do.
    /// Zero means the default is an error.
    static const unsigned char yydefact_[];

    static const signed char yypgoto_[];
    static const signed char yydefgoto_[];

    /// What to do in a state.
    /// \a yytable_[yypact_[s]]: what to do in state \a s.
    /// - if positive, shift that token.
    /// - if negative, reduce the rule which number is the opposite.
    /// - if zero, do what YYDEFACT says.
    static const unsigned char yytable_[];
    static const signed char yytable_ninf_;

    static const signed char yycheck_[];

    /// For a state, its accessing symbol.
    static const unsigned char yystos_[];

    /// For a rule, its LHS.
    static const unsigned char yyr1_[];
    /// For a rule, its RHS length.
    static const unsigned char yyr2_[]; 

    /// Convert the symbol name \a n to a form suitable for a diagnostic.
    static std::string yytnamerr_ (const char *n);


    /// For a symbol, its name in clear.
    static const char* const yytname_[];
#if YYDEBUG
    /// A type to store symbol numbers and -1.
    typedef signed char rhs_number_type;
    /// A `-1'-separated list of the rules' RHS.
    static const rhs_number_type yyrhs_[];
    /// For each rule, the index of the first RHS symbol in \a yyrhs_.
    static const unsigned char yyprhs_[];
    /// For each rule, its source line number.
    static const unsigned char yyrline_[];
    /// For each scanner token number, its symbol number.
    static const unsigned short int yytoken_number_[];
    /// Report on the debug stream that the rule \a r is going to be reduced.
    virtual void yy_reduce_print_ (int r);
    /// Print the state stack on the debug stream.
    virtual void yystack_print_ ();

    /* Debugging.  */
    int yydebug_;
    std::ostream* yycdebug_;
#endif

    /// Convert a scanner token number \a t to a symbol number.
    token_number_type yytranslate_ (int t);

    /// \brief Reclaim the memory associated to a symbol.
    /// \param yymsg        Why this token is reclaimed.
    ///                     If null, do not display the symbol, just free it.
    /// \param yytype       The symbol type.
    /// \param yyvaluep     Its semantic value.
    /// \param yylocationp  Its location.
    inline void yydestruct_ (const char* yymsg,
			     int yytype,
			     semantic_type* yyvaluep,
			     location_type* yylocationp);

    /// Pop \a n symbols the three stacks.
    inline void yypop_ (unsigned int n = 1);

    /* Constants.  */
    static const int yyeof_;
    /* LAST_ -- Last index in TABLE_.  */
    static const int yylast_;
    static const int yynnts_;
    static const int yyempty_;
    static const int yyfinal_;
    static const int yyterror_;
    static const int yyerrcode_;
    static const int yyntokens_;
    static const unsigned int yyuser_token_number_max_;
    static const token_number_type yyundef_token_;

    /* User arguments.  */
    QJson::ParserPrivate* driver;
  };

}Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\json_parser.hh:66
  2021-07-25 14:56:46  [ main:952 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\json_parser.hh
  2021-07-25 14:56:46  [ main:953 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\json_scanner.cc
  2021-07-25 14:56:47  [ main:1293 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\json_scanner.cpp
  2021-07-25 14:56:47  [ main:1301 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\json_scanner.h
  2021-07-25 14:56:47  [ main:1302 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\location.hh
  2021-07-25 14:56:47  [ main:1302 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\parser.cpp
  2021-07-25 14:56:47  [ main:1314 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\parser.h
  2021-07-25 14:56:47  [ main:1315 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\parserrunnable.cpp
  2021-07-25 14:56:47  [ main:1323 ] - [ ERROR ]  parsing error 
QT_BEGIN_NAMESPACE
  2021-07-25 14:56:47  [ main:1323 ] - [ ERROR ]  warning: parse error QT_BEGIN_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\parserrunnable.h:29
  2021-07-25 14:56:47  [ main:1323 ] - [ ERROR ]  parsing error 
QT_END_NAMESPACE
  2021-07-25 14:56:47  [ main:1323 ] - [ ERROR ]  warning: parse error QT_END_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\parserrunnable.h:31
  2021-07-25 14:56:47  [ main:1323 ] - [ ERROR ]  parsing error 
class QJSON_EXPORT ParserRunnable  : public QObject, public QRunnable
  {
    Q_OBJECT
    public:
      explicit ParserRunnable(QObject* parent = 0);
      ~ParserRunnable();

      void setData( const QByteArray& data );

      void run();

    Q_SIGNALS:
      /**
      * This signal is emitted when the parsing process has been completed
      * @param json contains the result of the parsing
      * @param ok if a parsing error occurs ok is set to false, otherwise it's set to true.
      * @param error_msg contains a string explaining the failure reason
      **/
      void parsingFinished(const QVariant& json, bool ok, const QString& error_msg);

    private:
      Q_DISABLE_COPY(ParserRunnable)
      class Private;
      Private* const d;
  };
  2021-07-25 14:56:47  [ main:1323 ] - [ ERROR ]  warning: parse error class QJSON_EXPORT ParserRunnable  : public QObject, public QRunnable
  {
    Q_OBJECT
    public:
      explicit ParserRunnable(QObject* parent = 0);
      ~ParserRunnable();

      void setData( const QByteArray& data );

      void run();

    Q_SIGNALS:
      /**
      * This signal is emitted when the parsing process has been completed
      * @param json contains the result of the parsing
      * @param ok if a parsing error occurs ok is set to false, otherwise it's set to true.
      * @param error_msg contains a string explaining the failure reason
      **/
      void parsingFinished(const QVariant& json, bool ok, const QString& error_msg);

    private:
      Q_DISABLE_COPY(ParserRunnable)
      class Private;
      Private* const d;
  };Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\parserrunnable.h:37
  2021-07-25 14:56:47  [ main:1327 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\parserrunnable.h
  2021-07-25 14:56:47  [ main:1328 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\parser_p.h
  2021-07-25 14:56:47  [ main:1329 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\position.hh
  2021-07-25 14:56:47  [ main:1338 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\qjson_debug.h
  2021-07-25 14:56:47  [ main:1339 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\qjson_export.h
  2021-07-25 14:56:47  [ main:1340 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\qobjecthelper.cpp
  2021-07-25 14:56:47  [ main:1347 ] - [ ERROR ]  parsing error 
QT_BEGIN_NAMESPACE
  2021-07-25 14:56:47  [ main:1347 ] - [ ERROR ]  warning: parse error QT_BEGIN_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\qobjecthelper.h:30
  2021-07-25 14:56:47  [ main:1347 ] - [ ERROR ]  parsing error 
QT_END_NAMESPACE
  2021-07-25 14:56:47  [ main:1347 ] - [ ERROR ]  warning: parse error QT_END_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\qobjecthelper.h:32
  2021-07-25 14:56:47  [ main:1347 ] - [ ERROR ]  parsing error 
class QJSON_EXPORT QObjectHelper {
    public:
      QObjectHelper();
      ~QObjectHelper();

    /**
    * This method converts a QObject instance into a QVariantMap.
    *
    * @param object The QObject instance to be converted.
    * @param ignoredProperties Properties that won't be converted.
    */
    static QVariantMap qobject2qvariant( const QObject* object,
                                  const QStringList& ignoredProperties = QStringList(QString(QLatin1String("objectName"))));

    /**
    * This method converts a QVariantMap instance into a QObject
    *
    * @param variant Attributes to assign to the object.
    * @param object The QObject instance to update.
    */
    static void qvariant2qobject(const QVariantMap& variant, QObject* object);

    private:
      Q_DISABLE_COPY(QObjectHelper)
      class QObjectHelperPrivate;
      QObjectHelperPrivate* const d;
  };
  2021-07-25 14:56:47  [ main:1347 ] - [ ERROR ]  warning: parse error class QJSON_EXPORT QObjectHelper {
    public:
      QObjectHelper();
      ~QObjectHelper();

    /**
    * This method converts a QObject instance into a QVariantMap.
    *
    * @param object The QObject instance to be converted.
    * @param ignoredProperties Properties that won't be converted.
    */
    static QVariantMap qobject2qvariant( const QObject* object,
                                  const QStringList& ignoredProperties = QStringList(QString(QLatin1String("objectName"))));

    /**
    * This method converts a QVariantMap instance into a QObject
    *
    * @param variant Attributes to assign to the object.
    * @param object The QObject instance to update.
    */
    static void qvariant2qobject(const QVariantMap& variant, QObject* object);

    private:
      Q_DISABLE_COPY(QObjectHelper)
      class QObjectHelperPrivate;
      QObjectHelperPrivate* const d;
  };Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\qobjecthelper.h:118
  2021-07-25 14:56:47  [ main:1353 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\qobjecthelper.h
  2021-07-25 14:56:47  [ main:1354 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\serializer.cpp
  2021-07-25 14:56:47  [ main:1372 ] - [ ERROR ]  warning: parse error Q_FOREACH( const QByteArray& i, list ) {
    if ( !res.isEmpty() )
      res += sep;
    res += i;
  }Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializer.cpp:55
  2021-07-25 14:56:47  [ main:1373 ] - [ ERROR ]  warning: parse error Q_FOREACH( const QVariant& var, list )
    {
      indentLevel++;
      QByteArray serializedValue = serialize( var, ok, indentLevel);
      indentLevel--;
      if ( !*ok ) {
        break;
      }
      values << serializedValue;
    }Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializer.cpp:72
  2021-07-25 14:56:47  [ main:1384 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\serializer.h
  2021-07-25 14:56:47  [ main:1385 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\serializerrunnable.cpp
  2021-07-25 14:56:47  [ main:1391 ] - [ ERROR ]  parsing error 
QT_BEGIN_NAMESPACE
  2021-07-25 14:56:47  [ main:1391 ] - [ ERROR ]  warning: parse error QT_BEGIN_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializerrunnable.h:29
  2021-07-25 14:56:47  [ main:1392 ] - [ ERROR ]  parsing error 
QT_END_NAMESPACE
  2021-07-25 14:56:47  [ main:1392 ] - [ ERROR ]  warning: parse error QT_END_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializerrunnable.h:33
  2021-07-25 14:56:47  [ main:1392 ] - [ ERROR ]  parsing error 
class QJSON_EXPORT SerializerRunnable  : public QObject, public QRunnable
  {
    Q_OBJECT
    public:
      explicit SerializerRunnable(QObject* parent = 0);
      ~SerializerRunnable();

      /**
       * Sets the json object to serialize.
       *
       * @param json QVariant containing the json representation to be serialized
       */
      void setJsonObject( const QVariant& json );

      /* reimp */ void run();

    Q_SIGNALS:
      /**
      * This signal is emitted when the serialization process has been completed
      * @param serialized contains the result of the serialization
      * @param ok if a serialization error occurs ok is set to false, otherwise it's set to true.
      * @param error_msg contains a string explaining the failure reason
      **/
      void parsingFinished(const QByteArray& serialized, bool ok, const QString& error_msg);

    private:
      Q_DISABLE_COPY(SerializerRunnable)
      class Private;
      Private* const d;
  };
  2021-07-25 14:56:47  [ main:1392 ] - [ ERROR ]  warning: parse error class QJSON_EXPORT SerializerRunnable  : public QObject, public QRunnable
  {
    Q_OBJECT
    public:
      explicit SerializerRunnable(QObject* parent = 0);
      ~SerializerRunnable();

      /**
       * Sets the json object to serialize.
       *
       * @param json QVariant containing the json representation to be serialized
       */
      void setJsonObject( const QVariant& json );

      /* reimp */ void run();

    Q_SIGNALS:
      /**
      * This signal is emitted when the serialization process has been completed
      * @param serialized contains the result of the serialization
      * @param ok if a serialization error occurs ok is set to false, otherwise it's set to true.
      * @param error_msg contains a string explaining the failure reason
      **/
      void parsingFinished(const QByteArray& serialized, bool ok, const QString& error_msg);

    private:
      Q_DISABLE_COPY(SerializerRunnable)
      class Private;
      Private* const d;
  };Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializerrunnable.h:39
  2021-07-25 14:56:47  [ main:1396 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\serializerrunnable.h
  2021-07-25 14:56:47  [ main:1397 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\stack.hh
  2021-07-25 14:56:47  [ main:1399 ] - [ INFO ]  start dependency
  2021-07-25 14:56:47  [ main:1472 ] - [ INFO ]  includenum:73
  2021-07-25 14:56:47  [ main:1473 ] - [ INFO ]  definenum:81
  2021-07-25 14:56:47  [ main:1473 ] - [ INFO ]  callnum:45
  2021-07-25 14:56:47  [ main:1473 ] - [ INFO ]  returnnum:159
  2021-07-25 14:56:47  [ main:1473 ] - [ INFO ]  parameternum:614
  2021-07-25 14:56:47  [ main:1473 ] - [ INFO ]  extendnum:1
  2021-07-25 14:56:47  [ main:1473 ] - [ INFO ]  overridenum:1
  2021-07-25 14:56:47  [ main:1579 ] - [ INFO ]  Process finish!
  2021-07-25 15:00:38  [ main:0 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\phantompy.cpp
  2021-07-25 15:00:38  [ main:447 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 15:00:38  [ main:495 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\frame.hpp:11
  2021-07-25 15:00:38  [ main:498 ] - [ ERROR ]  parsing error 
private slots:
    void loadFinished(bool ok);
  2021-07-25 15:00:38  [ main:498 ] - [ ERROR ]  warning: parse error private slots:
    void loadFinished(bool ok);Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\frame.hpp:38
  2021-07-25 15:00:38  [ main:501 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 15:00:38  [ main:502 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\image.hpp:9
  2021-07-25 15:00:38  [ main:519 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 15:00:38  [ main:519 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\timeout.hpp:9
  2021-07-25 15:00:38  [ main:520 ] - [ ERROR ]  parsing error 
private slots:
    void handleTimeout();
  2021-07-25 15:00:38  [ main:520 ] - [ ERROR ]  warning: parse error private slots:
    void handleTimeout();Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\timeout.hpp:22
  2021-07-25 15:00:38  [ main:529 ] - [ ERROR ]  parsing error 
QT_BEGIN_NAMESPACE
  2021-07-25 15:00:38  [ main:529 ] - [ ERROR ]  warning: parse error QT_BEGIN_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\parser.h:26
  2021-07-25 15:00:38  [ main:530 ] - [ ERROR ]  parsing error 
QT_END_NAMESPACE
  2021-07-25 15:00:38  [ main:530 ] - [ ERROR ]  warning: parse error QT_END_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\parser.h:29
  2021-07-25 15:00:38  [ main:531 ] - [ ERROR ]  parsing error 
class QJSON_EXPORT Parser
  {
    public:
      Parser();
      ~Parser();

      /**
      * Read JSON string from the I/O Device and converts it to a QVariant object
      * @param io Input output device
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true.
      * @returns a QVariant object generated from the JSON string
      */
      QVariant parse(QIODevice* io, bool* ok = 0);

      /**
      * This is a method provided for convenience.
      * @param jsonData data containing the JSON object representation
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true.
      * @returns a QVariant object generated from the JSON string
      * @sa errorString
      * @sa errorLine
      */
      QVariant parse(const QByteArray& jsonData, bool* ok = 0);

      /**
      * This method returns the error message
      * @returns a QString object containing the error message of the last parse operation
      * @sa errorLine
      */
      QString errorString() const;

      /**
      * This method returns line number where the error occurred
      * @returns the line number where the error occurred
      * @sa errorString
      */
      int errorLine() const;

      /**
       * Sets whether special numbers (Infinity, -Infinity, NaN) are allowed as an extension to
       * the standard
       * @param  allowSpecialNumbers new value of whether special numbers are allowed
       * @sa specialNumbersAllowed
       */
      void allowSpecialNumbers(bool allowSpecialNumbers);

      /**
       * @returns whether special numbers (Infinity, -Infinity, NaN) are allowed
       * @sa allowSpecialNumbers
       */
      bool specialNumbersAllowed() const;

    private:
      Q_DISABLE_COPY(Parser)
      ParserPrivate* const d;
  };
  2021-07-25 15:00:38  [ main:531 ] - [ ERROR ]  warning: parse error class QJSON_EXPORT Parser
  {
    public:
      Parser();
      ~Parser();

      /**
      * Read JSON string from the I/O Device and converts it to a QVariant object
      * @param io Input output device
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true.
      * @returns a QVariant object generated from the JSON string
      */
      QVariant parse(QIODevice* io, bool* ok = 0);

      /**
      * This is a method provided for convenience.
      * @param jsonData data containing the JSON object representation
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true.
      * @returns a QVariant object generated from the JSON string
      * @sa errorString
      * @sa errorLine
      */
      QVariant parse(const QByteArray& jsonData, bool* ok = 0);

      /**
      * This method returns the error message
      * @returns a QString object containing the error message of the last parse operation
      * @sa errorLine
      */
      QString errorString() const;

      /**
      * This method returns line number where the error occurred
      * @returns the line number where the error occurred
      * @sa errorString
      */
      int errorLine() const;

      /**
       * Sets whether special numbers (Infinity, -Infinity, NaN) are allowed as an extension to
       * the standard
       * @param  allowSpecialNumbers new value of whether special numbers are allowed
       * @sa specialNumbersAllowed
       */
      void allowSpecialNumbers(bool allowSpecialNumbers);

      /**
       * @returns whether special numbers (Infinity, -Infinity, NaN) are allowed
       * @sa allowSpecialNumbers
       */
      bool specialNumbersAllowed() const;

    private:
      Q_DISABLE_COPY(Parser)
      ParserPrivate* const d;
  };Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\parser.h:41
  2021-07-25 15:00:38  [ main:547 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 15:00:38  [ main:547 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\networkmanager.hpp:11
  2021-07-25 15:00:38  [ main:548 ] - [ ERROR ]  parsing error 
signals:
    void replyReceived(const QVariantMap &reply);
  2021-07-25 15:00:38  [ main:548 ] - [ ERROR ]  warning: parse error signals:
    void replyReceived(const QVariantMap &reply);Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\networkmanager.hpp:29
  2021-07-25 15:00:38  [ main:548 ] - [ ERROR ]  parsing error 
private slots:
    void provideAuthentication(QNetworkReply *reply, QAuthenticator *authenticator);
  2021-07-25 15:00:38  [ main:548 ] - [ ERROR ]  warning: parse error private slots:
    void provideAuthentication(QNetworkReply *reply, QAuthenticator *authenticator);Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\networkmanager.hpp:35
  2021-07-25 15:00:38  [ main:552 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 15:00:38  [ main:552 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\networkmanagerproxy.hpp:10
  2021-07-25 15:00:38  [ main:552 ] - [ ERROR ]  parsing error 
private slots:
    void finished();
  2021-07-25 15:00:38  [ main:552 ] - [ ERROR ]  warning: parse error private slots:
    void finished();Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\networkmanagerproxy.hpp:25
  2021-07-25 15:00:38  [ main:557 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 15:00:38  [ main:557 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\page.hpp:19
  2021-07-25 15:00:38  [ main:558 ] - [ ERROR ]  parsing error 
private slots:
    void loadFinished(bool ok);
  2021-07-25 15:00:38  [ main:558 ] - [ ERROR ]  warning: parse error private slots:
    void loadFinished(bool ok);Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\page.hpp:57
  2021-07-25 15:00:38  [ main:561 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 15:00:38  [ main:562 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\eventprocessor.hpp:9
  2021-07-25 15:00:38  [ main:563 ] - [ ERROR ]  parsing error 
private slots:
    void handleTimeout();
  2021-07-25 15:00:38  [ main:563 ] - [ ERROR ]  warning: parse error private slots:
    void handleTimeout();Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\eventprocessor.hpp:23
  2021-07-25 15:00:38  [ main:566 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 15:00:38  [ main:567 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\webelement.hpp:11
  2021-07-25 15:00:38  [ main:568 ] - [ ERROR ]  parsing error 
private slots:
    void loadFinished(bool ok);
  2021-07-25 15:00:38  [ main:568 ] - [ ERROR ]  warning: parse error private slots:
    void loadFinished(bool ok);Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\webelement.hpp:69
  2021-07-25 15:00:38  [ main:572 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 15:00:38  [ main:572 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\webelementcollection.hpp:11
  2021-07-25 15:00:38  [ main:590 ] - [ ERROR ]  parsing error 
QT_BEGIN_NAMESPACE
  2021-07-25 15:00:38  [ main:590 ] - [ ERROR ]  warning: parse error QT_BEGIN_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializer.h:26
  2021-07-25 15:00:38  [ main:590 ] - [ ERROR ]  parsing error 
QT_END_NAMESPACE
  2021-07-25 15:00:38  [ main:590 ] - [ ERROR ]  warning: parse error QT_END_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializer.h:30
  2021-07-25 15:00:38  [ main:591 ] - [ ERROR ]  parsing error 
class QJSON_EXPORT Serializer {
  public:
    Serializer();
    ~Serializer();

     /**
      * This method generates a textual JSON representation and outputs it to the
      * passed in I/O Device.
      * @param variant The JSON document in its in-memory representation as generated by the
      * parser.
      * @param out Input output device
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true
      */
    void serialize( const QVariant& variant, QIODevice* out, bool* ok);

    /**
      * This is a method provided for convenience. It turns the passed in in-memory
      * representation of the JSON document into a textual one, which is returned.
      * If the returned string is empty, the document was empty. If it was null, there
      * was a parsing error.
      *
      * @param variant The JSON document in its in-memory representation as generated by the
      * parser.
      *
      * \deprecated This method is going to be removed with the next major release of QJson.
      */
    QByteArray serialize( const QVariant& variant);

    /**
      * This is a method provided for convenience. It turns the passed in in-memory
      * representation of the JSON document into a textual one, which is returned.
      * If the returned string is empty, the document was empty. If it was null, there
      * was a parsing error.
      *
      * @param variant The JSON document in its in-memory representation as generated by the
      * parser.
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true
      */
    QByteArray serialize( const QVariant& variant, bool *ok);

    /**
     * Allow or disallow writing of NaN and/or Infinity (as an extension to QJson)
     */
    void allowSpecialNumbers(bool allow);

    /**
     * Is Nan and/or Infinity allowed?
     */
    bool specialNumbersAllowed() const;

    /**
     * set output indentation mode as defined in QJson::IndentMode
     */
    void setIndentMode(IndentMode mode = QJson::IndentNone);


    /**
    * set double precision used while converting Double
    * \sa QByteArray::number
    */
    void setDoublePrecision(int precision);

    /**
     * Returns one of the indentation modes defined in QJson::IndentMode
     */
    IndentMode indentMode() const;

    /**
     * Returns the error message
     */
    QString errorMessage() const;

  private:
    Q_DISABLE_COPY(Serializer)
    class SerializerPrivate;
    SerializerPrivate* const d;
  };
  2021-07-25 15:00:38  [ main:591 ] - [ ERROR ]  warning: parse error class QJSON_EXPORT Serializer {
  public:
    Serializer();
    ~Serializer();

     /**
      * This method generates a textual JSON representation and outputs it to the
      * passed in I/O Device.
      * @param variant The JSON document in its in-memory representation as generated by the
      * parser.
      * @param out Input output device
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true
      */
    void serialize( const QVariant& variant, QIODevice* out, bool* ok);

    /**
      * This is a method provided for convenience. It turns the passed in in-memory
      * representation of the JSON document into a textual one, which is returned.
      * If the returned string is empty, the document was empty. If it was null, there
      * was a parsing error.
      *
      * @param variant The JSON document in its in-memory representation as generated by the
      * parser.
      *
      * \deprecated This method is going to be removed with the next major release of QJson.
      */
    QByteArray serialize( const QVariant& variant);

    /**
      * This is a method provided for convenience. It turns the passed in in-memory
      * representation of the JSON document into a textual one, which is returned.
      * If the returned string is empty, the document was empty. If it was null, there
      * was a parsing error.
      *
      * @param variant The JSON document in its in-memory representation as generated by the
      * parser.
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true
      */
    QByteArray serialize( const QVariant& variant, bool *ok);

    /**
     * Allow or disallow writing of NaN and/or Infinity (as an extension to QJson)
     */
    void allowSpecialNumbers(bool allow);

    /**
     * Is Nan and/or Infinity allowed?
     */
    bool specialNumbersAllowed() const;

    /**
     * set output indentation mode as defined in QJson::IndentMode
     */
    void setIndentMode(IndentMode mode = QJson::IndentNone);


    /**
    * set double precision used while converting Double
    * \sa QByteArray::number
    */
    void setDoublePrecision(int precision);

    /**
     * Returns one of the indentation modes defined in QJson::IndentMode
     */
    IndentMode indentMode() const;

    /**
     * Returns the error message
     */
    QString errorMessage() const;

  private:
    Q_DISABLE_COPY(Serializer)
    class SerializerPrivate;
    SerializerPrivate* const d;
  };Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializer.h:112
  2021-07-25 15:00:38  [ main:594 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 15:00:38  [ main:594 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\cookiejar.hpp:14
  2021-07-25 15:00:38  [ main:656 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\phantompy.hpp
  2021-07-25 15:00:38  [ main:657 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\context.cpp
  2021-07-25 15:00:38  [ main:680 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\context.hpp
  2021-07-25 15:00:38  [ main:681 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\cookiejar.cpp
  2021-07-25 15:00:38  [ main:703 ] - [ ERROR ]  warning: parse error foreach(QNetworkCookie n_cookie, cookiesForUrl(QUrl(url))) {
        cookie["name"] = QString::fromUtf8(n_cookie.name());
        cookie["value"] = QString::fromUtf8(n_cookie.value());
        cookie["domain"] = n_cookie.domain();
        cookie["path"] = n_cookie.path();
        cookie["expires"] = n_cookie.expirationDate().toString(Qt::ISODate);

        cookiesList.append(cookie);
    }Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\cookiejar.cpp:112
  2021-07-25 15:00:38  [ main:703 ] - [ ERROR ]  warning: parse error foreach(QNetworkCookie n_cookie, allCookies()) {
        cookie["name"] = QString::fromUtf8(n_cookie.name());
        cookie["value"] = QString::fromUtf8(n_cookie.value());
        cookie["domain"] = n_cookie.domain();
        cookie["path"] = n_cookie.path();
        cookie["expires"] = n_cookie.expirationDate().toString(Qt::ISODate);

        cookiesList.append(cookie);
    }Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\cookiejar.cpp:129
  2021-07-25 15:00:38  [ main:704 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\cookiejar.hpp
  2021-07-25 15:00:38  [ main:705 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\eventprocessor.cpp
  2021-07-25 15:00:38  [ main:713 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\eventprocessor.hpp
  2021-07-25 15:00:38  [ main:714 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\frame.cpp
  2021-07-25 15:00:38  [ main:743 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\frame.hpp
  2021-07-25 15:00:38  [ main:744 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\image.cpp
  2021-07-25 15:00:38  [ main:749 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\image.hpp
  2021-07-25 15:00:38  [ main:750 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\networkmanager.cpp
  2021-07-25 15:00:38  [ main:757 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 15:00:38  [ main:757 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\networktimeout.hpp:10
  2021-07-25 15:00:38  [ main:764 ] - [ ERROR ]  warning: parse error foreach (QByteArray headerName, reply->rawHeaderList()) {
        QVariantMap header;
        header["name"] = QString::fromUtf8(headerName);
        header["value"] = QString::fromUtf8(reply->rawHeader(headerName));

        headers.append(header);
    }Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\networkmanager.cpp:69
  2021-07-25 15:00:38  [ main:766 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\networkmanager.hpp
  2021-07-25 15:00:38  [ main:767 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\networkmanagerproxy.cpp
  2021-07-25 15:00:38  [ main:775 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\networkmanagerproxy.hpp
  2021-07-25 15:00:38  [ main:776 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\networktimeout.cpp
  2021-07-25 15:00:38  [ main:780 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\networktimeout.hpp
  2021-07-25 15:00:38  [ main:781 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\page.cpp
  2021-07-25 15:00:38  [ main:792 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\page.hpp
  2021-07-25 15:00:38  [ main:793 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\timeout.cpp
  2021-07-25 15:00:38  [ main:797 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\timeout.hpp
  2021-07-25 15:00:38  [ main:798 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\webelement.cpp
  2021-07-25 15:00:38  [ main:808 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\webelement.hpp
  2021-07-25 15:00:38  [ main:809 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\webelementcollection.cpp
  2021-07-25 15:00:38  [ main:814 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\webelementcollection.hpp
  2021-07-25 15:00:38  [ main:815 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\FlexLexer.h
  2021-07-25 15:00:38  [ main:826 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\json_parser.cc
  2021-07-25 15:00:38  [ main:902 ] - [ ERROR ]  parsing error 
Q_DECLARE_METATYPE(QVector<QVariant>*)
  Q_DECLARE_METATYPE(QVariantMap*)


/* Line 33 of lalr1.cc  */
#line 72 "json_parser.hh"


#include <string>
#include <iostream>
#include "stack.hh"
#include "location.hh"

/* Enabling traces.  */
#ifndef YYDEBUG
# define YYDEBUG 1
#endif


namespace yy {
/* Line 33 of lalr1.cc  */
#line 88 "json_parser.hh"

  /// A Bison parser.
  class json_parser
  {
  public:
    /// Symbol semantic values.
#ifndef YYSTYPE
    typedef int semantic_type;
#else
    typedef YYSTYPE semantic_type;
#endif
    /// Symbol locations.
    typedef location location_type;
    /// Tokens.
    struct token
    {
      /* Tokens.  */
   enum yytokentype {
     END = 0,
     CURLY_BRACKET_OPEN = 1,
     CURLY_BRACKET_CLOSE = 2,
     SQUARE_BRACKET_OPEN = 3,
     SQUARE_BRACKET_CLOSE = 4,
     COLON = 5,
     COMMA = 6,
     NUMBER = 7,
     TRUE_VAL = 8,
     FALSE_VAL = 9,
     NULL_VAL = 10,
     STRING = 11,
     INVALID = 12
   };

    };
    /// Token type.
    typedef token::yytokentype token_type;

    /// Build a parser object.
    json_parser (QJson::ParserPrivate* driver_yyarg);
    virtual ~json_parser ();

    /// Parse.
    /// \returns  0 iff parsing succeeded.
    virtual int parse ();

#if YYDEBUG
    /// The current debugging stream.
    std::ostream& debug_stream () const;
    /// Set the current debugging stream.
    void set_debug_stream (std::ostream &);

    /// Type for debugging levels.
    typedef int debug_level_type;
    /// The current debugging level.
    debug_level_type debug_level () const;
    /// Set the current debugging level.
    void set_debug_level (debug_level_type l);
#endif

  private:
    /// Report a syntax error.
    /// \param loc    where the syntax error is found.
    /// \param msg    a description of the syntax error.
    virtual void error (const location_type& loc, const std::string& msg);

    /// Generate an error message.
    /// \param state   the state where the error occurred.
    /// \param tok     the lookahead token.
    virtual std::string yysyntax_error_ (int yystate, int tok);

#if YYDEBUG
    /// \brief Report a symbol value on the debug stream.
    /// \param yytype       The token type.
    /// \param yyvaluep     Its semantic value.
    /// \param yylocationp  Its location.
    virtual void yy_symbol_value_print_ (int yytype,
					 const semantic_type* yyvaluep,
					 const location_type* yylocationp);
    /// \brief Report a symbol on the debug stream.
    /// \param yytype       The token type.
    /// \param yyvaluep     Its semantic value.
    /// \param yylocationp  Its location.
    virtual void yy_symbol_print_ (int yytype,
				   const semantic_type* yyvaluep,
				   const location_type* yylocationp);
#endif


    /// State numbers.
    typedef int state_type;
    /// State stack type.
    typedef stack<state_type>    state_stack_type;
    /// Semantic value stack type.
    typedef stack<semantic_type> semantic_stack_type;
    /// location stack type.
    typedef stack<location_type> location_stack_type;

    /// The state stack.
    state_stack_type yystate_stack_;
    /// The semantic value stack.
    semantic_stack_type yysemantic_stack_;
    /// The location stack.
    location_stack_type yylocation_stack_;

    /// Whether the given \c yypact_ value indicates a defaulted state.
    /// \param yyvalue   the value to check
    static bool yy_pact_value_is_default_ (int yyvalue);

    /// Whether the given \c yytable_ value indicates a syntax error.
    /// \param yyvalue   the value to check
    static bool yy_table_value_is_error_ (int yyvalue);

    /// Internal symbol numbers.
    typedef unsigned char token_number_type;
    /* Tables.  */
    /// For a state, the index in \a yytable_ of its portion.
    static const signed char yypact_[];
    static const signed char yypact_ninf_;

    /// For a state, default reduction number.
    /// Unless\a  yytable_ specifies something else to do.
    /// Zero means the default is an error.
    static const unsigned char yydefact_[];

    static const signed char yypgoto_[];
    static const signed char yydefgoto_[];

    /// What to do in a state.
    /// \a yytable_[yypact_[s]]: what to do in state \a s.
    /// - if positive, shift that token.
    /// - if negative, reduce the rule which number is the opposite.
    /// - if zero, do what YYDEFACT says.
    static const unsigned char yytable_[];
    static const signed char yytable_ninf_;

    static const signed char yycheck_[];

    /// For a state, its accessing symbol.
    static const unsigned char yystos_[];

    /// For a rule, its LHS.
    static const unsigned char yyr1_[];
    /// For a rule, its RHS length.
    static const unsigned char yyr2_[]; 

    /// Convert the symbol name \a n to a form suitable for a diagnostic.
    static std::string yytnamerr_ (const char *n);


    /// For a symbol, its name in clear.
    static const char* const yytname_[];
#if YYDEBUG
    /// A type to store symbol numbers and -1.
    typedef signed char rhs_number_type;
    /// A `-1'-separated list of the rules' RHS.
    static const rhs_number_type yyrhs_[];
    /// For each rule, the index of the first RHS symbol in \a yyrhs_.
    static const unsigned char yyprhs_[];
    /// For each rule, its source line number.
    static const unsigned char yyrline_[];
    /// For each scanner token number, its symbol number.
    static const unsigned short int yytoken_number_[];
    /// Report on the debug stream that the rule \a r is going to be reduced.
    virtual void yy_reduce_print_ (int r);
    /// Print the state stack on the debug stream.
    virtual void yystack_print_ ();

    /* Debugging.  */
    int yydebug_;
    std::ostream* yycdebug_;
#endif

    /// Convert a scanner token number \a t to a symbol number.
    token_number_type yytranslate_ (int t);

    /// \brief Reclaim the memory associated to a symbol.
    /// \param yymsg        Why this token is reclaimed.
    ///                     If null, do not display the symbol, just free it.
    /// \param yytype       The symbol type.
    /// \param yyvaluep     Its semantic value.
    /// \param yylocationp  Its location.
    inline void yydestruct_ (const char* yymsg,
			     int yytype,
			     semantic_type* yyvaluep,
			     location_type* yylocationp);

    /// Pop \a n symbols the three stacks.
    inline void yypop_ (unsigned int n = 1);

    /* Constants.  */
    static const int yyeof_;
    /* LAST_ -- Last index in TABLE_.  */
    static const int yylast_;
    static const int yynnts_;
    static const int yyempty_;
    static const int yyfinal_;
    static const int yyterror_;
    static const int yyerrcode_;
    static const int yyntokens_;
    static const unsigned int yyuser_token_number_max_;
    static const token_number_type yyundef_token_;

    /* User arguments.  */
    QJson::ParserPrivate* driver;
  };

}
  2021-07-25 15:00:38  [ main:902 ] - [ ERROR ]  warning: parse error Q_DECLARE_METATYPE(QVector<QVariant>*)
  Q_DECLARE_METATYPE(QVariantMap*)


/* Line 33 of lalr1.cc  */
#line 72 "json_parser.hh"


#include <string>
#include <iostream>
#include "stack.hh"
#include "location.hh"

/* Enabling traces.  */
#ifndef YYDEBUG
# define YYDEBUG 1
#endif


namespace yy {
/* Line 33 of lalr1.cc  */
#line 88 "json_parser.hh"

  /// A Bison parser.
  class json_parser
  {
  public:
    /// Symbol semantic values.
#ifndef YYSTYPE
    typedef int semantic_type;
#else
    typedef YYSTYPE semantic_type;
#endif
    /// Symbol locations.
    typedef location location_type;
    /// Tokens.
    struct token
    {
      /* Tokens.  */
   enum yytokentype {
     END = 0,
     CURLY_BRACKET_OPEN = 1,
     CURLY_BRACKET_CLOSE = 2,
     SQUARE_BRACKET_OPEN = 3,
     SQUARE_BRACKET_CLOSE = 4,
     COLON = 5,
     COMMA = 6,
     NUMBER = 7,
     TRUE_VAL = 8,
     FALSE_VAL = 9,
     NULL_VAL = 10,
     STRING = 11,
     INVALID = 12
   };

    };
    /// Token type.
    typedef token::yytokentype token_type;

    /// Build a parser object.
    json_parser (QJson::ParserPrivate* driver_yyarg);
    virtual ~json_parser ();

    /// Parse.
    /// \returns  0 iff parsing succeeded.
    virtual int parse ();

#if YYDEBUG
    /// The current debugging stream.
    std::ostream& debug_stream () const;
    /// Set the current debugging stream.
    void set_debug_stream (std::ostream &);

    /// Type for debugging levels.
    typedef int debug_level_type;
    /// The current debugging level.
    debug_level_type debug_level () const;
    /// Set the current debugging level.
    void set_debug_level (debug_level_type l);
#endif

  private:
    /// Report a syntax error.
    /// \param loc    where the syntax error is found.
    /// \param msg    a description of the syntax error.
    virtual void error (const location_type& loc, const std::string& msg);

    /// Generate an error message.
    /// \param state   the state where the error occurred.
    /// \param tok     the lookahead token.
    virtual std::string yysyntax_error_ (int yystate, int tok);

#if YYDEBUG
    /// \brief Report a symbol value on the debug stream.
    /// \param yytype       The token type.
    /// \param yyvaluep     Its semantic value.
    /// \param yylocationp  Its location.
    virtual void yy_symbol_value_print_ (int yytype,
					 const semantic_type* yyvaluep,
					 const location_type* yylocationp);
    /// \brief Report a symbol on the debug stream.
    /// \param yytype       The token type.
    /// \param yyvaluep     Its semantic value.
    /// \param yylocationp  Its location.
    virtual void yy_symbol_print_ (int yytype,
				   const semantic_type* yyvaluep,
				   const location_type* yylocationp);
#endif


    /// State numbers.
    typedef int state_type;
    /// State stack type.
    typedef stack<state_type>    state_stack_type;
    /// Semantic value stack type.
    typedef stack<semantic_type> semantic_stack_type;
    /// location stack type.
    typedef stack<location_type> location_stack_type;

    /// The state stack.
    state_stack_type yystate_stack_;
    /// The semantic value stack.
    semantic_stack_type yysemantic_stack_;
    /// The location stack.
    location_stack_type yylocation_stack_;

    /// Whether the given \c yypact_ value indicates a defaulted state.
    /// \param yyvalue   the value to check
    static bool yy_pact_value_is_default_ (int yyvalue);

    /// Whether the given \c yytable_ value indicates a syntax error.
    /// \param yyvalue   the value to check
    static bool yy_table_value_is_error_ (int yyvalue);

    /// Internal symbol numbers.
    typedef unsigned char token_number_type;
    /* Tables.  */
    /// For a state, the index in \a yytable_ of its portion.
    static const signed char yypact_[];
    static const signed char yypact_ninf_;

    /// For a state, default reduction number.
    /// Unless\a  yytable_ specifies something else to do.
    /// Zero means the default is an error.
    static const unsigned char yydefact_[];

    static const signed char yypgoto_[];
    static const signed char yydefgoto_[];

    /// What to do in a state.
    /// \a yytable_[yypact_[s]]: what to do in state \a s.
    /// - if positive, shift that token.
    /// - if negative, reduce the rule which number is the opposite.
    /// - if zero, do what YYDEFACT says.
    static const unsigned char yytable_[];
    static const signed char yytable_ninf_;

    static const signed char yycheck_[];

    /// For a state, its accessing symbol.
    static const unsigned char yystos_[];

    /// For a rule, its LHS.
    static const unsigned char yyr1_[];
    /// For a rule, its RHS length.
    static const unsigned char yyr2_[]; 

    /// Convert the symbol name \a n to a form suitable for a diagnostic.
    static std::string yytnamerr_ (const char *n);


    /// For a symbol, its name in clear.
    static const char* const yytname_[];
#if YYDEBUG
    /// A type to store symbol numbers and -1.
    typedef signed char rhs_number_type;
    /// A `-1'-separated list of the rules' RHS.
    static const rhs_number_type yyrhs_[];
    /// For each rule, the index of the first RHS symbol in \a yyrhs_.
    static const unsigned char yyprhs_[];
    /// For each rule, its source line number.
    static const unsigned char yyrline_[];
    /// For each scanner token number, its symbol number.
    static const unsigned short int yytoken_number_[];
    /// Report on the debug stream that the rule \a r is going to be reduced.
    virtual void yy_reduce_print_ (int r);
    /// Print the state stack on the debug stream.
    virtual void yystack_print_ ();

    /* Debugging.  */
    int yydebug_;
    std::ostream* yycdebug_;
#endif

    /// Convert a scanner token number \a t to a symbol number.
    token_number_type yytranslate_ (int t);

    /// \brief Reclaim the memory associated to a symbol.
    /// \param yymsg        Why this token is reclaimed.
    ///                     If null, do not display the symbol, just free it.
    /// \param yytype       The symbol type.
    /// \param yyvaluep     Its semantic value.
    /// \param yylocationp  Its location.
    inline void yydestruct_ (const char* yymsg,
			     int yytype,
			     semantic_type* yyvaluep,
			     location_type* yylocationp);

    /// Pop \a n symbols the three stacks.
    inline void yypop_ (unsigned int n = 1);

    /* Constants.  */
    static const int yyeof_;
    /* LAST_ -- Last index in TABLE_.  */
    static const int yylast_;
    static const int yynnts_;
    static const int yyempty_;
    static const int yyfinal_;
    static const int yyterror_;
    static const int yyerrcode_;
    static const int yyntokens_;
    static const unsigned int yyuser_token_number_max_;
    static const token_number_type yyundef_token_;

    /* User arguments.  */
    QJson::ParserPrivate* driver;
  };

}Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\json_parser.hh:66
  2021-07-25 15:00:39  [ main:948 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\json_parser.hh
  2021-07-25 15:00:39  [ main:949 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\json_scanner.cc
  2021-07-25 15:00:39  [ main:1393 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\json_scanner.cpp
  2021-07-25 15:00:39  [ main:1400 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\json_scanner.h
  2021-07-25 15:00:39  [ main:1401 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\location.hh
  2021-07-25 15:00:39  [ main:1402 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\parser.cpp
  2021-07-25 15:00:39  [ main:1412 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\parser.h
  2021-07-25 15:00:39  [ main:1413 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\parserrunnable.cpp
  2021-07-25 15:00:39  [ main:1420 ] - [ ERROR ]  parsing error 
QT_BEGIN_NAMESPACE
  2021-07-25 15:00:39  [ main:1420 ] - [ ERROR ]  warning: parse error QT_BEGIN_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\parserrunnable.h:29
  2021-07-25 15:00:39  [ main:1420 ] - [ ERROR ]  parsing error 
QT_END_NAMESPACE
  2021-07-25 15:00:39  [ main:1420 ] - [ ERROR ]  warning: parse error QT_END_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\parserrunnable.h:31
  2021-07-25 15:00:39  [ main:1420 ] - [ ERROR ]  parsing error 
class QJSON_EXPORT ParserRunnable  : public QObject, public QRunnable
  {
    Q_OBJECT
    public:
      explicit ParserRunnable(QObject* parent = 0);
      ~ParserRunnable();

      void setData( const QByteArray& data );

      void run();

    Q_SIGNALS:
      /**
      * This signal is emitted when the parsing process has been completed
      * @param json contains the result of the parsing
      * @param ok if a parsing error occurs ok is set to false, otherwise it's set to true.
      * @param error_msg contains a string explaining the failure reason
      **/
      void parsingFinished(const QVariant& json, bool ok, const QString& error_msg);

    private:
      Q_DISABLE_COPY(ParserRunnable)
      class Private;
      Private* const d;
  };
  2021-07-25 15:00:39  [ main:1421 ] - [ ERROR ]  warning: parse error class QJSON_EXPORT ParserRunnable  : public QObject, public QRunnable
  {
    Q_OBJECT
    public:
      explicit ParserRunnable(QObject* parent = 0);
      ~ParserRunnable();

      void setData( const QByteArray& data );

      void run();

    Q_SIGNALS:
      /**
      * This signal is emitted when the parsing process has been completed
      * @param json contains the result of the parsing
      * @param ok if a parsing error occurs ok is set to false, otherwise it's set to true.
      * @param error_msg contains a string explaining the failure reason
      **/
      void parsingFinished(const QVariant& json, bool ok, const QString& error_msg);

    private:
      Q_DISABLE_COPY(ParserRunnable)
      class Private;
      Private* const d;
  };Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\parserrunnable.h:37
  2021-07-25 15:00:39  [ main:1424 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\parserrunnable.h
  2021-07-25 15:00:39  [ main:1425 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\parser_p.h
  2021-07-25 15:00:39  [ main:1426 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\position.hh
  2021-07-25 15:00:39  [ main:1435 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\qjson_debug.h
  2021-07-25 15:00:39  [ main:1436 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\qjson_export.h
  2021-07-25 15:00:39  [ main:1436 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\qobjecthelper.cpp
  2021-07-25 15:00:39  [ main:1443 ] - [ ERROR ]  parsing error 
QT_BEGIN_NAMESPACE
  2021-07-25 15:00:39  [ main:1444 ] - [ ERROR ]  warning: parse error QT_BEGIN_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\qobjecthelper.h:30
  2021-07-25 15:00:39  [ main:1444 ] - [ ERROR ]  parsing error 
QT_END_NAMESPACE
  2021-07-25 15:00:39  [ main:1444 ] - [ ERROR ]  warning: parse error QT_END_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\qobjecthelper.h:32
  2021-07-25 15:00:39  [ main:1444 ] - [ ERROR ]  parsing error 
class QJSON_EXPORT QObjectHelper {
    public:
      QObjectHelper();
      ~QObjectHelper();

    /**
    * This method converts a QObject instance into a QVariantMap.
    *
    * @param object The QObject instance to be converted.
    * @param ignoredProperties Properties that won't be converted.
    */
    static QVariantMap qobject2qvariant( const QObject* object,
                                  const QStringList& ignoredProperties = QStringList(QString(QLatin1String("objectName"))));

    /**
    * This method converts a QVariantMap instance into a QObject
    *
    * @param variant Attributes to assign to the object.
    * @param object The QObject instance to update.
    */
    static void qvariant2qobject(const QVariantMap& variant, QObject* object);

    private:
      Q_DISABLE_COPY(QObjectHelper)
      class QObjectHelperPrivate;
      QObjectHelperPrivate* const d;
  };
  2021-07-25 15:00:39  [ main:1444 ] - [ ERROR ]  warning: parse error class QJSON_EXPORT QObjectHelper {
    public:
      QObjectHelper();
      ~QObjectHelper();

    /**
    * This method converts a QObject instance into a QVariantMap.
    *
    * @param object The QObject instance to be converted.
    * @param ignoredProperties Properties that won't be converted.
    */
    static QVariantMap qobject2qvariant( const QObject* object,
                                  const QStringList& ignoredProperties = QStringList(QString(QLatin1String("objectName"))));

    /**
    * This method converts a QVariantMap instance into a QObject
    *
    * @param variant Attributes to assign to the object.
    * @param object The QObject instance to update.
    */
    static void qvariant2qobject(const QVariantMap& variant, QObject* object);

    private:
      Q_DISABLE_COPY(QObjectHelper)
      class QObjectHelperPrivate;
      QObjectHelperPrivate* const d;
  };Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\qobjecthelper.h:118
  2021-07-25 15:00:39  [ main:1449 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\qobjecthelper.h
  2021-07-25 15:00:39  [ main:1450 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\serializer.cpp
  2021-07-25 15:00:39  [ main:1467 ] - [ ERROR ]  warning: parse error Q_FOREACH( const QByteArray& i, list ) {
    if ( !res.isEmpty() )
      res += sep;
    res += i;
  }Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializer.cpp:55
  2021-07-25 15:00:39  [ main:1467 ] - [ ERROR ]  warning: parse error Q_FOREACH( const QVariant& var, list )
    {
      indentLevel++;
      QByteArray serializedValue = serialize( var, ok, indentLevel);
      indentLevel--;
      if ( !*ok ) {
        break;
      }
      values << serializedValue;
    }Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializer.cpp:72
  2021-07-25 15:00:39  [ main:1479 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\serializer.h
  2021-07-25 15:00:39  [ main:1480 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\serializerrunnable.cpp
  2021-07-25 15:00:39  [ main:1486 ] - [ ERROR ]  parsing error 
QT_BEGIN_NAMESPACE
  2021-07-25 15:00:39  [ main:1486 ] - [ ERROR ]  warning: parse error QT_BEGIN_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializerrunnable.h:29
  2021-07-25 15:00:39  [ main:1486 ] - [ ERROR ]  parsing error 
QT_END_NAMESPACE
  2021-07-25 15:00:39  [ main:1486 ] - [ ERROR ]  warning: parse error QT_END_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializerrunnable.h:33
  2021-07-25 15:00:39  [ main:1487 ] - [ ERROR ]  parsing error 
class QJSON_EXPORT SerializerRunnable  : public QObject, public QRunnable
  {
    Q_OBJECT
    public:
      explicit SerializerRunnable(QObject* parent = 0);
      ~SerializerRunnable();

      /**
       * Sets the json object to serialize.
       *
       * @param json QVariant containing the json representation to be serialized
       */
      void setJsonObject( const QVariant& json );

      /* reimp */ void run();

    Q_SIGNALS:
      /**
      * This signal is emitted when the serialization process has been completed
      * @param serialized contains the result of the serialization
      * @param ok if a serialization error occurs ok is set to false, otherwise it's set to true.
      * @param error_msg contains a string explaining the failure reason
      **/
      void parsingFinished(const QByteArray& serialized, bool ok, const QString& error_msg);

    private:
      Q_DISABLE_COPY(SerializerRunnable)
      class Private;
      Private* const d;
  };
  2021-07-25 15:00:39  [ main:1487 ] - [ ERROR ]  warning: parse error class QJSON_EXPORT SerializerRunnable  : public QObject, public QRunnable
  {
    Q_OBJECT
    public:
      explicit SerializerRunnable(QObject* parent = 0);
      ~SerializerRunnable();

      /**
       * Sets the json object to serialize.
       *
       * @param json QVariant containing the json representation to be serialized
       */
      void setJsonObject( const QVariant& json );

      /* reimp */ void run();

    Q_SIGNALS:
      /**
      * This signal is emitted when the serialization process has been completed
      * @param serialized contains the result of the serialization
      * @param ok if a serialization error occurs ok is set to false, otherwise it's set to true.
      * @param error_msg contains a string explaining the failure reason
      **/
      void parsingFinished(const QByteArray& serialized, bool ok, const QString& error_msg);

    private:
      Q_DISABLE_COPY(SerializerRunnable)
      class Private;
      Private* const d;
  };Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializerrunnable.h:39
  2021-07-25 15:00:39  [ main:1490 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\serializerrunnable.h
  2021-07-25 15:00:39  [ main:1491 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\stack.hh
  2021-07-25 15:00:39  [ main:1493 ] - [ INFO ]  start dependency
  2021-07-25 15:00:39  [ main:1583 ] - [ INFO ]  includenum:73
  2021-07-25 15:00:39  [ main:1583 ] - [ INFO ]  definenum:81
  2021-07-25 15:00:39  [ main:1583 ] - [ INFO ]  callnum:45
  2021-07-25 15:00:39  [ main:1583 ] - [ INFO ]  returnnum:159
  2021-07-25 15:00:39  [ main:1583 ] - [ INFO ]  parameternum:614
  2021-07-25 15:00:39  [ main:1583 ] - [ INFO ]  extendnum:1
  2021-07-25 15:00:39  [ main:1583 ] - [ INFO ]  overridenum:1
  2021-07-25 15:03:05  [ main:0 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\phantompy.cpp
  2021-07-25 15:03:05  [ main:447 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 15:03:05  [ main:496 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\frame.hpp:11
  2021-07-25 15:03:05  [ main:499 ] - [ ERROR ]  parsing error 
private slots:
    void loadFinished(bool ok);
  2021-07-25 15:03:05  [ main:499 ] - [ ERROR ]  warning: parse error private slots:
    void loadFinished(bool ok);Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\frame.hpp:38
  2021-07-25 15:03:06  [ main:502 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 15:03:06  [ main:502 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\image.hpp:9
  2021-07-25 15:03:06  [ main:520 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 15:03:06  [ main:520 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\timeout.hpp:9
  2021-07-25 15:03:06  [ main:520 ] - [ ERROR ]  parsing error 
private slots:
    void handleTimeout();
  2021-07-25 15:03:06  [ main:520 ] - [ ERROR ]  warning: parse error private slots:
    void handleTimeout();Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\timeout.hpp:22
  2021-07-25 15:03:06  [ main:530 ] - [ ERROR ]  parsing error 
QT_BEGIN_NAMESPACE
  2021-07-25 15:03:06  [ main:530 ] - [ ERROR ]  warning: parse error QT_BEGIN_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\parser.h:26
  2021-07-25 15:03:06  [ main:530 ] - [ ERROR ]  parsing error 
QT_END_NAMESPACE
  2021-07-25 15:03:06  [ main:530 ] - [ ERROR ]  warning: parse error QT_END_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\parser.h:29
  2021-07-25 15:03:06  [ main:531 ] - [ ERROR ]  parsing error 
class QJSON_EXPORT Parser
  {
    public:
      Parser();
      ~Parser();

      /**
      * Read JSON string from the I/O Device and converts it to a QVariant object
      * @param io Input output device
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true.
      * @returns a QVariant object generated from the JSON string
      */
      QVariant parse(QIODevice* io, bool* ok = 0);

      /**
      * This is a method provided for convenience.
      * @param jsonData data containing the JSON object representation
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true.
      * @returns a QVariant object generated from the JSON string
      * @sa errorString
      * @sa errorLine
      */
      QVariant parse(const QByteArray& jsonData, bool* ok = 0);

      /**
      * This method returns the error message
      * @returns a QString object containing the error message of the last parse operation
      * @sa errorLine
      */
      QString errorString() const;

      /**
      * This method returns line number where the error occurred
      * @returns the line number where the error occurred
      * @sa errorString
      */
      int errorLine() const;

      /**
       * Sets whether special numbers (Infinity, -Infinity, NaN) are allowed as an extension to
       * the standard
       * @param  allowSpecialNumbers new value of whether special numbers are allowed
       * @sa specialNumbersAllowed
       */
      void allowSpecialNumbers(bool allowSpecialNumbers);

      /**
       * @returns whether special numbers (Infinity, -Infinity, NaN) are allowed
       * @sa allowSpecialNumbers
       */
      bool specialNumbersAllowed() const;

    private:
      Q_DISABLE_COPY(Parser)
      ParserPrivate* const d;
  };
  2021-07-25 15:03:06  [ main:531 ] - [ ERROR ]  warning: parse error class QJSON_EXPORT Parser
  {
    public:
      Parser();
      ~Parser();

      /**
      * Read JSON string from the I/O Device and converts it to a QVariant object
      * @param io Input output device
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true.
      * @returns a QVariant object generated from the JSON string
      */
      QVariant parse(QIODevice* io, bool* ok = 0);

      /**
      * This is a method provided for convenience.
      * @param jsonData data containing the JSON object representation
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true.
      * @returns a QVariant object generated from the JSON string
      * @sa errorString
      * @sa errorLine
      */
      QVariant parse(const QByteArray& jsonData, bool* ok = 0);

      /**
      * This method returns the error message
      * @returns a QString object containing the error message of the last parse operation
      * @sa errorLine
      */
      QString errorString() const;

      /**
      * This method returns line number where the error occurred
      * @returns the line number where the error occurred
      * @sa errorString
      */
      int errorLine() const;

      /**
       * Sets whether special numbers (Infinity, -Infinity, NaN) are allowed as an extension to
       * the standard
       * @param  allowSpecialNumbers new value of whether special numbers are allowed
       * @sa specialNumbersAllowed
       */
      void allowSpecialNumbers(bool allowSpecialNumbers);

      /**
       * @returns whether special numbers (Infinity, -Infinity, NaN) are allowed
       * @sa allowSpecialNumbers
       */
      bool specialNumbersAllowed() const;

    private:
      Q_DISABLE_COPY(Parser)
      ParserPrivate* const d;
  };Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\parser.h:41
  2021-07-25 15:03:06  [ main:548 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 15:03:06  [ main:548 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\networkmanager.hpp:11
  2021-07-25 15:03:06  [ main:549 ] - [ ERROR ]  parsing error 
signals:
    void replyReceived(const QVariantMap &reply);
  2021-07-25 15:03:06  [ main:549 ] - [ ERROR ]  warning: parse error signals:
    void replyReceived(const QVariantMap &reply);Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\networkmanager.hpp:29
  2021-07-25 15:03:06  [ main:549 ] - [ ERROR ]  parsing error 
private slots:
    void provideAuthentication(QNetworkReply *reply, QAuthenticator *authenticator);
  2021-07-25 15:03:06  [ main:549 ] - [ ERROR ]  warning: parse error private slots:
    void provideAuthentication(QNetworkReply *reply, QAuthenticator *authenticator);Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\networkmanager.hpp:35
  2021-07-25 15:03:06  [ main:553 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 15:03:06  [ main:553 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\networkmanagerproxy.hpp:10
  2021-07-25 15:03:06  [ main:554 ] - [ ERROR ]  parsing error 
private slots:
    void finished();
  2021-07-25 15:03:06  [ main:554 ] - [ ERROR ]  warning: parse error private slots:
    void finished();Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\networkmanagerproxy.hpp:25
  2021-07-25 15:03:06  [ main:558 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 15:03:06  [ main:558 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\page.hpp:19
  2021-07-25 15:03:06  [ main:559 ] - [ ERROR ]  parsing error 
private slots:
    void loadFinished(bool ok);
  2021-07-25 15:03:06  [ main:559 ] - [ ERROR ]  warning: parse error private slots:
    void loadFinished(bool ok);Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\page.hpp:57
  2021-07-25 15:03:06  [ main:562 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 15:03:06  [ main:562 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\eventprocessor.hpp:9
  2021-07-25 15:03:06  [ main:563 ] - [ ERROR ]  parsing error 
private slots:
    void handleTimeout();
  2021-07-25 15:03:06  [ main:563 ] - [ ERROR ]  warning: parse error private slots:
    void handleTimeout();Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\eventprocessor.hpp:23
  2021-07-25 15:03:06  [ main:567 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 15:03:06  [ main:567 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\webelement.hpp:11
  2021-07-25 15:03:06  [ main:568 ] - [ ERROR ]  parsing error 
private slots:
    void loadFinished(bool ok);
  2021-07-25 15:03:06  [ main:569 ] - [ ERROR ]  warning: parse error private slots:
    void loadFinished(bool ok);Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\webelement.hpp:69
  2021-07-25 15:03:06  [ main:573 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 15:03:06  [ main:573 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\webelementcollection.hpp:11
  2021-07-25 15:03:06  [ main:590 ] - [ ERROR ]  parsing error 
QT_BEGIN_NAMESPACE
  2021-07-25 15:03:06  [ main:591 ] - [ ERROR ]  warning: parse error QT_BEGIN_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializer.h:26
  2021-07-25 15:03:06  [ main:591 ] - [ ERROR ]  parsing error 
QT_END_NAMESPACE
  2021-07-25 15:03:06  [ main:591 ] - [ ERROR ]  warning: parse error QT_END_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializer.h:30
  2021-07-25 15:03:06  [ main:591 ] - [ ERROR ]  parsing error 
class QJSON_EXPORT Serializer {
  public:
    Serializer();
    ~Serializer();

     /**
      * This method generates a textual JSON representation and outputs it to the
      * passed in I/O Device.
      * @param variant The JSON document in its in-memory representation as generated by the
      * parser.
      * @param out Input output device
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true
      */
    void serialize( const QVariant& variant, QIODevice* out, bool* ok);

    /**
      * This is a method provided for convenience. It turns the passed in in-memory
      * representation of the JSON document into a textual one, which is returned.
      * If the returned string is empty, the document was empty. If it was null, there
      * was a parsing error.
      *
      * @param variant The JSON document in its in-memory representation as generated by the
      * parser.
      *
      * \deprecated This method is going to be removed with the next major release of QJson.
      */
    QByteArray serialize( const QVariant& variant);

    /**
      * This is a method provided for convenience. It turns the passed in in-memory
      * representation of the JSON document into a textual one, which is returned.
      * If the returned string is empty, the document was empty. If it was null, there
      * was a parsing error.
      *
      * @param variant The JSON document in its in-memory representation as generated by the
      * parser.
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true
      */
    QByteArray serialize( const QVariant& variant, bool *ok);

    /**
     * Allow or disallow writing of NaN and/or Infinity (as an extension to QJson)
     */
    void allowSpecialNumbers(bool allow);

    /**
     * Is Nan and/or Infinity allowed?
     */
    bool specialNumbersAllowed() const;

    /**
     * set output indentation mode as defined in QJson::IndentMode
     */
    void setIndentMode(IndentMode mode = QJson::IndentNone);


    /**
    * set double precision used while converting Double
    * \sa QByteArray::number
    */
    void setDoublePrecision(int precision);

    /**
     * Returns one of the indentation modes defined in QJson::IndentMode
     */
    IndentMode indentMode() const;

    /**
     * Returns the error message
     */
    QString errorMessage() const;

  private:
    Q_DISABLE_COPY(Serializer)
    class SerializerPrivate;
    SerializerPrivate* const d;
  };
  2021-07-25 15:03:06  [ main:591 ] - [ ERROR ]  warning: parse error class QJSON_EXPORT Serializer {
  public:
    Serializer();
    ~Serializer();

     /**
      * This method generates a textual JSON representation and outputs it to the
      * passed in I/O Device.
      * @param variant The JSON document in its in-memory representation as generated by the
      * parser.
      * @param out Input output device
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true
      */
    void serialize( const QVariant& variant, QIODevice* out, bool* ok);

    /**
      * This is a method provided for convenience. It turns the passed in in-memory
      * representation of the JSON document into a textual one, which is returned.
      * If the returned string is empty, the document was empty. If it was null, there
      * was a parsing error.
      *
      * @param variant The JSON document in its in-memory representation as generated by the
      * parser.
      *
      * \deprecated This method is going to be removed with the next major release of QJson.
      */
    QByteArray serialize( const QVariant& variant);

    /**
      * This is a method provided for convenience. It turns the passed in in-memory
      * representation of the JSON document into a textual one, which is returned.
      * If the returned string is empty, the document was empty. If it was null, there
      * was a parsing error.
      *
      * @param variant The JSON document in its in-memory representation as generated by the
      * parser.
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true
      */
    QByteArray serialize( const QVariant& variant, bool *ok);

    /**
     * Allow or disallow writing of NaN and/or Infinity (as an extension to QJson)
     */
    void allowSpecialNumbers(bool allow);

    /**
     * Is Nan and/or Infinity allowed?
     */
    bool specialNumbersAllowed() const;

    /**
     * set output indentation mode as defined in QJson::IndentMode
     */
    void setIndentMode(IndentMode mode = QJson::IndentNone);


    /**
    * set double precision used while converting Double
    * \sa QByteArray::number
    */
    void setDoublePrecision(int precision);

    /**
     * Returns one of the indentation modes defined in QJson::IndentMode
     */
    IndentMode indentMode() const;

    /**
     * Returns the error message
     */
    QString errorMessage() const;

  private:
    Q_DISABLE_COPY(Serializer)
    class SerializerPrivate;
    SerializerPrivate* const d;
  };Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializer.h:112
  2021-07-25 15:03:06  [ main:595 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 15:03:06  [ main:595 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\cookiejar.hpp:14
  2021-07-25 15:03:06  [ main:657 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\phantompy.hpp
  2021-07-25 15:03:06  [ main:658 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\context.cpp
  2021-07-25 15:03:06  [ main:681 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\context.hpp
  2021-07-25 15:03:06  [ main:682 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\cookiejar.cpp
  2021-07-25 15:03:06  [ main:703 ] - [ ERROR ]  warning: parse error foreach(QNetworkCookie n_cookie, cookiesForUrl(QUrl(url))) {
        cookie["name"] = QString::fromUtf8(n_cookie.name());
        cookie["value"] = QString::fromUtf8(n_cookie.value());
        cookie["domain"] = n_cookie.domain();
        cookie["path"] = n_cookie.path();
        cookie["expires"] = n_cookie.expirationDate().toString(Qt::ISODate);

        cookiesList.append(cookie);
    }Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\cookiejar.cpp:112
  2021-07-25 15:03:06  [ main:703 ] - [ ERROR ]  warning: parse error foreach(QNetworkCookie n_cookie, allCookies()) {
        cookie["name"] = QString::fromUtf8(n_cookie.name());
        cookie["value"] = QString::fromUtf8(n_cookie.value());
        cookie["domain"] = n_cookie.domain();
        cookie["path"] = n_cookie.path();
        cookie["expires"] = n_cookie.expirationDate().toString(Qt::ISODate);

        cookiesList.append(cookie);
    }Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\cookiejar.cpp:129
  2021-07-25 15:03:06  [ main:704 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\cookiejar.hpp
  2021-07-25 15:03:06  [ main:705 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\eventprocessor.cpp
  2021-07-25 15:03:06  [ main:712 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\eventprocessor.hpp
  2021-07-25 15:03:06  [ main:713 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\frame.cpp
  2021-07-25 15:03:06  [ main:741 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\frame.hpp
  2021-07-25 15:03:06  [ main:741 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\image.cpp
  2021-07-25 15:03:06  [ main:747 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\image.hpp
  2021-07-25 15:03:06  [ main:747 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\networkmanager.cpp
  2021-07-25 15:03:06  [ main:755 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 15:03:06  [ main:755 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\networktimeout.hpp:10
  2021-07-25 15:03:06  [ main:761 ] - [ ERROR ]  warning: parse error foreach (QByteArray headerName, reply->rawHeaderList()) {
        QVariantMap header;
        header["name"] = QString::fromUtf8(headerName);
        header["value"] = QString::fromUtf8(reply->rawHeader(headerName));

        headers.append(header);
    }Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\networkmanager.cpp:69
  2021-07-25 15:03:06  [ main:763 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\networkmanager.hpp
  2021-07-25 15:03:06  [ main:764 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\networkmanagerproxy.cpp
  2021-07-25 15:03:06  [ main:772 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\networkmanagerproxy.hpp
  2021-07-25 15:03:06  [ main:773 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\networktimeout.cpp
  2021-07-25 15:03:06  [ main:777 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\networktimeout.hpp
  2021-07-25 15:03:06  [ main:778 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\page.cpp
  2021-07-25 15:03:06  [ main:789 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\page.hpp
  2021-07-25 15:03:06  [ main:790 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\timeout.cpp
  2021-07-25 15:03:06  [ main:795 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\timeout.hpp
  2021-07-25 15:03:06  [ main:796 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\webelement.cpp
  2021-07-25 15:03:06  [ main:807 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\webelement.hpp
  2021-07-25 15:03:06  [ main:808 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\webelementcollection.cpp
  2021-07-25 15:03:06  [ main:813 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\webelementcollection.hpp
  2021-07-25 15:03:06  [ main:814 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\FlexLexer.h
  2021-07-25 15:03:06  [ main:825 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\json_parser.cc
  2021-07-25 15:03:06  [ main:900 ] - [ ERROR ]  parsing error 
Q_DECLARE_METATYPE(QVector<QVariant>*)
  Q_DECLARE_METATYPE(QVariantMap*)


/* Line 33 of lalr1.cc  */
#line 72 "json_parser.hh"


#include <string>
#include <iostream>
#include "stack.hh"
#include "location.hh"

/* Enabling traces.  */
#ifndef YYDEBUG
# define YYDEBUG 1
#endif


namespace yy {
/* Line 33 of lalr1.cc  */
#line 88 "json_parser.hh"

  /// A Bison parser.
  class json_parser
  {
  public:
    /// Symbol semantic values.
#ifndef YYSTYPE
    typedef int semantic_type;
#else
    typedef YYSTYPE semantic_type;
#endif
    /// Symbol locations.
    typedef location location_type;
    /// Tokens.
    struct token
    {
      /* Tokens.  */
   enum yytokentype {
     END = 0,
     CURLY_BRACKET_OPEN = 1,
     CURLY_BRACKET_CLOSE = 2,
     SQUARE_BRACKET_OPEN = 3,
     SQUARE_BRACKET_CLOSE = 4,
     COLON = 5,
     COMMA = 6,
     NUMBER = 7,
     TRUE_VAL = 8,
     FALSE_VAL = 9,
     NULL_VAL = 10,
     STRING = 11,
     INVALID = 12
   };

    };
    /// Token type.
    typedef token::yytokentype token_type;

    /// Build a parser object.
    json_parser (QJson::ParserPrivate* driver_yyarg);
    virtual ~json_parser ();

    /// Parse.
    /// \returns  0 iff parsing succeeded.
    virtual int parse ();

#if YYDEBUG
    /// The current debugging stream.
    std::ostream& debug_stream () const;
    /// Set the current debugging stream.
    void set_debug_stream (std::ostream &);

    /// Type for debugging levels.
    typedef int debug_level_type;
    /// The current debugging level.
    debug_level_type debug_level () const;
    /// Set the current debugging level.
    void set_debug_level (debug_level_type l);
#endif

  private:
    /// Report a syntax error.
    /// \param loc    where the syntax error is found.
    /// \param msg    a description of the syntax error.
    virtual void error (const location_type& loc, const std::string& msg);

    /// Generate an error message.
    /// \param state   the state where the error occurred.
    /// \param tok     the lookahead token.
    virtual std::string yysyntax_error_ (int yystate, int tok);

#if YYDEBUG
    /// \brief Report a symbol value on the debug stream.
    /// \param yytype       The token type.
    /// \param yyvaluep     Its semantic value.
    /// \param yylocationp  Its location.
    virtual void yy_symbol_value_print_ (int yytype,
					 const semantic_type* yyvaluep,
					 const location_type* yylocationp);
    /// \brief Report a symbol on the debug stream.
    /// \param yytype       The token type.
    /// \param yyvaluep     Its semantic value.
    /// \param yylocationp  Its location.
    virtual void yy_symbol_print_ (int yytype,
				   const semantic_type* yyvaluep,
				   const location_type* yylocationp);
#endif


    /// State numbers.
    typedef int state_type;
    /// State stack type.
    typedef stack<state_type>    state_stack_type;
    /// Semantic value stack type.
    typedef stack<semantic_type> semantic_stack_type;
    /// location stack type.
    typedef stack<location_type> location_stack_type;

    /// The state stack.
    state_stack_type yystate_stack_;
    /// The semantic value stack.
    semantic_stack_type yysemantic_stack_;
    /// The location stack.
    location_stack_type yylocation_stack_;

    /// Whether the given \c yypact_ value indicates a defaulted state.
    /// \param yyvalue   the value to check
    static bool yy_pact_value_is_default_ (int yyvalue);

    /// Whether the given \c yytable_ value indicates a syntax error.
    /// \param yyvalue   the value to check
    static bool yy_table_value_is_error_ (int yyvalue);

    /// Internal symbol numbers.
    typedef unsigned char token_number_type;
    /* Tables.  */
    /// For a state, the index in \a yytable_ of its portion.
    static const signed char yypact_[];
    static const signed char yypact_ninf_;

    /// For a state, default reduction number.
    /// Unless\a  yytable_ specifies something else to do.
    /// Zero means the default is an error.
    static const unsigned char yydefact_[];

    static const signed char yypgoto_[];
    static const signed char yydefgoto_[];

    /// What to do in a state.
    /// \a yytable_[yypact_[s]]: what to do in state \a s.
    /// - if positive, shift that token.
    /// - if negative, reduce the rule which number is the opposite.
    /// - if zero, do what YYDEFACT says.
    static const unsigned char yytable_[];
    static const signed char yytable_ninf_;

    static const signed char yycheck_[];

    /// For a state, its accessing symbol.
    static const unsigned char yystos_[];

    /// For a rule, its LHS.
    static const unsigned char yyr1_[];
    /// For a rule, its RHS length.
    static const unsigned char yyr2_[]; 

    /// Convert the symbol name \a n to a form suitable for a diagnostic.
    static std::string yytnamerr_ (const char *n);


    /// For a symbol, its name in clear.
    static const char* const yytname_[];
#if YYDEBUG
    /// A type to store symbol numbers and -1.
    typedef signed char rhs_number_type;
    /// A `-1'-separated list of the rules' RHS.
    static const rhs_number_type yyrhs_[];
    /// For each rule, the index of the first RHS symbol in \a yyrhs_.
    static const unsigned char yyprhs_[];
    /// For each rule, its source line number.
    static const unsigned char yyrline_[];
    /// For each scanner token number, its symbol number.
    static const unsigned short int yytoken_number_[];
    /// Report on the debug stream that the rule \a r is going to be reduced.
    virtual void yy_reduce_print_ (int r);
    /// Print the state stack on the debug stream.
    virtual void yystack_print_ ();

    /* Debugging.  */
    int yydebug_;
    std::ostream* yycdebug_;
#endif

    /// Convert a scanner token number \a t to a symbol number.
    token_number_type yytranslate_ (int t);

    /// \brief Reclaim the memory associated to a symbol.
    /// \param yymsg        Why this token is reclaimed.
    ///                     If null, do not display the symbol, just free it.
    /// \param yytype       The symbol type.
    /// \param yyvaluep     Its semantic value.
    /// \param yylocationp  Its location.
    inline void yydestruct_ (const char* yymsg,
			     int yytype,
			     semantic_type* yyvaluep,
			     location_type* yylocationp);

    /// Pop \a n symbols the three stacks.
    inline void yypop_ (unsigned int n = 1);

    /* Constants.  */
    static const int yyeof_;
    /* LAST_ -- Last index in TABLE_.  */
    static const int yylast_;
    static const int yynnts_;
    static const int yyempty_;
    static const int yyfinal_;
    static const int yyterror_;
    static const int yyerrcode_;
    static const int yyntokens_;
    static const unsigned int yyuser_token_number_max_;
    static const token_number_type yyundef_token_;

    /* User arguments.  */
    QJson::ParserPrivate* driver;
  };

}
  2021-07-25 15:03:06  [ main:901 ] - [ ERROR ]  warning: parse error Q_DECLARE_METATYPE(QVector<QVariant>*)
  Q_DECLARE_METATYPE(QVariantMap*)


/* Line 33 of lalr1.cc  */
#line 72 "json_parser.hh"


#include <string>
#include <iostream>
#include "stack.hh"
#include "location.hh"

/* Enabling traces.  */
#ifndef YYDEBUG
# define YYDEBUG 1
#endif


namespace yy {
/* Line 33 of lalr1.cc  */
#line 88 "json_parser.hh"

  /// A Bison parser.
  class json_parser
  {
  public:
    /// Symbol semantic values.
#ifndef YYSTYPE
    typedef int semantic_type;
#else
    typedef YYSTYPE semantic_type;
#endif
    /// Symbol locations.
    typedef location location_type;
    /// Tokens.
    struct token
    {
      /* Tokens.  */
   enum yytokentype {
     END = 0,
     CURLY_BRACKET_OPEN = 1,
     CURLY_BRACKET_CLOSE = 2,
     SQUARE_BRACKET_OPEN = 3,
     SQUARE_BRACKET_CLOSE = 4,
     COLON = 5,
     COMMA = 6,
     NUMBER = 7,
     TRUE_VAL = 8,
     FALSE_VAL = 9,
     NULL_VAL = 10,
     STRING = 11,
     INVALID = 12
   };

    };
    /// Token type.
    typedef token::yytokentype token_type;

    /// Build a parser object.
    json_parser (QJson::ParserPrivate* driver_yyarg);
    virtual ~json_parser ();

    /// Parse.
    /// \returns  0 iff parsing succeeded.
    virtual int parse ();

#if YYDEBUG
    /// The current debugging stream.
    std::ostream& debug_stream () const;
    /// Set the current debugging stream.
    void set_debug_stream (std::ostream &);

    /// Type for debugging levels.
    typedef int debug_level_type;
    /// The current debugging level.
    debug_level_type debug_level () const;
    /// Set the current debugging level.
    void set_debug_level (debug_level_type l);
#endif

  private:
    /// Report a syntax error.
    /// \param loc    where the syntax error is found.
    /// \param msg    a description of the syntax error.
    virtual void error (const location_type& loc, const std::string& msg);

    /// Generate an error message.
    /// \param state   the state where the error occurred.
    /// \param tok     the lookahead token.
    virtual std::string yysyntax_error_ (int yystate, int tok);

#if YYDEBUG
    /// \brief Report a symbol value on the debug stream.
    /// \param yytype       The token type.
    /// \param yyvaluep     Its semantic value.
    /// \param yylocationp  Its location.
    virtual void yy_symbol_value_print_ (int yytype,
					 const semantic_type* yyvaluep,
					 const location_type* yylocationp);
    /// \brief Report a symbol on the debug stream.
    /// \param yytype       The token type.
    /// \param yyvaluep     Its semantic value.
    /// \param yylocationp  Its location.
    virtual void yy_symbol_print_ (int yytype,
				   const semantic_type* yyvaluep,
				   const location_type* yylocationp);
#endif


    /// State numbers.
    typedef int state_type;
    /// State stack type.
    typedef stack<state_type>    state_stack_type;
    /// Semantic value stack type.
    typedef stack<semantic_type> semantic_stack_type;
    /// location stack type.
    typedef stack<location_type> location_stack_type;

    /// The state stack.
    state_stack_type yystate_stack_;
    /// The semantic value stack.
    semantic_stack_type yysemantic_stack_;
    /// The location stack.
    location_stack_type yylocation_stack_;

    /// Whether the given \c yypact_ value indicates a defaulted state.
    /// \param yyvalue   the value to check
    static bool yy_pact_value_is_default_ (int yyvalue);

    /// Whether the given \c yytable_ value indicates a syntax error.
    /// \param yyvalue   the value to check
    static bool yy_table_value_is_error_ (int yyvalue);

    /// Internal symbol numbers.
    typedef unsigned char token_number_type;
    /* Tables.  */
    /// For a state, the index in \a yytable_ of its portion.
    static const signed char yypact_[];
    static const signed char yypact_ninf_;

    /// For a state, default reduction number.
    /// Unless\a  yytable_ specifies something else to do.
    /// Zero means the default is an error.
    static const unsigned char yydefact_[];

    static const signed char yypgoto_[];
    static const signed char yydefgoto_[];

    /// What to do in a state.
    /// \a yytable_[yypact_[s]]: what to do in state \a s.
    /// - if positive, shift that token.
    /// - if negative, reduce the rule which number is the opposite.
    /// - if zero, do what YYDEFACT says.
    static const unsigned char yytable_[];
    static const signed char yytable_ninf_;

    static const signed char yycheck_[];

    /// For a state, its accessing symbol.
    static const unsigned char yystos_[];

    /// For a rule, its LHS.
    static const unsigned char yyr1_[];
    /// For a rule, its RHS length.
    static const unsigned char yyr2_[]; 

    /// Convert the symbol name \a n to a form suitable for a diagnostic.
    static std::string yytnamerr_ (const char *n);


    /// For a symbol, its name in clear.
    static const char* const yytname_[];
#if YYDEBUG
    /// A type to store symbol numbers and -1.
    typedef signed char rhs_number_type;
    /// A `-1'-separated list of the rules' RHS.
    static const rhs_number_type yyrhs_[];
    /// For each rule, the index of the first RHS symbol in \a yyrhs_.
    static const unsigned char yyprhs_[];
    /// For each rule, its source line number.
    static const unsigned char yyrline_[];
    /// For each scanner token number, its symbol number.
    static const unsigned short int yytoken_number_[];
    /// Report on the debug stream that the rule \a r is going to be reduced.
    virtual void yy_reduce_print_ (int r);
    /// Print the state stack on the debug stream.
    virtual void yystack_print_ ();

    /* Debugging.  */
    int yydebug_;
    std::ostream* yycdebug_;
#endif

    /// Convert a scanner token number \a t to a symbol number.
    token_number_type yytranslate_ (int t);

    /// \brief Reclaim the memory associated to a symbol.
    /// \param yymsg        Why this token is reclaimed.
    ///                     If null, do not display the symbol, just free it.
    /// \param yytype       The symbol type.
    /// \param yyvaluep     Its semantic value.
    /// \param yylocationp  Its location.
    inline void yydestruct_ (const char* yymsg,
			     int yytype,
			     semantic_type* yyvaluep,
			     location_type* yylocationp);

    /// Pop \a n symbols the three stacks.
    inline void yypop_ (unsigned int n = 1);

    /* Constants.  */
    static const int yyeof_;
    /* LAST_ -- Last index in TABLE_.  */
    static const int yylast_;
    static const int yynnts_;
    static const int yyempty_;
    static const int yyfinal_;
    static const int yyterror_;
    static const int yyerrcode_;
    static const int yyntokens_;
    static const unsigned int yyuser_token_number_max_;
    static const token_number_type yyundef_token_;

    /* User arguments.  */
    QJson::ParserPrivate* driver;
  };

}Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\json_parser.hh:66
  2021-07-25 15:03:06  [ main:943 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\json_parser.hh
  2021-07-25 15:03:06  [ main:944 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\json_scanner.cc
  2021-07-25 15:03:06  [ main:1276 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\json_scanner.cpp
  2021-07-25 15:03:06  [ main:1284 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\json_scanner.h
  2021-07-25 15:03:06  [ main:1285 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\location.hh
  2021-07-25 15:03:06  [ main:1285 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\parser.cpp
  2021-07-25 15:03:06  [ main:1296 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\parser.h
  2021-07-25 15:03:06  [ main:1296 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\parserrunnable.cpp
  2021-07-25 15:03:06  [ main:1304 ] - [ ERROR ]  parsing error 
QT_BEGIN_NAMESPACE
  2021-07-25 15:03:06  [ main:1305 ] - [ ERROR ]  warning: parse error QT_BEGIN_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\parserrunnable.h:29
  2021-07-25 15:03:06  [ main:1305 ] - [ ERROR ]  parsing error 
QT_END_NAMESPACE
  2021-07-25 15:03:06  [ main:1305 ] - [ ERROR ]  warning: parse error QT_END_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\parserrunnable.h:31
  2021-07-25 15:03:06  [ main:1305 ] - [ ERROR ]  parsing error 
class QJSON_EXPORT ParserRunnable  : public QObject, public QRunnable
  {
    Q_OBJECT
    public:
      explicit ParserRunnable(QObject* parent = 0);
      ~ParserRunnable();

      void setData( const QByteArray& data );

      void run();

    Q_SIGNALS:
      /**
      * This signal is emitted when the parsing process has been completed
      * @param json contains the result of the parsing
      * @param ok if a parsing error occurs ok is set to false, otherwise it's set to true.
      * @param error_msg contains a string explaining the failure reason
      **/
      void parsingFinished(const QVariant& json, bool ok, const QString& error_msg);

    private:
      Q_DISABLE_COPY(ParserRunnable)
      class Private;
      Private* const d;
  };
  2021-07-25 15:03:06  [ main:1305 ] - [ ERROR ]  warning: parse error class QJSON_EXPORT ParserRunnable  : public QObject, public QRunnable
  {
    Q_OBJECT
    public:
      explicit ParserRunnable(QObject* parent = 0);
      ~ParserRunnable();

      void setData( const QByteArray& data );

      void run();

    Q_SIGNALS:
      /**
      * This signal is emitted when the parsing process has been completed
      * @param json contains the result of the parsing
      * @param ok if a parsing error occurs ok is set to false, otherwise it's set to true.
      * @param error_msg contains a string explaining the failure reason
      **/
      void parsingFinished(const QVariant& json, bool ok, const QString& error_msg);

    private:
      Q_DISABLE_COPY(ParserRunnable)
      class Private;
      Private* const d;
  };Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\parserrunnable.h:37
  2021-07-25 15:03:06  [ main:1309 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\parserrunnable.h
  2021-07-25 15:03:06  [ main:1310 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\parser_p.h
  2021-07-25 15:03:06  [ main:1310 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\position.hh
  2021-07-25 15:03:06  [ main:1319 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\qjson_debug.h
  2021-07-25 15:03:06  [ main:1320 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\qjson_export.h
  2021-07-25 15:03:06  [ main:1321 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\qobjecthelper.cpp
  2021-07-25 15:03:06  [ main:1327 ] - [ ERROR ]  parsing error 
QT_BEGIN_NAMESPACE
  2021-07-25 15:03:06  [ main:1328 ] - [ ERROR ]  warning: parse error QT_BEGIN_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\qobjecthelper.h:30
  2021-07-25 15:03:06  [ main:1328 ] - [ ERROR ]  parsing error 
QT_END_NAMESPACE
  2021-07-25 15:03:06  [ main:1328 ] - [ ERROR ]  warning: parse error QT_END_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\qobjecthelper.h:32
  2021-07-25 15:03:06  [ main:1328 ] - [ ERROR ]  parsing error 
class QJSON_EXPORT QObjectHelper {
    public:
      QObjectHelper();
      ~QObjectHelper();

    /**
    * This method converts a QObject instance into a QVariantMap.
    *
    * @param object The QObject instance to be converted.
    * @param ignoredProperties Properties that won't be converted.
    */
    static QVariantMap qobject2qvariant( const QObject* object,
                                  const QStringList& ignoredProperties = QStringList(QString(QLatin1String("objectName"))));

    /**
    * This method converts a QVariantMap instance into a QObject
    *
    * @param variant Attributes to assign to the object.
    * @param object The QObject instance to update.
    */
    static void qvariant2qobject(const QVariantMap& variant, QObject* object);

    private:
      Q_DISABLE_COPY(QObjectHelper)
      class QObjectHelperPrivate;
      QObjectHelperPrivate* const d;
  };
  2021-07-25 15:03:06  [ main:1328 ] - [ ERROR ]  warning: parse error class QJSON_EXPORT QObjectHelper {
    public:
      QObjectHelper();
      ~QObjectHelper();

    /**
    * This method converts a QObject instance into a QVariantMap.
    *
    * @param object The QObject instance to be converted.
    * @param ignoredProperties Properties that won't be converted.
    */
    static QVariantMap qobject2qvariant( const QObject* object,
                                  const QStringList& ignoredProperties = QStringList(QString(QLatin1String("objectName"))));

    /**
    * This method converts a QVariantMap instance into a QObject
    *
    * @param variant Attributes to assign to the object.
    * @param object The QObject instance to update.
    */
    static void qvariant2qobject(const QVariantMap& variant, QObject* object);

    private:
      Q_DISABLE_COPY(QObjectHelper)
      class QObjectHelperPrivate;
      QObjectHelperPrivate* const d;
  };Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\qobjecthelper.h:118
  2021-07-25 15:03:06  [ main:1333 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\qobjecthelper.h
  2021-07-25 15:03:06  [ main:1334 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\serializer.cpp
  2021-07-25 15:03:06  [ main:1351 ] - [ ERROR ]  warning: parse error Q_FOREACH( const QByteArray& i, list ) {
    if ( !res.isEmpty() )
      res += sep;
    res += i;
  }Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializer.cpp:55
  2021-07-25 15:03:06  [ main:1351 ] - [ ERROR ]  warning: parse error Q_FOREACH( const QVariant& var, list )
    {
      indentLevel++;
      QByteArray serializedValue = serialize( var, ok, indentLevel);
      indentLevel--;
      if ( !*ok ) {
        break;
      }
      values << serializedValue;
    }Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializer.cpp:72
  2021-07-25 15:03:06  [ main:1363 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\serializer.h
  2021-07-25 15:03:06  [ main:1364 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\serializerrunnable.cpp
  2021-07-25 15:03:06  [ main:1370 ] - [ ERROR ]  parsing error 
QT_BEGIN_NAMESPACE
  2021-07-25 15:03:06  [ main:1371 ] - [ ERROR ]  warning: parse error QT_BEGIN_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializerrunnable.h:29
  2021-07-25 15:03:06  [ main:1371 ] - [ ERROR ]  parsing error 
QT_END_NAMESPACE
  2021-07-25 15:03:06  [ main:1371 ] - [ ERROR ]  warning: parse error QT_END_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializerrunnable.h:33
  2021-07-25 15:03:06  [ main:1371 ] - [ ERROR ]  parsing error 
class QJSON_EXPORT SerializerRunnable  : public QObject, public QRunnable
  {
    Q_OBJECT
    public:
      explicit SerializerRunnable(QObject* parent = 0);
      ~SerializerRunnable();

      /**
       * Sets the json object to serialize.
       *
       * @param json QVariant containing the json representation to be serialized
       */
      void setJsonObject( const QVariant& json );

      /* reimp */ void run();

    Q_SIGNALS:
      /**
      * This signal is emitted when the serialization process has been completed
      * @param serialized contains the result of the serialization
      * @param ok if a serialization error occurs ok is set to false, otherwise it's set to true.
      * @param error_msg contains a string explaining the failure reason
      **/
      void parsingFinished(const QByteArray& serialized, bool ok, const QString& error_msg);

    private:
      Q_DISABLE_COPY(SerializerRunnable)
      class Private;
      Private* const d;
  };
  2021-07-25 15:03:06  [ main:1371 ] - [ ERROR ]  warning: parse error class QJSON_EXPORT SerializerRunnable  : public QObject, public QRunnable
  {
    Q_OBJECT
    public:
      explicit SerializerRunnable(QObject* parent = 0);
      ~SerializerRunnable();

      /**
       * Sets the json object to serialize.
       *
       * @param json QVariant containing the json representation to be serialized
       */
      void setJsonObject( const QVariant& json );

      /* reimp */ void run();

    Q_SIGNALS:
      /**
      * This signal is emitted when the serialization process has been completed
      * @param serialized contains the result of the serialization
      * @param ok if a serialization error occurs ok is set to false, otherwise it's set to true.
      * @param error_msg contains a string explaining the failure reason
      **/
      void parsingFinished(const QByteArray& serialized, bool ok, const QString& error_msg);

    private:
      Q_DISABLE_COPY(SerializerRunnable)
      class Private;
      Private* const d;
  };Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializerrunnable.h:39
  2021-07-25 15:03:06  [ main:1375 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\serializerrunnable.h
  2021-07-25 15:03:06  [ main:1375 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\stack.hh
  2021-07-25 15:03:06  [ main:1378 ] - [ INFO ]  start dependency
  2021-07-25 15:03:06  [ main:1451 ] - [ INFO ]  includenum:73
  2021-07-25 15:03:06  [ main:1451 ] - [ INFO ]  definenum:81
  2021-07-25 15:03:06  [ main:1451 ] - [ INFO ]  callnum:45
  2021-07-25 15:03:06  [ main:1451 ] - [ INFO ]  returnnum:159
  2021-07-25 15:03:06  [ main:1451 ] - [ INFO ]  parameternum:614
  2021-07-25 15:03:06  [ main:1451 ] - [ INFO ]  extendnum:1
  2021-07-25 15:03:06  [ main:1451 ] - [ INFO ]  overridenum:1
  2021-07-25 15:03:07  [ main:1558 ] - [ INFO ]  Process finish!
  2021-07-25 15:24:52  [ main:0 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\phantompy.cpp
  2021-07-25 15:24:53  [ main:442 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 15:24:53  [ main:490 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\timeout.hpp:9
  2021-07-25 15:24:53  [ main:491 ] - [ ERROR ]  parsing error 
private slots:
    void handleTimeout();
  2021-07-25 15:24:53  [ main:491 ] - [ ERROR ]  warning: parse error private slots:
    void handleTimeout();Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\timeout.hpp:22
  2021-07-25 15:24:53  [ main:508 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 15:24:53  [ main:509 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\networkmanager.hpp:11
  2021-07-25 15:24:53  [ main:509 ] - [ ERROR ]  parsing error 
signals:
    void replyReceived(const QVariantMap &reply);
  2021-07-25 15:24:53  [ main:510 ] - [ ERROR ]  warning: parse error signals:
    void replyReceived(const QVariantMap &reply);Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\networkmanager.hpp:29
  2021-07-25 15:24:53  [ main:510 ] - [ ERROR ]  parsing error 
private slots:
    void provideAuthentication(QNetworkReply *reply, QAuthenticator *authenticator);
  2021-07-25 15:24:53  [ main:510 ] - [ ERROR ]  warning: parse error private slots:
    void provideAuthentication(QNetworkReply *reply, QAuthenticator *authenticator);Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\networkmanager.hpp:35
  2021-07-25 15:24:53  [ main:513 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 15:24:53  [ main:514 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\networkmanagerproxy.hpp:10
  2021-07-25 15:24:53  [ main:514 ] - [ ERROR ]  parsing error 
private slots:
    void finished();
  2021-07-25 15:24:53  [ main:514 ] - [ ERROR ]  warning: parse error private slots:
    void finished();Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\networkmanagerproxy.hpp:25
  2021-07-25 15:24:53  [ main:518 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 15:24:53  [ main:518 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\page.hpp:19
  2021-07-25 15:24:53  [ main:520 ] - [ ERROR ]  parsing error 
private slots:
    void loadFinished(bool ok);
  2021-07-25 15:24:53  [ main:520 ] - [ ERROR ]  warning: parse error private slots:
    void loadFinished(bool ok);Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\page.hpp:57
  2021-07-25 15:24:53  [ main:545 ] - [ ERROR ]  parsing error 
QT_BEGIN_NAMESPACE
  2021-07-25 15:24:53  [ main:546 ] - [ ERROR ]  warning: parse error QT_BEGIN_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\parser.h:26
  2021-07-25 15:24:53  [ main:546 ] - [ ERROR ]  parsing error 
QT_END_NAMESPACE
  2021-07-25 15:24:53  [ main:546 ] - [ ERROR ]  warning: parse error QT_END_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\parser.h:29
  2021-07-25 15:24:53  [ main:547 ] - [ ERROR ]  parsing error 
class QJSON_EXPORT Parser
  {
    public:
      Parser();
      ~Parser();

      /**
      * Read JSON string from the I/O Device and converts it to a QVariant object
      * @param io Input output device
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true.
      * @returns a QVariant object generated from the JSON string
      */
      QVariant parse(QIODevice* io, bool* ok = 0);

      /**
      * This is a method provided for convenience.
      * @param jsonData data containing the JSON object representation
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true.
      * @returns a QVariant object generated from the JSON string
      * @sa errorString
      * @sa errorLine
      */
      QVariant parse(const QByteArray& jsonData, bool* ok = 0);

      /**
      * This method returns the error message
      * @returns a QString object containing the error message of the last parse operation
      * @sa errorLine
      */
      QString errorString() const;

      /**
      * This method returns line number where the error occurred
      * @returns the line number where the error occurred
      * @sa errorString
      */
      int errorLine() const;

      /**
       * Sets whether special numbers (Infinity, -Infinity, NaN) are allowed as an extension to
       * the standard
       * @param  allowSpecialNumbers new value of whether special numbers are allowed
       * @sa specialNumbersAllowed
       */
      void allowSpecialNumbers(bool allowSpecialNumbers);

      /**
       * @returns whether special numbers (Infinity, -Infinity, NaN) are allowed
       * @sa allowSpecialNumbers
       */
      bool specialNumbersAllowed() const;

    private:
      Q_DISABLE_COPY(Parser)
      ParserPrivate* const d;
  };
  2021-07-25 15:24:53  [ main:547 ] - [ ERROR ]  warning: parse error class QJSON_EXPORT Parser
  {
    public:
      Parser();
      ~Parser();

      /**
      * Read JSON string from the I/O Device and converts it to a QVariant object
      * @param io Input output device
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true.
      * @returns a QVariant object generated from the JSON string
      */
      QVariant parse(QIODevice* io, bool* ok = 0);

      /**
      * This is a method provided for convenience.
      * @param jsonData data containing the JSON object representation
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true.
      * @returns a QVariant object generated from the JSON string
      * @sa errorString
      * @sa errorLine
      */
      QVariant parse(const QByteArray& jsonData, bool* ok = 0);

      /**
      * This method returns the error message
      * @returns a QString object containing the error message of the last parse operation
      * @sa errorLine
      */
      QString errorString() const;

      /**
      * This method returns line number where the error occurred
      * @returns the line number where the error occurred
      * @sa errorString
      */
      int errorLine() const;

      /**
       * Sets whether special numbers (Infinity, -Infinity, NaN) are allowed as an extension to
       * the standard
       * @param  allowSpecialNumbers new value of whether special numbers are allowed
       * @sa specialNumbersAllowed
       */
      void allowSpecialNumbers(bool allowSpecialNumbers);

      /**
       * @returns whether special numbers (Infinity, -Infinity, NaN) are allowed
       * @sa allowSpecialNumbers
       */
      bool specialNumbersAllowed() const;

    private:
      Q_DISABLE_COPY(Parser)
      ParserPrivate* const d;
  };Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\parser.h:41
  2021-07-25 15:24:53  [ main:1024 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 15:24:53  [ main:1024 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\eventprocessor.hpp:9
  2021-07-25 15:24:53  [ main:1025 ] - [ ERROR ]  parsing error 
private slots:
    void handleTimeout();
  2021-07-25 15:24:53  [ main:1025 ] - [ ERROR ]  warning: parse error private slots:
    void handleTimeout();Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\eventprocessor.hpp:23
  2021-07-25 15:24:53  [ main:1031 ] - [ ERROR ]  parsing error 
QT_BEGIN_NAMESPACE
  2021-07-25 15:24:53  [ main:1031 ] - [ ERROR ]  warning: parse error QT_BEGIN_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializer.h:26
  2021-07-25 15:24:53  [ main:1031 ] - [ ERROR ]  parsing error 
QT_END_NAMESPACE
  2021-07-25 15:24:53  [ main:1031 ] - [ ERROR ]  warning: parse error QT_END_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializer.h:30
  2021-07-25 15:24:53  [ main:1031 ] - [ ERROR ]  parsing error 
class QJSON_EXPORT Serializer {
  public:
    Serializer();
    ~Serializer();

     /**
      * This method generates a textual JSON representation and outputs it to the
      * passed in I/O Device.
      * @param variant The JSON document in its in-memory representation as generated by the
      * parser.
      * @param out Input output device
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true
      */
    void serialize( const QVariant& variant, QIODevice* out, bool* ok);

    /**
      * This is a method provided for convenience. It turns the passed in in-memory
      * representation of the JSON document into a textual one, which is returned.
      * If the returned string is empty, the document was empty. If it was null, there
      * was a parsing error.
      *
      * @param variant The JSON document in its in-memory representation as generated by the
      * parser.
      *
      * \deprecated This method is going to be removed with the next major release of QJson.
      */
    QByteArray serialize( const QVariant& variant);

    /**
      * This is a method provided for convenience. It turns the passed in in-memory
      * representation of the JSON document into a textual one, which is returned.
      * If the returned string is empty, the document was empty. If it was null, there
      * was a parsing error.
      *
      * @param variant The JSON document in its in-memory representation as generated by the
      * parser.
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true
      */
    QByteArray serialize( const QVariant& variant, bool *ok);

    /**
     * Allow or disallow writing of NaN and/or Infinity (as an extension to QJson)
     */
    void allowSpecialNumbers(bool allow);

    /**
     * Is Nan and/or Infinity allowed?
     */
    bool specialNumbersAllowed() const;

    /**
     * set output indentation mode as defined in QJson::IndentMode
     */
    void setIndentMode(IndentMode mode = QJson::IndentNone);


    /**
    * set double precision used while converting Double
    * \sa QByteArray::number
    */
    void setDoublePrecision(int precision);

    /**
     * Returns one of the indentation modes defined in QJson::IndentMode
     */
    IndentMode indentMode() const;

    /**
     * Returns the error message
     */
    QString errorMessage() const;

  private:
    Q_DISABLE_COPY(Serializer)
    class SerializerPrivate;
    SerializerPrivate* const d;
  };
  2021-07-25 15:24:53  [ main:1032 ] - [ ERROR ]  warning: parse error class QJSON_EXPORT Serializer {
  public:
    Serializer();
    ~Serializer();

     /**
      * This method generates a textual JSON representation and outputs it to the
      * passed in I/O Device.
      * @param variant The JSON document in its in-memory representation as generated by the
      * parser.
      * @param out Input output device
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true
      */
    void serialize( const QVariant& variant, QIODevice* out, bool* ok);

    /**
      * This is a method provided for convenience. It turns the passed in in-memory
      * representation of the JSON document into a textual one, which is returned.
      * If the returned string is empty, the document was empty. If it was null, there
      * was a parsing error.
      *
      * @param variant The JSON document in its in-memory representation as generated by the
      * parser.
      *
      * \deprecated This method is going to be removed with the next major release of QJson.
      */
    QByteArray serialize( const QVariant& variant);

    /**
      * This is a method provided for convenience. It turns the passed in in-memory
      * representation of the JSON document into a textual one, which is returned.
      * If the returned string is empty, the document was empty. If it was null, there
      * was a parsing error.
      *
      * @param variant The JSON document in its in-memory representation as generated by the
      * parser.
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true
      */
    QByteArray serialize( const QVariant& variant, bool *ok);

    /**
     * Allow or disallow writing of NaN and/or Infinity (as an extension to QJson)
     */
    void allowSpecialNumbers(bool allow);

    /**
     * Is Nan and/or Infinity allowed?
     */
    bool specialNumbersAllowed() const;

    /**
     * set output indentation mode as defined in QJson::IndentMode
     */
    void setIndentMode(IndentMode mode = QJson::IndentNone);


    /**
    * set double precision used while converting Double
    * \sa QByteArray::number
    */
    void setDoublePrecision(int precision);

    /**
     * Returns one of the indentation modes defined in QJson::IndentMode
     */
    IndentMode indentMode() const;

    /**
     * Returns the error message
     */
    QString errorMessage() const;

  private:
    Q_DISABLE_COPY(Serializer)
    class SerializerPrivate;
    SerializerPrivate* const d;
  };Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializer.h:112
  2021-07-25 15:24:53  [ main:1034 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 15:24:53  [ main:1034 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\cookiejar.hpp:14
  2021-07-25 15:24:53  [ main:1061 ] - [ ERROR ]  warning: parse error Q_FOREACH( const QByteArray& i, list ) {
    if ( !res.isEmpty() )
      res += sep;
    res += i;
  }Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializer.cpp:55
  2021-07-25 15:24:53  [ main:1062 ] - [ ERROR ]  warning: parse error Q_FOREACH( const QVariant& var, list )
    {
      indentLevel++;
      QByteArray serializedValue = serialize( var, ok, indentLevel);
      indentLevel--;
      if ( !*ok ) {
        break;
      }
      values << serializedValue;
    }Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializer.cpp:72
  2021-07-25 15:24:53  [ main:1085 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 15:24:53  [ main:1086 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\frame.hpp:11
  2021-07-25 15:24:53  [ main:1086 ] - [ ERROR ]  parsing error 
private slots:
    void loadFinished(bool ok);
  2021-07-25 15:24:53  [ main:1086 ] - [ ERROR ]  warning: parse error private slots:
    void loadFinished(bool ok);Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\frame.hpp:38
  2021-07-25 15:24:53  [ main:1088 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 15:24:53  [ main:1088 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\image.hpp:9
  2021-07-25 15:24:53  [ main:1098 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 15:24:53  [ main:1098 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\webelement.hpp:11
  2021-07-25 15:24:53  [ main:1099 ] - [ ERROR ]  parsing error 
private slots:
    void loadFinished(bool ok);
  2021-07-25 15:24:53  [ main:1099 ] - [ ERROR ]  warning: parse error private slots:
    void loadFinished(bool ok);Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\webelement.hpp:69
  2021-07-25 15:24:53  [ main:1102 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 15:24:53  [ main:1102 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\webelementcollection.hpp:11
  2021-07-25 15:24:53  [ main:1141 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\phantompy.hpp
  2021-07-25 15:24:53  [ main:1142 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\context.cpp
  2021-07-25 15:24:53  [ main:1157 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\context.hpp
  2021-07-25 15:24:53  [ main:1158 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\cookiejar.cpp
  2021-07-25 15:24:53  [ main:1174 ] - [ ERROR ]  warning: parse error foreach(QNetworkCookie n_cookie, cookiesForUrl(QUrl(url))) {
        cookie["name"] = QString::fromUtf8(n_cookie.name());
        cookie["value"] = QString::fromUtf8(n_cookie.value());
        cookie["domain"] = n_cookie.domain();
        cookie["path"] = n_cookie.path();
        cookie["expires"] = n_cookie.expirationDate().toString(Qt::ISODate);

        cookiesList.append(cookie);
    }Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\cookiejar.cpp:112
  2021-07-25 15:24:53  [ main:1179 ] - [ ERROR ]  warning: parse error foreach(QNetworkCookie n_cookie, allCookies()) {
        cookie["name"] = QString::fromUtf8(n_cookie.name());
        cookie["value"] = QString::fromUtf8(n_cookie.value());
        cookie["domain"] = n_cookie.domain();
        cookie["path"] = n_cookie.path();
        cookie["expires"] = n_cookie.expirationDate().toString(Qt::ISODate);

        cookiesList.append(cookie);
    }Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\cookiejar.cpp:129
  2021-07-25 15:24:53  [ main:1180 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\cookiejar.hpp
  2021-07-25 15:24:53  [ main:1181 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\eventprocessor.cpp
  2021-07-25 15:24:53  [ main:1187 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\eventprocessor.hpp
  2021-07-25 15:24:53  [ main:1188 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\frame.cpp
  2021-07-25 15:24:53  [ main:1210 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\frame.hpp
  2021-07-25 15:24:53  [ main:1211 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\image.cpp
  2021-07-25 15:24:53  [ main:1216 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\image.hpp
  2021-07-25 15:24:53  [ main:1217 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\networkmanager.cpp
  2021-07-25 15:24:53  [ main:1224 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 15:24:53  [ main:1224 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\networktimeout.hpp:10
  2021-07-25 15:24:53  [ main:1230 ] - [ ERROR ]  warning: parse error foreach (QByteArray headerName, reply->rawHeaderList()) {
        QVariantMap header;
        header["name"] = QString::fromUtf8(headerName);
        header["value"] = QString::fromUtf8(reply->rawHeader(headerName));

        headers.append(header);
    }Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\networkmanager.cpp:69
  2021-07-25 15:24:53  [ main:1231 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\networkmanager.hpp
  2021-07-25 15:24:53  [ main:1232 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\networkmanagerproxy.cpp
  2021-07-25 15:24:53  [ main:1239 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\networkmanagerproxy.hpp
  2021-07-25 15:24:53  [ main:1240 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\networktimeout.cpp
  2021-07-25 15:24:53  [ main:1244 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\networktimeout.hpp
  2021-07-25 15:24:53  [ main:1245 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\page.cpp
  2021-07-25 15:24:53  [ main:1256 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\page.hpp
  2021-07-25 15:24:53  [ main:1257 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\timeout.cpp
  2021-07-25 15:24:53  [ main:1262 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\timeout.hpp
  2021-07-25 15:24:53  [ main:1263 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\webelement.cpp
  2021-07-25 15:24:53  [ main:1272 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\webelement.hpp
  2021-07-25 15:24:53  [ main:1273 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\webelementcollection.cpp
  2021-07-25 15:24:53  [ main:1278 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\webelementcollection.hpp
  2021-07-25 15:24:53  [ main:1279 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\FlexLexer.h
  2021-07-25 15:24:53  [ main:1280 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\json_parser.cc
  2021-07-25 15:24:54  [ main:1340 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\json_parser.hh
  2021-07-25 15:24:54  [ main:1340 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\json_scanner.cc
  2021-07-25 15:24:54  [ main:1341 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\json_scanner.cpp
  2021-07-25 15:24:54  [ main:1342 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\json_scanner.h
  2021-07-25 15:24:54  [ main:1343 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\location.hh
  2021-07-25 15:24:54  [ main:1343 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\parser.cpp
  2021-07-25 15:24:54  [ main:1344 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\parser.h
  2021-07-25 15:24:54  [ main:1345 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\parserrunnable.cpp
  2021-07-25 15:24:54  [ main:1351 ] - [ ERROR ]  parsing error 
QT_BEGIN_NAMESPACE
  2021-07-25 15:24:54  [ main:1351 ] - [ ERROR ]  warning: parse error QT_BEGIN_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\parserrunnable.h:29
  2021-07-25 15:24:54  [ main:1351 ] - [ ERROR ]  parsing error 
QT_END_NAMESPACE
  2021-07-25 15:24:54  [ main:1352 ] - [ ERROR ]  warning: parse error QT_END_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\parserrunnable.h:31
  2021-07-25 15:24:54  [ main:1352 ] - [ ERROR ]  parsing error 
class QJSON_EXPORT ParserRunnable  : public QObject, public QRunnable
  {
    Q_OBJECT
    public:
      explicit ParserRunnable(QObject* parent = 0);
      ~ParserRunnable();

      void setData( const QByteArray& data );

      void run();

    Q_SIGNALS:
      /**
      * This signal is emitted when the parsing process has been completed
      * @param json contains the result of the parsing
      * @param ok if a parsing error occurs ok is set to false, otherwise it's set to true.
      * @param error_msg contains a string explaining the failure reason
      **/
      void parsingFinished(const QVariant& json, bool ok, const QString& error_msg);

    private:
      Q_DISABLE_COPY(ParserRunnable)
      class Private;
      Private* const d;
  };
  2021-07-25 15:24:54  [ main:1352 ] - [ ERROR ]  warning: parse error class QJSON_EXPORT ParserRunnable  : public QObject, public QRunnable
  {
    Q_OBJECT
    public:
      explicit ParserRunnable(QObject* parent = 0);
      ~ParserRunnable();

      void setData( const QByteArray& data );

      void run();

    Q_SIGNALS:
      /**
      * This signal is emitted when the parsing process has been completed
      * @param json contains the result of the parsing
      * @param ok if a parsing error occurs ok is set to false, otherwise it's set to true.
      * @param error_msg contains a string explaining the failure reason
      **/
      void parsingFinished(const QVariant& json, bool ok, const QString& error_msg);

    private:
      Q_DISABLE_COPY(ParserRunnable)
      class Private;
      Private* const d;
  };Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\parserrunnable.h:37
  2021-07-25 15:24:54  [ main:1356 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\parserrunnable.h
  2021-07-25 15:24:54  [ main:1357 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\parser_p.h
  2021-07-25 15:24:54  [ main:1358 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\position.hh
  2021-07-25 15:24:54  [ main:1367 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\qjson_debug.h
  2021-07-25 15:24:54  [ main:1367 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\qjson_export.h
  2021-07-25 15:24:54  [ main:1368 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\qobjecthelper.cpp
  2021-07-25 15:24:54  [ main:1377 ] - [ ERROR ]  parsing error 
QT_BEGIN_NAMESPACE
  2021-07-25 15:24:54  [ main:1377 ] - [ ERROR ]  warning: parse error QT_BEGIN_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\qobjecthelper.h:30
  2021-07-25 15:24:54  [ main:1377 ] - [ ERROR ]  parsing error 
QT_END_NAMESPACE
  2021-07-25 15:24:54  [ main:1377 ] - [ ERROR ]  warning: parse error QT_END_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\qobjecthelper.h:32
  2021-07-25 15:24:54  [ main:1378 ] - [ ERROR ]  parsing error 
class QJSON_EXPORT QObjectHelper {
    public:
      QObjectHelper();
      ~QObjectHelper();

    /**
    * This method converts a QObject instance into a QVariantMap.
    *
    * @param object The QObject instance to be converted.
    * @param ignoredProperties Properties that won't be converted.
    */
    static QVariantMap qobject2qvariant( const QObject* object,
                                  const QStringList& ignoredProperties = QStringList(QString(QLatin1String("objectName"))));

    /**
    * This method converts a QVariantMap instance into a QObject
    *
    * @param variant Attributes to assign to the object.
    * @param object The QObject instance to update.
    */
    static void qvariant2qobject(const QVariantMap& variant, QObject* object);

    private:
      Q_DISABLE_COPY(QObjectHelper)
      class QObjectHelperPrivate;
      QObjectHelperPrivate* const d;
  };
  2021-07-25 15:24:54  [ main:1378 ] - [ ERROR ]  warning: parse error class QJSON_EXPORT QObjectHelper {
    public:
      QObjectHelper();
      ~QObjectHelper();

    /**
    * This method converts a QObject instance into a QVariantMap.
    *
    * @param object The QObject instance to be converted.
    * @param ignoredProperties Properties that won't be converted.
    */
    static QVariantMap qobject2qvariant( const QObject* object,
                                  const QStringList& ignoredProperties = QStringList(QString(QLatin1String("objectName"))));

    /**
    * This method converts a QVariantMap instance into a QObject
    *
    * @param variant Attributes to assign to the object.
    * @param object The QObject instance to update.
    */
    static void qvariant2qobject(const QVariantMap& variant, QObject* object);

    private:
      Q_DISABLE_COPY(QObjectHelper)
      class QObjectHelperPrivate;
      QObjectHelperPrivate* const d;
  };Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\qobjecthelper.h:118
  2021-07-25 15:24:54  [ main:1382 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\qobjecthelper.h
  2021-07-25 15:24:54  [ main:1382 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\serializer.cpp
  2021-07-25 15:24:54  [ main:1383 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\serializer.h
  2021-07-25 15:24:54  [ main:1384 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\serializerrunnable.cpp
  2021-07-25 15:24:54  [ main:1392 ] - [ ERROR ]  parsing error 
QT_BEGIN_NAMESPACE
  2021-07-25 15:24:54  [ main:1392 ] - [ ERROR ]  warning: parse error QT_BEGIN_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializerrunnable.h:29
  2021-07-25 15:24:54  [ main:1392 ] - [ ERROR ]  parsing error 
QT_END_NAMESPACE
  2021-07-25 15:24:54  [ main:1392 ] - [ ERROR ]  warning: parse error QT_END_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializerrunnable.h:33
  2021-07-25 15:24:54  [ main:1392 ] - [ ERROR ]  parsing error 
class QJSON_EXPORT SerializerRunnable  : public QObject, public QRunnable
  {
    Q_OBJECT
    public:
      explicit SerializerRunnable(QObject* parent = 0);
      ~SerializerRunnable();

      /**
       * Sets the json object to serialize.
       *
       * @param json QVariant containing the json representation to be serialized
       */
      void setJsonObject( const QVariant& json );

      /* reimp */ void run();

    Q_SIGNALS:
      /**
      * This signal is emitted when the serialization process has been completed
      * @param serialized contains the result of the serialization
      * @param ok if a serialization error occurs ok is set to false, otherwise it's set to true.
      * @param error_msg contains a string explaining the failure reason
      **/
      void parsingFinished(const QByteArray& serialized, bool ok, const QString& error_msg);

    private:
      Q_DISABLE_COPY(SerializerRunnable)
      class Private;
      Private* const d;
  };
  2021-07-25 15:24:54  [ main:1392 ] - [ ERROR ]  warning: parse error class QJSON_EXPORT SerializerRunnable  : public QObject, public QRunnable
  {
    Q_OBJECT
    public:
      explicit SerializerRunnable(QObject* parent = 0);
      ~SerializerRunnable();

      /**
       * Sets the json object to serialize.
       *
       * @param json QVariant containing the json representation to be serialized
       */
      void setJsonObject( const QVariant& json );

      /* reimp */ void run();

    Q_SIGNALS:
      /**
      * This signal is emitted when the serialization process has been completed
      * @param serialized contains the result of the serialization
      * @param ok if a serialization error occurs ok is set to false, otherwise it's set to true.
      * @param error_msg contains a string explaining the failure reason
      **/
      void parsingFinished(const QByteArray& serialized, bool ok, const QString& error_msg);

    private:
      Q_DISABLE_COPY(SerializerRunnable)
      class Private;
      Private* const d;
  };Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializerrunnable.h:39
  2021-07-25 15:24:54  [ main:1396 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\serializerrunnable.h
  2021-07-25 15:24:54  [ main:1397 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\stack.hh
  2021-07-25 15:24:54  [ main:1399 ] - [ INFO ]  start dependency
  2021-07-25 15:24:54  [ main:1484 ] - [ INFO ]  includenum:88
  2021-07-25 15:24:54  [ main:1484 ] - [ INFO ]  definenum:81
  2021-07-25 15:24:54  [ main:1484 ] - [ INFO ]  callnum:45
  2021-07-25 15:24:54  [ main:1484 ] - [ INFO ]  returnnum:159
  2021-07-25 15:24:54  [ main:1484 ] - [ INFO ]  parameternum:614
  2021-07-25 15:24:54  [ main:1484 ] - [ INFO ]  extendnum:1
  2021-07-25 15:24:54  [ main:1484 ] - [ INFO ]  overridenum:1
  2021-07-25 15:24:54  [ main:1591 ] - [ INFO ]  Process finish!
  2021-07-25 15:25:11  [ main:0 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\phantompy.cpp
  2021-07-25 15:25:11  [ main:459 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 15:25:11  [ main:507 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\timeout.hpp:9
  2021-07-25 15:25:11  [ main:509 ] - [ ERROR ]  parsing error 
private slots:
    void handleTimeout();
  2021-07-25 15:25:11  [ main:509 ] - [ ERROR ]  warning: parse error private slots:
    void handleTimeout();Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\timeout.hpp:22
  2021-07-25 15:25:12  [ main:526 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 15:25:12  [ main:526 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\networkmanager.hpp:11
  2021-07-25 15:25:12  [ main:526 ] - [ ERROR ]  parsing error 
signals:
    void replyReceived(const QVariantMap &reply);
  2021-07-25 15:25:12  [ main:526 ] - [ ERROR ]  warning: parse error signals:
    void replyReceived(const QVariantMap &reply);Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\networkmanager.hpp:29
  2021-07-25 15:25:12  [ main:527 ] - [ ERROR ]  parsing error 
private slots:
    void provideAuthentication(QNetworkReply *reply, QAuthenticator *authenticator);
  2021-07-25 15:25:12  [ main:527 ] - [ ERROR ]  warning: parse error private slots:
    void provideAuthentication(QNetworkReply *reply, QAuthenticator *authenticator);Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\networkmanager.hpp:35
  2021-07-25 15:25:12  [ main:530 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 15:25:12  [ main:531 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\networkmanagerproxy.hpp:10
  2021-07-25 15:25:12  [ main:531 ] - [ ERROR ]  parsing error 
private slots:
    void finished();
  2021-07-25 15:25:12  [ main:531 ] - [ ERROR ]  warning: parse error private slots:
    void finished();Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\networkmanagerproxy.hpp:25
  2021-07-25 15:25:12  [ main:536 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 15:25:12  [ main:536 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\page.hpp:19
  2021-07-25 15:25:12  [ main:537 ] - [ ERROR ]  parsing error 
private slots:
    void loadFinished(bool ok);
  2021-07-25 15:25:12  [ main:538 ] - [ ERROR ]  warning: parse error private slots:
    void loadFinished(bool ok);Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\page.hpp:57
  2021-07-25 15:25:12  [ main:563 ] - [ ERROR ]  parsing error 
QT_BEGIN_NAMESPACE
  2021-07-25 15:25:12  [ main:563 ] - [ ERROR ]  warning: parse error QT_BEGIN_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\parser.h:26
  2021-07-25 15:25:12  [ main:563 ] - [ ERROR ]  parsing error 
QT_END_NAMESPACE
  2021-07-25 15:25:12  [ main:563 ] - [ ERROR ]  warning: parse error QT_END_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\parser.h:29
  2021-07-25 15:25:12  [ main:564 ] - [ ERROR ]  parsing error 
class QJSON_EXPORT Parser
  {
    public:
      Parser();
      ~Parser();

      /**
      * Read JSON string from the I/O Device and converts it to a QVariant object
      * @param io Input output device
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true.
      * @returns a QVariant object generated from the JSON string
      */
      QVariant parse(QIODevice* io, bool* ok = 0);

      /**
      * This is a method provided for convenience.
      * @param jsonData data containing the JSON object representation
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true.
      * @returns a QVariant object generated from the JSON string
      * @sa errorString
      * @sa errorLine
      */
      QVariant parse(const QByteArray& jsonData, bool* ok = 0);

      /**
      * This method returns the error message
      * @returns a QString object containing the error message of the last parse operation
      * @sa errorLine
      */
      QString errorString() const;

      /**
      * This method returns line number where the error occurred
      * @returns the line number where the error occurred
      * @sa errorString
      */
      int errorLine() const;

      /**
       * Sets whether special numbers (Infinity, -Infinity, NaN) are allowed as an extension to
       * the standard
       * @param  allowSpecialNumbers new value of whether special numbers are allowed
       * @sa specialNumbersAllowed
       */
      void allowSpecialNumbers(bool allowSpecialNumbers);

      /**
       * @returns whether special numbers (Infinity, -Infinity, NaN) are allowed
       * @sa allowSpecialNumbers
       */
      bool specialNumbersAllowed() const;

    private:
      Q_DISABLE_COPY(Parser)
      ParserPrivate* const d;
  };
  2021-07-25 15:25:12  [ main:564 ] - [ ERROR ]  warning: parse error class QJSON_EXPORT Parser
  {
    public:
      Parser();
      ~Parser();

      /**
      * Read JSON string from the I/O Device and converts it to a QVariant object
      * @param io Input output device
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true.
      * @returns a QVariant object generated from the JSON string
      */
      QVariant parse(QIODevice* io, bool* ok = 0);

      /**
      * This is a method provided for convenience.
      * @param jsonData data containing the JSON object representation
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true.
      * @returns a QVariant object generated from the JSON string
      * @sa errorString
      * @sa errorLine
      */
      QVariant parse(const QByteArray& jsonData, bool* ok = 0);

      /**
      * This method returns the error message
      * @returns a QString object containing the error message of the last parse operation
      * @sa errorLine
      */
      QString errorString() const;

      /**
      * This method returns line number where the error occurred
      * @returns the line number where the error occurred
      * @sa errorString
      */
      int errorLine() const;

      /**
       * Sets whether special numbers (Infinity, -Infinity, NaN) are allowed as an extension to
       * the standard
       * @param  allowSpecialNumbers new value of whether special numbers are allowed
       * @sa specialNumbersAllowed
       */
      void allowSpecialNumbers(bool allowSpecialNumbers);

      /**
       * @returns whether special numbers (Infinity, -Infinity, NaN) are allowed
       * @sa allowSpecialNumbers
       */
      bool specialNumbersAllowed() const;

    private:
      Q_DISABLE_COPY(Parser)
      ParserPrivate* const d;
  };Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\parser.h:41
  2021-07-25 15:25:12  [ main:1052 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 15:25:12  [ main:1052 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\eventprocessor.hpp:9
  2021-07-25 15:25:12  [ main:1053 ] - [ ERROR ]  parsing error 
private slots:
    void handleTimeout();
  2021-07-25 15:25:12  [ main:1053 ] - [ ERROR ]  warning: parse error private slots:
    void handleTimeout();Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\eventprocessor.hpp:23
  2021-07-25 15:25:12  [ main:1060 ] - [ ERROR ]  parsing error 
QT_BEGIN_NAMESPACE
  2021-07-25 15:25:12  [ main:1060 ] - [ ERROR ]  warning: parse error QT_BEGIN_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializer.h:26
  2021-07-25 15:25:12  [ main:1060 ] - [ ERROR ]  parsing error 
QT_END_NAMESPACE
  2021-07-25 15:25:12  [ main:1060 ] - [ ERROR ]  warning: parse error QT_END_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializer.h:30
  2021-07-25 15:25:12  [ main:1060 ] - [ ERROR ]  parsing error 
class QJSON_EXPORT Serializer {
  public:
    Serializer();
    ~Serializer();

     /**
      * This method generates a textual JSON representation and outputs it to the
      * passed in I/O Device.
      * @param variant The JSON document in its in-memory representation as generated by the
      * parser.
      * @param out Input output device
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true
      */
    void serialize( const QVariant& variant, QIODevice* out, bool* ok);

    /**
      * This is a method provided for convenience. It turns the passed in in-memory
      * representation of the JSON document into a textual one, which is returned.
      * If the returned string is empty, the document was empty. If it was null, there
      * was a parsing error.
      *
      * @param variant The JSON document in its in-memory representation as generated by the
      * parser.
      *
      * \deprecated This method is going to be removed with the next major release of QJson.
      */
    QByteArray serialize( const QVariant& variant);

    /**
      * This is a method provided for convenience. It turns the passed in in-memory
      * representation of the JSON document into a textual one, which is returned.
      * If the returned string is empty, the document was empty. If it was null, there
      * was a parsing error.
      *
      * @param variant The JSON document in its in-memory representation as generated by the
      * parser.
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true
      */
    QByteArray serialize( const QVariant& variant, bool *ok);

    /**
     * Allow or disallow writing of NaN and/or Infinity (as an extension to QJson)
     */
    void allowSpecialNumbers(bool allow);

    /**
     * Is Nan and/or Infinity allowed?
     */
    bool specialNumbersAllowed() const;

    /**
     * set output indentation mode as defined in QJson::IndentMode
     */
    void setIndentMode(IndentMode mode = QJson::IndentNone);


    /**
    * set double precision used while converting Double
    * \sa QByteArray::number
    */
    void setDoublePrecision(int precision);

    /**
     * Returns one of the indentation modes defined in QJson::IndentMode
     */
    IndentMode indentMode() const;

    /**
     * Returns the error message
     */
    QString errorMessage() const;

  private:
    Q_DISABLE_COPY(Serializer)
    class SerializerPrivate;
    SerializerPrivate* const d;
  };
  2021-07-25 15:25:12  [ main:1061 ] - [ ERROR ]  warning: parse error class QJSON_EXPORT Serializer {
  public:
    Serializer();
    ~Serializer();

     /**
      * This method generates a textual JSON representation and outputs it to the
      * passed in I/O Device.
      * @param variant The JSON document in its in-memory representation as generated by the
      * parser.
      * @param out Input output device
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true
      */
    void serialize( const QVariant& variant, QIODevice* out, bool* ok);

    /**
      * This is a method provided for convenience. It turns the passed in in-memory
      * representation of the JSON document into a textual one, which is returned.
      * If the returned string is empty, the document was empty. If it was null, there
      * was a parsing error.
      *
      * @param variant The JSON document in its in-memory representation as generated by the
      * parser.
      *
      * \deprecated This method is going to be removed with the next major release of QJson.
      */
    QByteArray serialize( const QVariant& variant);

    /**
      * This is a method provided for convenience. It turns the passed in in-memory
      * representation of the JSON document into a textual one, which is returned.
      * If the returned string is empty, the document was empty. If it was null, there
      * was a parsing error.
      *
      * @param variant The JSON document in its in-memory representation as generated by the
      * parser.
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true
      */
    QByteArray serialize( const QVariant& variant, bool *ok);

    /**
     * Allow or disallow writing of NaN and/or Infinity (as an extension to QJson)
     */
    void allowSpecialNumbers(bool allow);

    /**
     * Is Nan and/or Infinity allowed?
     */
    bool specialNumbersAllowed() const;

    /**
     * set output indentation mode as defined in QJson::IndentMode
     */
    void setIndentMode(IndentMode mode = QJson::IndentNone);


    /**
    * set double precision used while converting Double
    * \sa QByteArray::number
    */
    void setDoublePrecision(int precision);

    /**
     * Returns one of the indentation modes defined in QJson::IndentMode
     */
    IndentMode indentMode() const;

    /**
     * Returns the error message
     */
    QString errorMessage() const;

  private:
    Q_DISABLE_COPY(Serializer)
    class SerializerPrivate;
    SerializerPrivate* const d;
  };Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializer.h:112
  2021-07-25 15:25:12  [ main:1064 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 15:25:12  [ main:1064 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\cookiejar.hpp:14
  2021-07-25 15:25:12  [ main:1089 ] - [ ERROR ]  warning: parse error Q_FOREACH( const QByteArray& i, list ) {
    if ( !res.isEmpty() )
      res += sep;
    res += i;
  }Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializer.cpp:55
  2021-07-25 15:25:12  [ main:1089 ] - [ ERROR ]  warning: parse error Q_FOREACH( const QVariant& var, list )
    {
      indentLevel++;
      QByteArray serializedValue = serialize( var, ok, indentLevel);
      indentLevel--;
      if ( !*ok ) {
        break;
      }
      values << serializedValue;
    }Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializer.cpp:72
  2021-07-25 15:25:12  [ main:1109 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 15:25:12  [ main:1110 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\frame.hpp:11
  2021-07-25 15:25:12  [ main:1110 ] - [ ERROR ]  parsing error 
private slots:
    void loadFinished(bool ok);
  2021-07-25 15:25:12  [ main:1110 ] - [ ERROR ]  warning: parse error private slots:
    void loadFinished(bool ok);Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\frame.hpp:38
  2021-07-25 15:25:12  [ main:1112 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 15:25:12  [ main:1112 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\image.hpp:9
  2021-07-25 15:25:12  [ main:1121 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 15:25:12  [ main:1121 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\webelement.hpp:11
  2021-07-25 15:25:12  [ main:1121 ] - [ ERROR ]  parsing error 
private slots:
    void loadFinished(bool ok);
  2021-07-25 15:25:12  [ main:1121 ] - [ ERROR ]  warning: parse error private slots:
    void loadFinished(bool ok);Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\webelement.hpp:69
  2021-07-25 15:25:12  [ main:1125 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 15:25:12  [ main:1125 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\webelementcollection.hpp:11
  2021-07-25 15:25:12  [ main:1159 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\phantompy.hpp
  2021-07-25 15:25:12  [ main:1160 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\context.cpp
  2021-07-25 15:25:12  [ main:1175 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\context.hpp
  2021-07-25 15:25:12  [ main:1176 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\cookiejar.cpp
  2021-07-25 15:25:12  [ main:1188 ] - [ ERROR ]  warning: parse error foreach(QNetworkCookie n_cookie, cookiesForUrl(QUrl(url))) {
        cookie["name"] = QString::fromUtf8(n_cookie.name());
        cookie["value"] = QString::fromUtf8(n_cookie.value());
        cookie["domain"] = n_cookie.domain();
        cookie["path"] = n_cookie.path();
        cookie["expires"] = n_cookie.expirationDate().toString(Qt::ISODate);

        cookiesList.append(cookie);
    }Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\cookiejar.cpp:112
  2021-07-25 15:25:12  [ main:1188 ] - [ ERROR ]  warning: parse error foreach(QNetworkCookie n_cookie, allCookies()) {
        cookie["name"] = QString::fromUtf8(n_cookie.name());
        cookie["value"] = QString::fromUtf8(n_cookie.value());
        cookie["domain"] = n_cookie.domain();
        cookie["path"] = n_cookie.path();
        cookie["expires"] = n_cookie.expirationDate().toString(Qt::ISODate);

        cookiesList.append(cookie);
    }Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\cookiejar.cpp:129
  2021-07-25 15:25:12  [ main:1189 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\cookiejar.hpp
  2021-07-25 15:25:12  [ main:1190 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\eventprocessor.cpp
  2021-07-25 15:25:12  [ main:1195 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\eventprocessor.hpp
  2021-07-25 15:25:12  [ main:1196 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\frame.cpp
  2021-07-25 15:25:12  [ main:1215 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\frame.hpp
  2021-07-25 15:25:12  [ main:1215 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\image.cpp
  2021-07-25 15:25:12  [ main:1220 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\image.hpp
  2021-07-25 15:25:12  [ main:1221 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\networkmanager.cpp
  2021-07-25 15:25:12  [ main:1227 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 15:25:12  [ main:1227 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\networktimeout.hpp:10
  2021-07-25 15:25:12  [ main:1233 ] - [ ERROR ]  warning: parse error foreach (QByteArray headerName, reply->rawHeaderList()) {
        QVariantMap header;
        header["name"] = QString::fromUtf8(headerName);
        header["value"] = QString::fromUtf8(reply->rawHeader(headerName));

        headers.append(header);
    }Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\networkmanager.cpp:69
  2021-07-25 15:25:12  [ main:1235 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\networkmanager.hpp
  2021-07-25 15:25:12  [ main:1235 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\networkmanagerproxy.cpp
  2021-07-25 15:25:12  [ main:1241 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\networkmanagerproxy.hpp
  2021-07-25 15:25:12  [ main:1242 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\networktimeout.cpp
  2021-07-25 15:25:12  [ main:1246 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\networktimeout.hpp
  2021-07-25 15:25:12  [ main:1246 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\page.cpp
  2021-07-25 15:25:12  [ main:1255 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\page.hpp
  2021-07-25 15:25:12  [ main:1256 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\timeout.cpp
  2021-07-25 15:25:12  [ main:1261 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\timeout.hpp
  2021-07-25 15:25:12  [ main:1262 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\webelement.cpp
  2021-07-25 15:25:12  [ main:1272 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\webelement.hpp
  2021-07-25 15:25:12  [ main:1273 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\webelementcollection.cpp
  2021-07-25 15:25:12  [ main:1277 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\webelementcollection.hpp
  2021-07-25 15:25:12  [ main:1278 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\FlexLexer.h
  2021-07-25 15:25:12  [ main:1279 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\json_parser.cc
  2021-07-25 15:25:12  [ main:1336 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\json_parser.hh
  2021-07-25 15:25:12  [ main:1338 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\json_scanner.cc
  2021-07-25 15:25:12  [ main:1339 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\json_scanner.cpp
  2021-07-25 15:25:12  [ main:1340 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\json_scanner.h
  2021-07-25 15:25:12  [ main:1341 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\location.hh
  2021-07-25 15:25:12  [ main:1341 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\parser.cpp
  2021-07-25 15:25:12  [ main:1342 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\parser.h
  2021-07-25 15:25:12  [ main:1343 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\parserrunnable.cpp
  2021-07-25 15:25:12  [ main:1349 ] - [ ERROR ]  parsing error 
QT_BEGIN_NAMESPACE
  2021-07-25 15:25:12  [ main:1349 ] - [ ERROR ]  warning: parse error QT_BEGIN_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\parserrunnable.h:29
  2021-07-25 15:25:12  [ main:1349 ] - [ ERROR ]  parsing error 
QT_END_NAMESPACE
  2021-07-25 15:25:12  [ main:1349 ] - [ ERROR ]  warning: parse error QT_END_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\parserrunnable.h:31
  2021-07-25 15:25:12  [ main:1349 ] - [ ERROR ]  parsing error 
class QJSON_EXPORT ParserRunnable  : public QObject, public QRunnable
  {
    Q_OBJECT
    public:
      explicit ParserRunnable(QObject* parent = 0);
      ~ParserRunnable();

      void setData( const QByteArray& data );

      void run();

    Q_SIGNALS:
      /**
      * This signal is emitted when the parsing process has been completed
      * @param json contains the result of the parsing
      * @param ok if a parsing error occurs ok is set to false, otherwise it's set to true.
      * @param error_msg contains a string explaining the failure reason
      **/
      void parsingFinished(const QVariant& json, bool ok, const QString& error_msg);

    private:
      Q_DISABLE_COPY(ParserRunnable)
      class Private;
      Private* const d;
  };
  2021-07-25 15:25:12  [ main:1350 ] - [ ERROR ]  warning: parse error class QJSON_EXPORT ParserRunnable  : public QObject, public QRunnable
  {
    Q_OBJECT
    public:
      explicit ParserRunnable(QObject* parent = 0);
      ~ParserRunnable();

      void setData( const QByteArray& data );

      void run();

    Q_SIGNALS:
      /**
      * This signal is emitted when the parsing process has been completed
      * @param json contains the result of the parsing
      * @param ok if a parsing error occurs ok is set to false, otherwise it's set to true.
      * @param error_msg contains a string explaining the failure reason
      **/
      void parsingFinished(const QVariant& json, bool ok, const QString& error_msg);

    private:
      Q_DISABLE_COPY(ParserRunnable)
      class Private;
      Private* const d;
  };Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\parserrunnable.h:37
  2021-07-25 15:25:12  [ main:1354 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\parserrunnable.h
  2021-07-25 15:25:12  [ main:1355 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\parser_p.h
  2021-07-25 15:25:12  [ main:1355 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\position.hh
  2021-07-25 15:25:12  [ main:1363 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\qjson_debug.h
  2021-07-25 15:25:12  [ main:1364 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\qjson_export.h
  2021-07-25 15:25:12  [ main:1365 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\qobjecthelper.cpp
  2021-07-25 15:25:12  [ main:1373 ] - [ ERROR ]  parsing error 
QT_BEGIN_NAMESPACE
  2021-07-25 15:25:12  [ main:1374 ] - [ ERROR ]  warning: parse error QT_BEGIN_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\qobjecthelper.h:30
  2021-07-25 15:25:12  [ main:1374 ] - [ ERROR ]  parsing error 
QT_END_NAMESPACE
  2021-07-25 15:25:12  [ main:1374 ] - [ ERROR ]  warning: parse error QT_END_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\qobjecthelper.h:32
  2021-07-25 15:25:12  [ main:1374 ] - [ ERROR ]  parsing error 
class QJSON_EXPORT QObjectHelper {
    public:
      QObjectHelper();
      ~QObjectHelper();

    /**
    * This method converts a QObject instance into a QVariantMap.
    *
    * @param object The QObject instance to be converted.
    * @param ignoredProperties Properties that won't be converted.
    */
    static QVariantMap qobject2qvariant( const QObject* object,
                                  const QStringList& ignoredProperties = QStringList(QString(QLatin1String("objectName"))));

    /**
    * This method converts a QVariantMap instance into a QObject
    *
    * @param variant Attributes to assign to the object.
    * @param object The QObject instance to update.
    */
    static void qvariant2qobject(const QVariantMap& variant, QObject* object);

    private:
      Q_DISABLE_COPY(QObjectHelper)
      class QObjectHelperPrivate;
      QObjectHelperPrivate* const d;
  };
  2021-07-25 15:25:12  [ main:1374 ] - [ ERROR ]  warning: parse error class QJSON_EXPORT QObjectHelper {
    public:
      QObjectHelper();
      ~QObjectHelper();

    /**
    * This method converts a QObject instance into a QVariantMap.
    *
    * @param object The QObject instance to be converted.
    * @param ignoredProperties Properties that won't be converted.
    */
    static QVariantMap qobject2qvariant( const QObject* object,
                                  const QStringList& ignoredProperties = QStringList(QString(QLatin1String("objectName"))));

    /**
    * This method converts a QVariantMap instance into a QObject
    *
    * @param variant Attributes to assign to the object.
    * @param object The QObject instance to update.
    */
    static void qvariant2qobject(const QVariantMap& variant, QObject* object);

    private:
      Q_DISABLE_COPY(QObjectHelper)
      class QObjectHelperPrivate;
      QObjectHelperPrivate* const d;
  };Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\qobjecthelper.h:118
  2021-07-25 15:25:12  [ main:1378 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\qobjecthelper.h
  2021-07-25 15:25:12  [ main:1379 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\serializer.cpp
  2021-07-25 15:25:12  [ main:1380 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\serializer.h
  2021-07-25 15:25:12  [ main:1380 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\serializerrunnable.cpp
  2021-07-25 15:25:12  [ main:1388 ] - [ ERROR ]  parsing error 
QT_BEGIN_NAMESPACE
  2021-07-25 15:25:12  [ main:1388 ] - [ ERROR ]  warning: parse error QT_BEGIN_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializerrunnable.h:29
  2021-07-25 15:25:12  [ main:1388 ] - [ ERROR ]  parsing error 
QT_END_NAMESPACE
  2021-07-25 15:25:12  [ main:1388 ] - [ ERROR ]  warning: parse error QT_END_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializerrunnable.h:33
  2021-07-25 15:25:12  [ main:1388 ] - [ ERROR ]  parsing error 
class QJSON_EXPORT SerializerRunnable  : public QObject, public QRunnable
  {
    Q_OBJECT
    public:
      explicit SerializerRunnable(QObject* parent = 0);
      ~SerializerRunnable();

      /**
       * Sets the json object to serialize.
       *
       * @param json QVariant containing the json representation to be serialized
       */
      void setJsonObject( const QVariant& json );

      /* reimp */ void run();

    Q_SIGNALS:
      /**
      * This signal is emitted when the serialization process has been completed
      * @param serialized contains the result of the serialization
      * @param ok if a serialization error occurs ok is set to false, otherwise it's set to true.
      * @param error_msg contains a string explaining the failure reason
      **/
      void parsingFinished(const QByteArray& serialized, bool ok, const QString& error_msg);

    private:
      Q_DISABLE_COPY(SerializerRunnable)
      class Private;
      Private* const d;
  };
  2021-07-25 15:25:12  [ main:1388 ] - [ ERROR ]  warning: parse error class QJSON_EXPORT SerializerRunnable  : public QObject, public QRunnable
  {
    Q_OBJECT
    public:
      explicit SerializerRunnable(QObject* parent = 0);
      ~SerializerRunnable();

      /**
       * Sets the json object to serialize.
       *
       * @param json QVariant containing the json representation to be serialized
       */
      void setJsonObject( const QVariant& json );

      /* reimp */ void run();

    Q_SIGNALS:
      /**
      * This signal is emitted when the serialization process has been completed
      * @param serialized contains the result of the serialization
      * @param ok if a serialization error occurs ok is set to false, otherwise it's set to true.
      * @param error_msg contains a string explaining the failure reason
      **/
      void parsingFinished(const QByteArray& serialized, bool ok, const QString& error_msg);

    private:
      Q_DISABLE_COPY(SerializerRunnable)
      class Private;
      Private* const d;
  };Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializerrunnable.h:39
  2021-07-25 15:25:12  [ main:1392 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\serializerrunnable.h
  2021-07-25 15:25:12  [ main:1392 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\stack.hh
  2021-07-25 15:25:12  [ main:1395 ] - [ INFO ]  start dependency
  2021-07-25 15:25:12  [ main:1475 ] - [ INFO ]  includenum:88
  2021-07-25 15:25:12  [ main:1475 ] - [ INFO ]  definenum:81
  2021-07-25 15:25:12  [ main:1475 ] - [ INFO ]  callnum:45
  2021-07-25 15:25:12  [ main:1475 ] - [ INFO ]  returnnum:159
  2021-07-25 15:25:12  [ main:1475 ] - [ INFO ]  parameternum:614
  2021-07-25 15:25:12  [ main:1475 ] - [ INFO ]  extendnum:1
  2021-07-25 15:25:12  [ main:1475 ] - [ INFO ]  overridenum:1
  2021-07-25 15:25:13  [ main:1582 ] - [ INFO ]  Process finish!
  2021-07-25 15:45:25  [ main:0 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\phantompy.cpp
  2021-07-25 15:45:25  [ main:464 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 15:45:25  [ main:515 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\eventprocessor.hpp:9
  2021-07-25 15:45:25  [ main:517 ] - [ ERROR ]  parsing error 
private slots:
    void handleTimeout();
  2021-07-25 15:45:25  [ main:517 ] - [ ERROR ]  warning: parse error private slots:
    void handleTimeout();Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\eventprocessor.hpp:23
  2021-07-25 15:45:26  [ main:588 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 15:45:26  [ main:588 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\timeout.hpp:9
  2021-07-25 15:45:26  [ main:588 ] - [ ERROR ]  parsing error 
private slots:
    void handleTimeout();
  2021-07-25 15:45:26  [ main:588 ] - [ ERROR ]  warning: parse error private slots:
    void handleTimeout();Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\timeout.hpp:22
  2021-07-25 15:45:26  [ main:592 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 15:45:26  [ main:592 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\webelement.hpp:11
  2021-07-25 15:45:26  [ main:595 ] - [ ERROR ]  parsing error 
private slots:
    void loadFinished(bool ok);
  2021-07-25 15:45:26  [ main:595 ] - [ ERROR ]  warning: parse error private slots:
    void loadFinished(bool ok);Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\webelement.hpp:69
  2021-07-25 15:45:26  [ main:617 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 15:45:26  [ main:617 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\webelementcollection.hpp:11
  2021-07-25 15:45:26  [ main:628 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 15:45:26  [ main:628 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\networkmanager.hpp:11
  2021-07-25 15:45:26  [ main:629 ] - [ ERROR ]  parsing error 
signals:
    void replyReceived(const QVariantMap &reply);
  2021-07-25 15:45:26  [ main:629 ] - [ ERROR ]  warning: parse error signals:
    void replyReceived(const QVariantMap &reply);Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\networkmanager.hpp:29
  2021-07-25 15:45:26  [ main:629 ] - [ ERROR ]  parsing error 
private slots:
    void provideAuthentication(QNetworkReply *reply, QAuthenticator *authenticator);
  2021-07-25 15:45:26  [ main:629 ] - [ ERROR ]  warning: parse error private slots:
    void provideAuthentication(QNetworkReply *reply, QAuthenticator *authenticator);Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\networkmanager.hpp:35
  2021-07-25 15:45:26  [ main:636 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 15:45:26  [ main:637 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\networkmanagerproxy.hpp:10
  2021-07-25 15:45:26  [ main:637 ] - [ ERROR ]  parsing error 
private slots:
    void finished();
  2021-07-25 15:45:26  [ main:637 ] - [ ERROR ]  warning: parse error private slots:
    void finished();Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\networkmanagerproxy.hpp:25
  2021-07-25 15:45:26  [ main:656 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 15:45:26  [ main:656 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\networktimeout.hpp:10
  2021-07-25 15:45:26  [ main:669 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 15:45:26  [ main:670 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\cookiejar.hpp:14
  2021-07-25 15:45:26  [ main:685 ] - [ ERROR ]  warning: parse error foreach(QNetworkCookie n_cookie, cookiesForUrl(QUrl(url))) {
        cookie["name"] = QString::fromUtf8(n_cookie.name());
        cookie["value"] = QString::fromUtf8(n_cookie.value());
        cookie["domain"] = n_cookie.domain();
        cookie["path"] = n_cookie.path();
        cookie["expires"] = n_cookie.expirationDate().toString(Qt::ISODate);

        cookiesList.append(cookie);
    }Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\cookiejar.cpp:112
  2021-07-25 15:45:26  [ main:686 ] - [ ERROR ]  warning: parse error foreach(QNetworkCookie n_cookie, allCookies()) {
        cookie["name"] = QString::fromUtf8(n_cookie.name());
        cookie["value"] = QString::fromUtf8(n_cookie.value());
        cookie["domain"] = n_cookie.domain();
        cookie["path"] = n_cookie.path();
        cookie["expires"] = n_cookie.expirationDate().toString(Qt::ISODate);

        cookiesList.append(cookie);
    }Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\cookiejar.cpp:129
  2021-07-25 15:45:26  [ main:694 ] - [ ERROR ]  warning: parse error foreach (QByteArray headerName, reply->rawHeaderList()) {
        QVariantMap header;
        header["name"] = QString::fromUtf8(headerName);
        header["value"] = QString::fromUtf8(reply->rawHeader(headerName));

        headers.append(header);
    }Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\networkmanager.cpp:69
  2021-07-25 15:45:26  [ main:699 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 15:45:26  [ main:699 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\page.hpp:19
  2021-07-25 15:45:26  [ main:700 ] - [ ERROR ]  parsing error 
private slots:
    void loadFinished(bool ok);
  2021-07-25 15:45:26  [ main:700 ] - [ ERROR ]  warning: parse error private slots:
    void loadFinished(bool ok);Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\page.hpp:57
  2021-07-25 15:45:26  [ main:723 ] - [ ERROR ]  parsing error 
QT_BEGIN_NAMESPACE
  2021-07-25 15:45:26  [ main:723 ] - [ ERROR ]  warning: parse error QT_BEGIN_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\parser.h:26
  2021-07-25 15:45:26  [ main:723 ] - [ ERROR ]  parsing error 
QT_END_NAMESPACE
  2021-07-25 15:45:26  [ main:723 ] - [ ERROR ]  warning: parse error QT_END_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\parser.h:29
  2021-07-25 15:45:26  [ main:724 ] - [ ERROR ]  parsing error 
class QJSON_EXPORT Parser
  {
    public:
      Parser();
      ~Parser();

      /**
      * Read JSON string from the I/O Device and converts it to a QVariant object
      * @param io Input output device
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true.
      * @returns a QVariant object generated from the JSON string
      */
      QVariant parse(QIODevice* io, bool* ok = 0);

      /**
      * This is a method provided for convenience.
      * @param jsonData data containing the JSON object representation
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true.
      * @returns a QVariant object generated from the JSON string
      * @sa errorString
      * @sa errorLine
      */
      QVariant parse(const QByteArray& jsonData, bool* ok = 0);

      /**
      * This method returns the error message
      * @returns a QString object containing the error message of the last parse operation
      * @sa errorLine
      */
      QString errorString() const;

      /**
      * This method returns line number where the error occurred
      * @returns the line number where the error occurred
      * @sa errorString
      */
      int errorLine() const;

      /**
       * Sets whether special numbers (Infinity, -Infinity, NaN) are allowed as an extension to
       * the standard
       * @param  allowSpecialNumbers new value of whether special numbers are allowed
       * @sa specialNumbersAllowed
       */
      void allowSpecialNumbers(bool allowSpecialNumbers);

      /**
       * @returns whether special numbers (Infinity, -Infinity, NaN) are allowed
       * @sa allowSpecialNumbers
       */
      bool specialNumbersAllowed() const;

    private:
      Q_DISABLE_COPY(Parser)
      ParserPrivate* const d;
  };
  2021-07-25 15:45:26  [ main:724 ] - [ ERROR ]  warning: parse error class QJSON_EXPORT Parser
  {
    public:
      Parser();
      ~Parser();

      /**
      * Read JSON string from the I/O Device and converts it to a QVariant object
      * @param io Input output device
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true.
      * @returns a QVariant object generated from the JSON string
      */
      QVariant parse(QIODevice* io, bool* ok = 0);

      /**
      * This is a method provided for convenience.
      * @param jsonData data containing the JSON object representation
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true.
      * @returns a QVariant object generated from the JSON string
      * @sa errorString
      * @sa errorLine
      */
      QVariant parse(const QByteArray& jsonData, bool* ok = 0);

      /**
      * This method returns the error message
      * @returns a QString object containing the error message of the last parse operation
      * @sa errorLine
      */
      QString errorString() const;

      /**
      * This method returns line number where the error occurred
      * @returns the line number where the error occurred
      * @sa errorString
      */
      int errorLine() const;

      /**
       * Sets whether special numbers (Infinity, -Infinity, NaN) are allowed as an extension to
       * the standard
       * @param  allowSpecialNumbers new value of whether special numbers are allowed
       * @sa specialNumbersAllowed
       */
      void allowSpecialNumbers(bool allowSpecialNumbers);

      /**
       * @returns whether special numbers (Infinity, -Infinity, NaN) are allowed
       * @sa allowSpecialNumbers
       */
      bool specialNumbersAllowed() const;

    private:
      Q_DISABLE_COPY(Parser)
      ParserPrivate* const d;
  };Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\parser.h:41
  2021-07-25 15:45:26  [ main:1269 ] - [ ERROR ]  parsing error 
QT_BEGIN_NAMESPACE
  2021-07-25 15:45:26  [ main:1269 ] - [ ERROR ]  warning: parse error QT_BEGIN_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializer.h:26
  2021-07-25 15:45:26  [ main:1269 ] - [ ERROR ]  parsing error 
QT_END_NAMESPACE
  2021-07-25 15:45:26  [ main:1269 ] - [ ERROR ]  warning: parse error QT_END_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializer.h:30
  2021-07-25 15:45:26  [ main:1269 ] - [ ERROR ]  parsing error 
class QJSON_EXPORT Serializer {
  public:
    Serializer();
    ~Serializer();

     /**
      * This method generates a textual JSON representation and outputs it to the
      * passed in I/O Device.
      * @param variant The JSON document in its in-memory representation as generated by the
      * parser.
      * @param out Input output device
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true
      */
    void serialize( const QVariant& variant, QIODevice* out, bool* ok);

    /**
      * This is a method provided for convenience. It turns the passed in in-memory
      * representation of the JSON document into a textual one, which is returned.
      * If the returned string is empty, the document was empty. If it was null, there
      * was a parsing error.
      *
      * @param variant The JSON document in its in-memory representation as generated by the
      * parser.
      *
      * \deprecated This method is going to be removed with the next major release of QJson.
      */
    QByteArray serialize( const QVariant& variant);

    /**
      * This is a method provided for convenience. It turns the passed in in-memory
      * representation of the JSON document into a textual one, which is returned.
      * If the returned string is empty, the document was empty. If it was null, there
      * was a parsing error.
      *
      * @param variant The JSON document in its in-memory representation as generated by the
      * parser.
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true
      */
    QByteArray serialize( const QVariant& variant, bool *ok);

    /**
     * Allow or disallow writing of NaN and/or Infinity (as an extension to QJson)
     */
    void allowSpecialNumbers(bool allow);

    /**
     * Is Nan and/or Infinity allowed?
     */
    bool specialNumbersAllowed() const;

    /**
     * set output indentation mode as defined in QJson::IndentMode
     */
    void setIndentMode(IndentMode mode = QJson::IndentNone);


    /**
    * set double precision used while converting Double
    * \sa QByteArray::number
    */
    void setDoublePrecision(int precision);

    /**
     * Returns one of the indentation modes defined in QJson::IndentMode
     */
    IndentMode indentMode() const;

    /**
     * Returns the error message
     */
    QString errorMessage() const;

  private:
    Q_DISABLE_COPY(Serializer)
    class SerializerPrivate;
    SerializerPrivate* const d;
  };
  2021-07-25 15:45:26  [ main:1269 ] - [ ERROR ]  warning: parse error class QJSON_EXPORT Serializer {
  public:
    Serializer();
    ~Serializer();

     /**
      * This method generates a textual JSON representation and outputs it to the
      * passed in I/O Device.
      * @param variant The JSON document in its in-memory representation as generated by the
      * parser.
      * @param out Input output device
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true
      */
    void serialize( const QVariant& variant, QIODevice* out, bool* ok);

    /**
      * This is a method provided for convenience. It turns the passed in in-memory
      * representation of the JSON document into a textual one, which is returned.
      * If the returned string is empty, the document was empty. If it was null, there
      * was a parsing error.
      *
      * @param variant The JSON document in its in-memory representation as generated by the
      * parser.
      *
      * \deprecated This method is going to be removed with the next major release of QJson.
      */
    QByteArray serialize( const QVariant& variant);

    /**
      * This is a method provided for convenience. It turns the passed in in-memory
      * representation of the JSON document into a textual one, which is returned.
      * If the returned string is empty, the document was empty. If it was null, there
      * was a parsing error.
      *
      * @param variant The JSON document in its in-memory representation as generated by the
      * parser.
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true
      */
    QByteArray serialize( const QVariant& variant, bool *ok);

    /**
     * Allow or disallow writing of NaN and/or Infinity (as an extension to QJson)
     */
    void allowSpecialNumbers(bool allow);

    /**
     * Is Nan and/or Infinity allowed?
     */
    bool specialNumbersAllowed() const;

    /**
     * set output indentation mode as defined in QJson::IndentMode
     */
    void setIndentMode(IndentMode mode = QJson::IndentNone);


    /**
    * set double precision used while converting Double
    * \sa QByteArray::number
    */
    void setDoublePrecision(int precision);

    /**
     * Returns one of the indentation modes defined in QJson::IndentMode
     */
    IndentMode indentMode() const;

    /**
     * Returns the error message
     */
    QString errorMessage() const;

  private:
    Q_DISABLE_COPY(Serializer)
    class SerializerPrivate;
    SerializerPrivate* const d;
  };Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializer.h:112
  2021-07-25 15:45:26  [ main:1276 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 15:45:26  [ main:1277 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\frame.hpp:11
  2021-07-25 15:45:26  [ main:1277 ] - [ ERROR ]  parsing error 
private slots:
    void loadFinished(bool ok);
  2021-07-25 15:45:26  [ main:1277 ] - [ ERROR ]  warning: parse error private slots:
    void loadFinished(bool ok);Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\frame.hpp:38
  2021-07-25 15:45:26  [ main:1298 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-25 15:45:26  [ main:1298 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\image.hpp:9
  2021-07-25 15:45:26  [ main:1321 ] - [ ERROR ]  warning: parse error Q_FOREACH( const QByteArray& i, list ) {
    if ( !res.isEmpty() )
      res += sep;
    res += i;
  }Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializer.cpp:55
  2021-07-25 15:45:26  [ main:1322 ] - [ ERROR ]  warning: parse error Q_FOREACH( const QVariant& var, list )
    {
      indentLevel++;
      QByteArray serializedValue = serialize( var, ok, indentLevel);
      indentLevel--;
      if ( !*ok ) {
        break;
      }
      values << serializedValue;
    }Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializer.cpp:72
  2021-07-25 15:45:26  [ main:1367 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\phantompy.hpp
  2021-07-25 15:45:26  [ main:1368 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\context.cpp
  2021-07-25 15:45:26  [ main:1369 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\context.hpp
  2021-07-25 15:45:26  [ main:1370 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\cookiejar.cpp
  2021-07-25 15:45:26  [ main:1371 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\cookiejar.hpp
  2021-07-25 15:45:26  [ main:1372 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\eventprocessor.cpp
  2021-07-25 15:45:26  [ main:1372 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\eventprocessor.hpp
  2021-07-25 15:45:26  [ main:1373 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\frame.cpp
  2021-07-25 15:45:26  [ main:1374 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\frame.hpp
  2021-07-25 15:45:26  [ main:1375 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\image.cpp
  2021-07-25 15:45:26  [ main:1376 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\image.hpp
  2021-07-25 15:45:26  [ main:1376 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\networkmanager.cpp
  2021-07-25 15:45:26  [ main:1377 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\networkmanager.hpp
  2021-07-25 15:45:26  [ main:1378 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\networkmanagerproxy.cpp
  2021-07-25 15:45:26  [ main:1379 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\networkmanagerproxy.hpp
  2021-07-25 15:45:26  [ main:1379 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\networktimeout.cpp
  2021-07-25 15:45:26  [ main:1380 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\networktimeout.hpp
  2021-07-25 15:45:26  [ main:1381 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\page.cpp
  2021-07-25 15:45:26  [ main:1381 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\page.hpp
  2021-07-25 15:45:26  [ main:1382 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\timeout.cpp
  2021-07-25 15:45:26  [ main:1383 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\timeout.hpp
  2021-07-25 15:45:26  [ main:1384 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\webelement.cpp
  2021-07-25 15:45:26  [ main:1384 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\webelement.hpp
  2021-07-25 15:45:26  [ main:1385 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\webelementcollection.cpp
  2021-07-25 15:45:26  [ main:1386 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\webelementcollection.hpp
  2021-07-25 15:45:26  [ main:1387 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\FlexLexer.h
  2021-07-25 15:45:26  [ main:1388 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\json_parser.cc
  2021-07-25 15:45:26  [ main:1448 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\json_parser.hh
  2021-07-25 15:45:26  [ main:1449 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\json_scanner.cc
  2021-07-25 15:45:26  [ main:1449 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\json_scanner.cpp
  2021-07-25 15:45:26  [ main:1450 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\json_scanner.h
  2021-07-25 15:45:26  [ main:1451 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\location.hh
  2021-07-25 15:45:26  [ main:1452 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\parser.cpp
  2021-07-25 15:45:26  [ main:1453 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\parser.h
  2021-07-25 15:45:26  [ main:1453 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\parserrunnable.cpp
  2021-07-25 15:45:26  [ main:1460 ] - [ ERROR ]  parsing error 
QT_BEGIN_NAMESPACE
  2021-07-25 15:45:26  [ main:1461 ] - [ ERROR ]  warning: parse error QT_BEGIN_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\parserrunnable.h:29
  2021-07-25 15:45:26  [ main:1461 ] - [ ERROR ]  parsing error 
QT_END_NAMESPACE
  2021-07-25 15:45:26  [ main:1461 ] - [ ERROR ]  warning: parse error QT_END_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\parserrunnable.h:31
  2021-07-25 15:45:26  [ main:1461 ] - [ ERROR ]  parsing error 
class QJSON_EXPORT ParserRunnable  : public QObject, public QRunnable
  {
    Q_OBJECT
    public:
      explicit ParserRunnable(QObject* parent = 0);
      ~ParserRunnable();

      void setData( const QByteArray& data );

      void run();

    Q_SIGNALS:
      /**
      * This signal is emitted when the parsing process has been completed
      * @param json contains the result of the parsing
      * @param ok if a parsing error occurs ok is set to false, otherwise it's set to true.
      * @param error_msg contains a string explaining the failure reason
      **/
      void parsingFinished(const QVariant& json, bool ok, const QString& error_msg);

    private:
      Q_DISABLE_COPY(ParserRunnable)
      class Private;
      Private* const d;
  };
  2021-07-25 15:45:26  [ main:1461 ] - [ ERROR ]  warning: parse error class QJSON_EXPORT ParserRunnable  : public QObject, public QRunnable
  {
    Q_OBJECT
    public:
      explicit ParserRunnable(QObject* parent = 0);
      ~ParserRunnable();

      void setData( const QByteArray& data );

      void run();

    Q_SIGNALS:
      /**
      * This signal is emitted when the parsing process has been completed
      * @param json contains the result of the parsing
      * @param ok if a parsing error occurs ok is set to false, otherwise it's set to true.
      * @param error_msg contains a string explaining the failure reason
      **/
      void parsingFinished(const QVariant& json, bool ok, const QString& error_msg);

    private:
      Q_DISABLE_COPY(ParserRunnable)
      class Private;
      Private* const d;
  };Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\parserrunnable.h:37
  2021-07-25 15:45:26  [ main:1465 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\parserrunnable.h
  2021-07-25 15:45:26  [ main:1466 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\parser_p.h
  2021-07-25 15:45:26  [ main:1467 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\position.hh
  2021-07-25 15:45:26  [ main:1477 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\qjson_debug.h
  2021-07-25 15:45:26  [ main:1477 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\qjson_export.h
  2021-07-25 15:45:26  [ main:1478 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\qobjecthelper.cpp
  2021-07-25 15:45:26  [ main:1486 ] - [ ERROR ]  parsing error 
QT_BEGIN_NAMESPACE
  2021-07-25 15:45:26  [ main:1487 ] - [ ERROR ]  warning: parse error QT_BEGIN_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\qobjecthelper.h:30
  2021-07-25 15:45:26  [ main:1487 ] - [ ERROR ]  parsing error 
QT_END_NAMESPACE
  2021-07-25 15:45:26  [ main:1487 ] - [ ERROR ]  warning: parse error QT_END_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\qobjecthelper.h:32
  2021-07-25 15:45:26  [ main:1487 ] - [ ERROR ]  parsing error 
class QJSON_EXPORT QObjectHelper {
    public:
      QObjectHelper();
      ~QObjectHelper();

    /**
    * This method converts a QObject instance into a QVariantMap.
    *
    * @param object The QObject instance to be converted.
    * @param ignoredProperties Properties that won't be converted.
    */
    static QVariantMap qobject2qvariant( const QObject* object,
                                  const QStringList& ignoredProperties = QStringList(QString(QLatin1String("objectName"))));

    /**
    * This method converts a QVariantMap instance into a QObject
    *
    * @param variant Attributes to assign to the object.
    * @param object The QObject instance to update.
    */
    static void qvariant2qobject(const QVariantMap& variant, QObject* object);

    private:
      Q_DISABLE_COPY(QObjectHelper)
      class QObjectHelperPrivate;
      QObjectHelperPrivate* const d;
  };
  2021-07-25 15:45:26  [ main:1487 ] - [ ERROR ]  warning: parse error class QJSON_EXPORT QObjectHelper {
    public:
      QObjectHelper();
      ~QObjectHelper();

    /**
    * This method converts a QObject instance into a QVariantMap.
    *
    * @param object The QObject instance to be converted.
    * @param ignoredProperties Properties that won't be converted.
    */
    static QVariantMap qobject2qvariant( const QObject* object,
                                  const QStringList& ignoredProperties = QStringList(QString(QLatin1String("objectName"))));

    /**
    * This method converts a QVariantMap instance into a QObject
    *
    * @param variant Attributes to assign to the object.
    * @param object The QObject instance to update.
    */
    static void qvariant2qobject(const QVariantMap& variant, QObject* object);

    private:
      Q_DISABLE_COPY(QObjectHelper)
      class QObjectHelperPrivate;
      QObjectHelperPrivate* const d;
  };Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\qobjecthelper.h:118
  2021-07-25 15:45:26  [ main:1492 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\qobjecthelper.h
  2021-07-25 15:45:26  [ main:1493 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\serializer.cpp
  2021-07-25 15:45:26  [ main:1494 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\serializer.h
  2021-07-25 15:45:26  [ main:1495 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\serializerrunnable.cpp
  2021-07-25 15:45:26  [ main:1502 ] - [ ERROR ]  parsing error 
QT_BEGIN_NAMESPACE
  2021-07-25 15:45:26  [ main:1502 ] - [ ERROR ]  warning: parse error QT_BEGIN_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializerrunnable.h:29
  2021-07-25 15:45:26  [ main:1503 ] - [ ERROR ]  parsing error 
QT_END_NAMESPACE
  2021-07-25 15:45:26  [ main:1503 ] - [ ERROR ]  warning: parse error QT_END_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializerrunnable.h:33
  2021-07-25 15:45:26  [ main:1503 ] - [ ERROR ]  parsing error 
class QJSON_EXPORT SerializerRunnable  : public QObject, public QRunnable
  {
    Q_OBJECT
    public:
      explicit SerializerRunnable(QObject* parent = 0);
      ~SerializerRunnable();

      /**
       * Sets the json object to serialize.
       *
       * @param json QVariant containing the json representation to be serialized
       */
      void setJsonObject( const QVariant& json );

      /* reimp */ void run();

    Q_SIGNALS:
      /**
      * This signal is emitted when the serialization process has been completed
      * @param serialized contains the result of the serialization
      * @param ok if a serialization error occurs ok is set to false, otherwise it's set to true.
      * @param error_msg contains a string explaining the failure reason
      **/
      void parsingFinished(const QByteArray& serialized, bool ok, const QString& error_msg);

    private:
      Q_DISABLE_COPY(SerializerRunnable)
      class Private;
      Private* const d;
  };
  2021-07-25 15:45:26  [ main:1503 ] - [ ERROR ]  warning: parse error class QJSON_EXPORT SerializerRunnable  : public QObject, public QRunnable
  {
    Q_OBJECT
    public:
      explicit SerializerRunnable(QObject* parent = 0);
      ~SerializerRunnable();

      /**
       * Sets the json object to serialize.
       *
       * @param json QVariant containing the json representation to be serialized
       */
      void setJsonObject( const QVariant& json );

      /* reimp */ void run();

    Q_SIGNALS:
      /**
      * This signal is emitted when the serialization process has been completed
      * @param serialized contains the result of the serialization
      * @param ok if a serialization error occurs ok is set to false, otherwise it's set to true.
      * @param error_msg contains a string explaining the failure reason
      **/
      void parsingFinished(const QByteArray& serialized, bool ok, const QString& error_msg);

    private:
      Q_DISABLE_COPY(SerializerRunnable)
      class Private;
      Private* const d;
  };Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializerrunnable.h:39
  2021-07-25 15:45:26  [ main:1507 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\serializerrunnable.h
  2021-07-25 15:45:26  [ main:1508 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\stack.hh
  2021-07-25 15:45:26  [ main:1511 ] - [ INFO ]  start dependency
  2021-07-25 15:45:27  [ main:1596 ] - [ INFO ]  includenum:127
  2021-07-25 15:45:27  [ main:1597 ] - [ INFO ]  definenum:81
  2021-07-25 15:45:27  [ main:1597 ] - [ INFO ]  callnum:45
  2021-07-25 15:45:27  [ main:1597 ] - [ INFO ]  returnnum:159
  2021-07-25 15:45:27  [ main:1597 ] - [ INFO ]  parameternum:614
  2021-07-25 15:45:27  [ main:1597 ] - [ INFO ]  extendnum:1
  2021-07-25 15:45:27  [ main:1597 ] - [ INFO ]  overridenum:1
  2021-07-25 15:45:27  [ main:1706 ] - [ INFO ]  Process finish!
  2021-07-25 15:55:51  [ main:0 ] - [ INFO ]  parseC:\Users\ding7\Desktop\newtest\phantompy\context.cpp
  2021-07-25 15:55:52  [ main:408 ] - [ ERROR ]  parsing error 

  2021-07-25 15:55:52  [ main:468 ] - [ ERROR ]  warning: parse error Syntax error in file: C:\Users\ding7\Desktop\newtest\phantompy\context.cpp:14
  2021-07-25 15:55:52  [ main:469 ] - [ INFO ]  parseC:\Users\ding7\Desktop\newtest\phantompy\phantompy.cpp
  2021-07-25 15:55:52  [ main:482 ] - [ INFO ]  start dependency
  2021-07-25 15:55:52  [ main:484 ] - [ INFO ]  includenum:0
  2021-07-25 15:55:52  [ main:485 ] - [ INFO ]  definenum:0
  2021-07-25 15:55:52  [ main:485 ] - [ INFO ]  callnum:0
  2021-07-25 15:55:52  [ main:485 ] - [ INFO ]  returnnum:1
  2021-07-25 15:55:52  [ main:485 ] - [ INFO ]  parameternum:3
  2021-07-25 15:55:52  [ main:485 ] - [ INFO ]  extendnum:0
  2021-07-25 15:55:52  [ main:485 ] - [ INFO ]  overridenum:0
  2021-07-25 15:55:52  [ main:538 ] - [ INFO ]  Process finish!
  2021-07-25 15:56:29  [ main:0 ] - [ INFO ]  parseC:\Users\ding7\Desktop\newtest\phantompy\context.cpp
  2021-07-25 15:56:30  [ main:413 ] - [ INFO ]  parseC:\Users\ding7\Desktop\newtest\phantompy\phantompy.cpp
  2021-07-25 15:56:30  [ main:425 ] - [ INFO ]  start dependency
  2021-07-25 15:56:30  [ main:428 ] - [ INFO ]  includenum:0
  2021-07-25 15:56:30  [ main:428 ] - [ INFO ]  definenum:0
  2021-07-25 15:56:30  [ main:428 ] - [ INFO ]  callnum:0
  2021-07-25 15:56:30  [ main:428 ] - [ INFO ]  returnnum:1
  2021-07-25 15:56:30  [ main:428 ] - [ INFO ]  parameternum:3
  2021-07-25 15:56:30  [ main:428 ] - [ INFO ]  extendnum:0
  2021-07-25 15:56:30  [ main:428 ] - [ INFO ]  overridenum:0
  2021-07-25 15:56:30  [ main:479 ] - [ INFO ]  Process finish!
  2021-07-25 15:57:15  [ main:0 ] - [ INFO ]  parseC:\Users\ding7\Desktop\newtest\phantompy\context.cpp
  2021-07-25 15:57:16  [ main:433 ] - [ INFO ]  parseC:\Users\ding7\Desktop\newtest\phantompy\context.hpp
  2021-07-25 15:57:16  [ main:434 ] - [ INFO ]  parseC:\Users\ding7\Desktop\newtest\phantompy\phantompy.cpp
  2021-07-25 15:57:16  [ main:443 ] - [ INFO ]  start dependency
  2021-07-25 15:57:16  [ main:447 ] - [ INFO ]  includenum:4
  2021-07-25 15:57:16  [ main:447 ] - [ INFO ]  definenum:0
  2021-07-25 15:57:16  [ main:447 ] - [ INFO ]  callnum:0
  2021-07-25 15:57:16  [ main:447 ] - [ INFO ]  returnnum:1
  2021-07-25 15:57:16  [ main:447 ] - [ INFO ]  parameternum:14
  2021-07-25 15:57:16  [ main:447 ] - [ INFO ]  extendnum:0
  2021-07-25 15:57:16  [ main:447 ] - [ INFO ]  overridenum:0
  2021-07-25 15:57:16  [ main:501 ] - [ INFO ]  Process finish!
  2021-07-25 15:57:46  [ main:0 ] - [ INFO ]  parseC:\Users\ding7\Desktop\newtest\phantompy\context.cpp
  2021-07-25 15:57:46  [ main:439 ] - [ INFO ]  parseC:\Users\ding7\Desktop\newtest\phantompy\context.hpp
  2021-07-25 15:57:46  [ main:440 ] - [ INFO ]  parseC:\Users\ding7\Desktop\newtest\phantompy\phantompy.cpp
  2021-07-25 15:57:46  [ main:449 ] - [ INFO ]  start dependency
  2021-07-25 15:57:46  [ main:452 ] - [ INFO ]  includenum:4
  2021-07-25 15:57:46  [ main:452 ] - [ INFO ]  definenum:0
  2021-07-25 15:57:46  [ main:453 ] - [ INFO ]  callnum:0
  2021-07-25 15:57:46  [ main:453 ] - [ INFO ]  returnnum:1
  2021-07-25 15:57:46  [ main:453 ] - [ INFO ]  parameternum:14
  2021-07-25 15:57:46  [ main:453 ] - [ INFO ]  extendnum:0
  2021-07-25 15:57:46  [ main:453 ] - [ INFO ]  overridenum:0
  2021-07-25 15:57:46  [ main:507 ] - [ INFO ]  Process finish!
  2021-07-25 15:58:25  [ main:0 ] - [ INFO ]  parseC:\Users\ding7\Desktop\newtest\phantompy\context.cpp
  2021-07-25 15:58:26  [ main:448 ] - [ INFO ]  parseC:\Users\ding7\Desktop\newtest\phantompy\context.hpp
  2021-07-25 15:58:26  [ main:448 ] - [ INFO ]  parseC:\Users\ding7\Desktop\newtest\phantompy\phantompy.cpp
  2021-07-25 15:58:26  [ main:458 ] - [ INFO ]  start dependency
  2021-07-25 15:58:26  [ main:462 ] - [ INFO ]  includenum:4
  2021-07-25 15:58:26  [ main:463 ] - [ INFO ]  definenum:0
  2021-07-25 15:58:26  [ main:463 ] - [ INFO ]  callnum:0
  2021-07-25 15:58:26  [ main:463 ] - [ INFO ]  returnnum:1
  2021-07-25 15:58:26  [ main:463 ] - [ INFO ]  parameternum:14
  2021-07-25 15:58:26  [ main:463 ] - [ INFO ]  extendnum:0
  2021-07-25 15:58:26  [ main:463 ] - [ INFO ]  overridenum:0
  2021-07-25 15:58:26  [ main:519 ] - [ INFO ]  Process finish!
  2021-07-25 15:58:47  [ main:0 ] - [ INFO ]  parseC:\Users\ding7\Desktop\newtest\phantompy\context.cpp
  2021-07-25 15:58:47  [ main:436 ] - [ INFO ]  parseC:\Users\ding7\Desktop\newtest\phantompy\context.hpp
  2021-07-25 15:58:47  [ main:436 ] - [ INFO ]  parseC:\Users\ding7\Desktop\newtest\phantompy\phantompy.cpp
  2021-07-25 15:58:47  [ main:446 ] - [ INFO ]  start dependency
  2021-07-25 15:58:47  [ main:450 ] - [ INFO ]  includenum:4
  2021-07-25 15:58:47  [ main:450 ] - [ INFO ]  definenum:0
  2021-07-25 15:58:47  [ main:450 ] - [ INFO ]  callnum:0
  2021-07-25 15:58:47  [ main:450 ] - [ INFO ]  returnnum:1
  2021-07-25 15:58:47  [ main:450 ] - [ INFO ]  parameternum:14
  2021-07-25 15:58:47  [ main:450 ] - [ INFO ]  extendnum:0
  2021-07-25 15:58:47  [ main:451 ] - [ INFO ]  overridenum:0
  2021-07-25 15:58:47  [ main:505 ] - [ INFO ]  Process finish!
  2021-07-25 15:59:26  [ main:0 ] - [ INFO ]  parseC:\Users\ding7\Desktop\newtest\phantompy\context.cpp
  2021-07-25 15:59:26  [ main:441 ] - [ INFO ]  parseC:\Users\ding7\Desktop\newtest\phantompy\context.hpp
  2021-07-25 15:59:26  [ main:441 ] - [ INFO ]  parseC:\Users\ding7\Desktop\newtest\phantompy\phantompy.cpp
  2021-07-25 15:59:27  [ main:450 ] - [ INFO ]  start dependency
  2021-07-25 15:59:27  [ main:454 ] - [ INFO ]  includenum:4
  2021-07-25 15:59:27  [ main:455 ] - [ INFO ]  definenum:0
  2021-07-25 15:59:27  [ main:455 ] - [ INFO ]  callnum:0
  2021-07-25 15:59:27  [ main:455 ] - [ INFO ]  returnnum:1
  2021-07-25 15:59:27  [ main:455 ] - [ INFO ]  parameternum:14
  2021-07-25 15:59:27  [ main:455 ] - [ INFO ]  extendnum:0
  2021-07-25 15:59:27  [ main:455 ] - [ INFO ]  overridenum:0
  2021-07-25 15:59:27  [ main:508 ] - [ INFO ]  Process finish!
  2021-07-25 16:00:22  [ main:0 ] - [ INFO ]  parseC:\Users\ding7\Desktop\newtest\phantompy\context.cpp
  2021-07-25 16:00:23  [ main:437 ] - [ INFO ]  parseC:\Users\ding7\Desktop\newtest\phantompy\context.hpp
  2021-07-25 16:00:23  [ main:438 ] - [ INFO ]  parseC:\Users\ding7\Desktop\newtest\phantompy\phantompy.cpp
  2021-07-25 16:00:23  [ main:447 ] - [ INFO ]  start dependency
  2021-07-25 16:00:23  [ main:451 ] - [ INFO ]  includenum:4
  2021-07-25 16:00:23  [ main:451 ] - [ INFO ]  definenum:0
  2021-07-25 16:00:23  [ main:451 ] - [ INFO ]  callnum:0
  2021-07-25 16:00:23  [ main:451 ] - [ INFO ]  returnnum:1
  2021-07-25 16:00:23  [ main:451 ] - [ INFO ]  parameternum:14
  2021-07-25 16:00:23  [ main:451 ] - [ INFO ]  extendnum:0
  2021-07-25 16:00:23  [ main:451 ] - [ INFO ]  overridenum:0
  2021-07-25 16:00:23  [ main:512 ] - [ INFO ]  Process finish!
  2021-07-25 16:02:59  [ main:0 ] - [ INFO ]  parseC:\Users\ding7\Desktop\newtest\phantompy\context.cpp
  2021-07-25 16:03:00  [ main:788 ] - [ INFO ]  parseC:\Users\ding7\Desktop\newtest\phantompy\context.hpp
  2021-07-25 16:03:00  [ main:789 ] - [ INFO ]  parseC:\Users\ding7\Desktop\newtest\phantompy\phantompy.cpp
  2021-07-25 16:03:00  [ main:806 ] - [ INFO ]  start dependency
  2021-07-25 16:03:00  [ main:811 ] - [ INFO ]  includenum:4
  2021-07-25 16:03:00  [ main:811 ] - [ INFO ]  definenum:0
  2021-07-25 16:03:00  [ main:811 ] - [ INFO ]  callnum:0
  2021-07-25 16:03:00  [ main:811 ] - [ INFO ]  returnnum:1
  2021-07-25 16:03:00  [ main:811 ] - [ INFO ]  parameternum:14
  2021-07-25 16:03:00  [ main:811 ] - [ INFO ]  extendnum:0
  2021-07-25 16:03:00  [ main:811 ] - [ INFO ]  overridenum:0
  2021-07-25 16:03:00  [ main:898 ] - [ INFO ]  Process finish!
  2021-07-25 16:03:52  [ main:0 ] - [ INFO ]  parseC:\Users\ding7\Desktop\newtest\phantompy\context.cpp
  2021-07-25 16:03:52  [ main:434 ] - [ INFO ]  parseC:\Users\ding7\Desktop\newtest\phantompy\context.hpp
  2021-07-25 16:03:52  [ main:435 ] - [ INFO ]  parseC:\Users\ding7\Desktop\newtest\phantompy\phantompy.cpp
  2021-07-25 16:03:52  [ main:445 ] - [ INFO ]  start dependency
  2021-07-25 16:03:52  [ main:448 ] - [ INFO ]  includenum:4
  2021-07-25 16:03:52  [ main:448 ] - [ INFO ]  definenum:0
  2021-07-25 16:03:52  [ main:448 ] - [ INFO ]  callnum:0
  2021-07-25 16:03:52  [ main:448 ] - [ INFO ]  returnnum:1
  2021-07-25 16:03:52  [ main:448 ] - [ INFO ]  parameternum:14
  2021-07-25 16:03:52  [ main:448 ] - [ INFO ]  extendnum:0
  2021-07-25 16:03:52  [ main:448 ] - [ INFO ]  overridenum:0
  2021-07-25 16:03:52  [ main:501 ] - [ INFO ]  Process finish!
  2021-07-25 16:05:02  [ main:0 ] - [ INFO ]  parseC:\Users\ding7\Desktop\newtest\phantompy\context.cpp
  2021-07-25 16:05:02  [ main:460 ] - [ INFO ]  parseC:\Users\ding7\Desktop\newtest\phantompy\context.hpp
  2021-07-25 16:05:02  [ main:460 ] - [ INFO ]  parseC:\Users\ding7\Desktop\newtest\phantompy\phantompy.cpp
  2021-07-25 16:05:02  [ main:467 ] - [ INFO ]  start dependency
  2021-07-25 16:05:02  [ main:471 ] - [ INFO ]  includenum:4
  2021-07-25 16:05:02  [ main:471 ] - [ INFO ]  definenum:0
  2021-07-25 16:05:02  [ main:471 ] - [ INFO ]  callnum:0
  2021-07-25 16:05:02  [ main:471 ] - [ INFO ]  returnnum:1
  2021-07-25 16:05:02  [ main:471 ] - [ INFO ]  parameternum:17
  2021-07-25 16:05:02  [ main:471 ] - [ INFO ]  extendnum:0
  2021-07-25 16:05:02  [ main:471 ] - [ INFO ]  overridenum:0
  2021-07-25 16:05:02  [ main:524 ] - [ INFO ]  Process finish!
  2021-07-25 16:12:49  [ main:0 ] - [ INFO ]  parseC:\Users\ding7\Desktop\newtest\phantompy\context.cpp
  2021-07-25 16:12:50  [ main:442 ] - [ INFO ]  parseC:\Users\ding7\Desktop\newtest\phantompy\context.hpp
  2021-07-25 16:12:50  [ main:442 ] - [ INFO ]  parseC:\Users\ding7\Desktop\newtest\phantompy\phantompy.cpp
  2021-07-25 16:12:50  [ main:448 ] - [ INFO ]  start dependency
  2021-07-25 16:12:50  [ main:452 ] - [ INFO ]  includenum:4
  2021-07-25 16:12:50  [ main:452 ] - [ INFO ]  definenum:0
  2021-07-25 16:12:50  [ main:453 ] - [ INFO ]  callnum:0
  2021-07-25 16:12:50  [ main:453 ] - [ INFO ]  returnnum:1
  2021-07-25 16:12:50  [ main:453 ] - [ INFO ]  parameternum:17
  2021-07-25 16:12:50  [ main:453 ] - [ INFO ]  extendnum:0
  2021-07-25 16:12:50  [ main:453 ] - [ INFO ]  overridenum:0
  2021-07-25 16:12:50  [ main:509 ] - [ INFO ]  Process finish!
  2021-07-25 16:14:26  [ main:0 ] - [ INFO ]  parseC:\Users\ding7\Desktop\newtest\phantompy\context.cpp
  2021-07-25 16:14:26  [ main:450 ] - [ INFO ]  parseC:\Users\ding7\Desktop\newtest\phantompy\context.hpp
  2021-07-25 16:14:26  [ main:451 ] - [ INFO ]  parseC:\Users\ding7\Desktop\newtest\phantompy\phantompy.cpp
  2021-07-25 16:14:26  [ main:458 ] - [ INFO ]  start dependency
  2021-07-25 16:14:26  [ main:461 ] - [ INFO ]  includenum:4
  2021-07-25 16:14:26  [ main:461 ] - [ INFO ]  definenum:0
  2021-07-25 16:14:26  [ main:461 ] - [ INFO ]  callnum:0
  2021-07-25 16:14:26  [ main:461 ] - [ INFO ]  returnnum:1
  2021-07-25 16:14:26  [ main:461 ] - [ INFO ]  parameternum:17
  2021-07-25 16:14:26  [ main:462 ] - [ INFO ]  extendnum:0
  2021-07-25 16:14:26  [ main:462 ] - [ INFO ]  overridenum:0
  2021-07-25 16:14:26  [ main:518 ] - [ INFO ]  Process finish!
  2021-07-25 16:15:23  [ main:0 ] - [ INFO ]  parseC:\Users\ding7\Desktop\newtest\phantompy\context.cpp
  2021-07-25 16:15:24  [ main:450 ] - [ INFO ]  parseC:\Users\ding7\Desktop\newtest\phantompy\context.hpp
  2021-07-25 16:15:24  [ main:450 ] - [ INFO ]  parseC:\Users\ding7\Desktop\newtest\phantompy\phantompy.cpp
  2021-07-25 16:15:24  [ main:457 ] - [ INFO ]  start dependency
  2021-07-25 16:15:24  [ main:461 ] - [ INFO ]  includenum:4
  2021-07-25 16:15:24  [ main:461 ] - [ INFO ]  definenum:0
  2021-07-25 16:15:24  [ main:461 ] - [ INFO ]  callnum:0
  2021-07-25 16:15:24  [ main:461 ] - [ INFO ]  returnnum:1
  2021-07-25 16:15:24  [ main:461 ] - [ INFO ]  parameternum:17
  2021-07-25 16:15:24  [ main:461 ] - [ INFO ]  extendnum:0
  2021-07-25 16:15:24  [ main:461 ] - [ INFO ]  overridenum:0
  2021-07-25 16:15:24  [ main:517 ] - [ INFO ]  Process finish!
  2021-07-25 16:15:35  [ main:0 ] - [ INFO ]  parseC:\Users\ding7\Desktop\newtest\phantompy\context.cpp
  2021-07-25 16:15:35  [ main:448 ] - [ INFO ]  parseC:\Users\ding7\Desktop\newtest\phantompy\context.hpp
  2021-07-25 16:15:35  [ main:449 ] - [ INFO ]  parseC:\Users\ding7\Desktop\newtest\phantompy\phantompy.cpp
  2021-07-25 16:15:35  [ main:455 ] - [ INFO ]  start dependency
  2021-07-25 16:15:35  [ main:459 ] - [ INFO ]  includenum:4
  2021-07-25 16:15:35  [ main:459 ] - [ INFO ]  definenum:0
  2021-07-25 16:15:35  [ main:459 ] - [ INFO ]  callnum:0
  2021-07-25 16:15:35  [ main:459 ] - [ INFO ]  returnnum:1
  2021-07-25 16:15:35  [ main:459 ] - [ INFO ]  parameternum:17
  2021-07-25 16:15:35  [ main:459 ] - [ INFO ]  extendnum:0
  2021-07-25 16:15:35  [ main:459 ] - [ INFO ]  overridenum:0
  2021-07-25 16:15:35  [ main:515 ] - [ INFO ]  Process finish!
  2021-07-25 16:16:01  [ main:0 ] - [ INFO ]  parseC:\Users\ding7\Desktop\newtest\phantompy\context.cpp
  2021-07-25 16:16:02  [ main:446 ] - [ INFO ]  parseC:\Users\ding7\Desktop\newtest\phantompy\context.hpp
  2021-07-25 16:16:02  [ main:446 ] - [ INFO ]  parseC:\Users\ding7\Desktop\newtest\phantompy\phantompy.cpp
  2021-07-25 16:16:02  [ main:453 ] - [ INFO ]  start dependency
  2021-07-25 16:16:02  [ main:456 ] - [ INFO ]  includenum:4
  2021-07-25 16:16:02  [ main:456 ] - [ INFO ]  definenum:0
  2021-07-25 16:16:02  [ main:456 ] - [ INFO ]  callnum:0
  2021-07-25 16:16:02  [ main:456 ] - [ INFO ]  returnnum:1
  2021-07-25 16:16:02  [ main:456 ] - [ INFO ]  parameternum:17
  2021-07-25 16:16:02  [ main:456 ] - [ INFO ]  extendnum:0
  2021-07-25 16:16:02  [ main:456 ] - [ INFO ]  overridenum:0
  2021-07-25 16:16:02  [ main:511 ] - [ INFO ]  Process finish!
  2021-07-25 16:16:22  [ main:1 ] - [ INFO ]  parseC:\Users\ding7\Desktop\newtest\phantompy\context.cpp
  2021-07-25 16:16:22  [ main:443 ] - [ INFO ]  parseC:\Users\ding7\Desktop\newtest\phantompy\context.hpp
  2021-07-25 16:16:22  [ main:444 ] - [ INFO ]  parseC:\Users\ding7\Desktop\newtest\phantompy\phantompy.cpp
  2021-07-25 16:16:22  [ main:451 ] - [ INFO ]  start dependency
  2021-07-25 16:16:22  [ main:454 ] - [ INFO ]  includenum:4
  2021-07-25 16:16:22  [ main:454 ] - [ INFO ]  definenum:0
  2021-07-25 16:16:22  [ main:454 ] - [ INFO ]  callnum:0
  2021-07-25 16:16:22  [ main:455 ] - [ INFO ]  returnnum:1
  2021-07-25 16:16:22  [ main:455 ] - [ INFO ]  parameternum:17
  2021-07-25 16:16:22  [ main:455 ] - [ INFO ]  extendnum:0
  2021-07-25 16:16:22  [ main:455 ] - [ INFO ]  overridenum:0
  2021-07-25 16:16:22  [ main:511 ] - [ INFO ]  Process finish!
  2021-07-25 16:22:58  [ main:0 ] - [ INFO ]  parseC:\Users\ding7\Desktop\newtest\phantompy\context.cpp
  2021-07-25 16:22:58  [ main:445 ] - [ INFO ]  parseC:\Users\ding7\Desktop\newtest\phantompy\context.hpp
  2021-07-25 16:22:58  [ main:446 ] - [ INFO ]  parseC:\Users\ding7\Desktop\newtest\phantompy\phantompy.cpp
  2021-07-25 16:22:58  [ main:454 ] - [ INFO ]  start dependency
  2021-07-25 16:22:58  [ main:457 ] - [ INFO ]  includenum:4
  2021-07-25 16:22:58  [ main:457 ] - [ INFO ]  definenum:0
  2021-07-25 16:22:58  [ main:457 ] - [ INFO ]  callnum:0
  2021-07-25 16:22:58  [ main:457 ] - [ INFO ]  returnnum:1
  2021-07-25 16:22:58  [ main:457 ] - [ INFO ]  parameternum:17
  2021-07-25 16:22:58  [ main:457 ] - [ INFO ]  extendnum:0
  2021-07-25 16:22:58  [ main:458 ] - [ INFO ]  overridenum:0
  2021-07-25 16:22:58  [ main:512 ] - [ INFO ]  Process finish!
  2021-07-25 16:23:54  [ main:0 ] - [ INFO ]  parseC:\Users\ding7\Desktop\newtest\phantompy\context.cpp
  2021-07-25 16:23:54  [ main:446 ] - [ INFO ]  parseC:\Users\ding7\Desktop\newtest\phantompy\context.hpp
  2021-07-25 16:23:54  [ main:446 ] - [ INFO ]  parseC:\Users\ding7\Desktop\newtest\phantompy\phantompy.cpp
  2021-07-25 16:23:54  [ main:452 ] - [ INFO ]  start dependency
  2021-07-25 16:24:55  [ main:0 ] - [ INFO ]  parseC:\Users\ding7\Desktop\newtest\phantompy\context.cpp
  2021-07-25 16:24:55  [ main:451 ] - [ INFO ]  parseC:\Users\ding7\Desktop\newtest\phantompy\context.hpp
  2021-07-25 16:24:55  [ main:452 ] - [ INFO ]  parseC:\Users\ding7\Desktop\newtest\phantompy\phantompy.cpp
  2021-07-25 16:24:55  [ main:459 ] - [ INFO ]  start dependency
  2021-07-25 16:26:01  [ main:0 ] - [ INFO ]  parseC:\Users\ding7\Desktop\newtest\phantompy\context.cpp
  2021-07-25 16:26:02  [ main:444 ] - [ INFO ]  parseC:\Users\ding7\Desktop\newtest\phantompy\context.hpp
  2021-07-25 16:26:02  [ main:445 ] - [ INFO ]  parseC:\Users\ding7\Desktop\newtest\phantompy\phantompy.cpp
  2021-07-25 16:26:02  [ main:451 ] - [ INFO ]  start dependency
  2021-07-25 16:26:27  [ main:0 ] - [ INFO ]  parseC:\Users\ding7\Desktop\newtest\phantompy\context.cpp
  2021-07-25 16:26:28  [ main:450 ] - [ INFO ]  parseC:\Users\ding7\Desktop\newtest\phantompy\context.hpp
  2021-07-25 16:26:28  [ main:451 ] - [ INFO ]  parseC:\Users\ding7\Desktop\newtest\phantompy\phantompy.cpp
  2021-07-25 16:26:28  [ main:458 ] - [ INFO ]  start dependency
  2021-07-25 16:26:28  [ main:461 ] - [ INFO ]  includenum:4
  2021-07-25 16:26:28  [ main:461 ] - [ INFO ]  definenum:0
  2021-07-25 16:26:28  [ main:461 ] - [ INFO ]  callnum:0
  2021-07-25 16:26:28  [ main:461 ] - [ INFO ]  returnnum:1
  2021-07-25 16:26:28  [ main:461 ] - [ INFO ]  parameternum:17
  2021-07-25 16:26:28  [ main:462 ] - [ INFO ]  extendnum:0
  2021-07-25 16:26:28  [ main:462 ] - [ INFO ]  overridenum:0
  2021-07-25 16:26:28  [ main:525 ] - [ INFO ]  Process finish!
  2021-07-25 16:26:54  [ main:0 ] - [ INFO ]  parseC:\Users\ding7\Desktop\newtest\phantompy\context.cpp
  2021-07-25 16:26:54  [ main:440 ] - [ INFO ]  parseC:\Users\ding7\Desktop\newtest\phantompy\context.hpp
  2021-07-25 16:26:54  [ main:440 ] - [ INFO ]  parseC:\Users\ding7\Desktop\newtest\phantompy\phantompy.cpp
  2021-07-25 16:26:54  [ main:447 ] - [ INFO ]  start dependency
  2021-07-25 16:26:54  [ main:450 ] - [ INFO ]  includenum:4
  2021-07-25 16:26:54  [ main:450 ] - [ INFO ]  definenum:0
  2021-07-25 16:26:54  [ main:450 ] - [ INFO ]  callnum:0
  2021-07-25 16:26:54  [ main:450 ] - [ INFO ]  returnnum:1
  2021-07-25 16:26:54  [ main:450 ] - [ INFO ]  parameternum:17
  2021-07-25 16:26:54  [ main:451 ] - [ INFO ]  extendnum:0
  2021-07-25 16:26:54  [ main:451 ] - [ INFO ]  overridenum:0
  2021-07-25 16:26:54  [ main:506 ] - [ INFO ]  Process finish!
  2021-07-25 16:27:42  [ main:0 ] - [ INFO ]  parseC:\Users\ding7\Desktop\newtest\phantompy\context.cpp
  2021-07-25 16:27:42  [ main:445 ] - [ INFO ]  parseC:\Users\ding7\Desktop\newtest\phantompy\context.hpp
  2021-07-25 16:27:42  [ main:445 ] - [ INFO ]  parseC:\Users\ding7\Desktop\newtest\phantompy\phantompy.cpp
  2021-07-25 16:27:42  [ main:454 ] - [ INFO ]  start dependency
  2021-07-25 16:27:42  [ main:458 ] - [ INFO ]  includenum:4
  2021-07-25 16:27:42  [ main:458 ] - [ INFO ]  definenum:0
  2021-07-25 16:27:42  [ main:458 ] - [ INFO ]  callnum:0
  2021-07-25 16:27:42  [ main:458 ] - [ INFO ]  returnnum:1
  2021-07-25 16:27:42  [ main:458 ] - [ INFO ]  parameternum:17
  2021-07-25 16:27:42  [ main:458 ] - [ INFO ]  extendnum:0
  2021-07-25 16:27:42  [ main:458 ] - [ INFO ]  overridenum:0
  2021-07-25 16:27:42  [ main:514 ] - [ INFO ]  Process finish!
  2021-07-25 16:27:54  [ main:0 ] - [ INFO ]  parseC:\Users\ding7\Desktop\newtest\phantompy\context.cpp
  2021-07-25 16:27:55  [ main:438 ] - [ INFO ]  parseC:\Users\ding7\Desktop\newtest\phantompy\context.hpp
  2021-07-25 16:27:55  [ main:438 ] - [ INFO ]  parseC:\Users\ding7\Desktop\newtest\phantompy\phantompy.cpp
  2021-07-25 16:27:55  [ main:445 ] - [ INFO ]  start dependency
  2021-07-25 16:27:55  [ main:449 ] - [ INFO ]  includenum:4
  2021-07-25 16:27:55  [ main:449 ] - [ INFO ]  definenum:0
  2021-07-25 16:27:55  [ main:449 ] - [ INFO ]  callnum:0
  2021-07-25 16:27:55  [ main:449 ] - [ INFO ]  returnnum:1
  2021-07-25 16:27:55  [ main:449 ] - [ INFO ]  parameternum:17
  2021-07-25 16:27:55  [ main:449 ] - [ INFO ]  extendnum:0
  2021-07-25 16:27:55  [ main:449 ] - [ INFO ]  overridenum:0
  2021-07-25 16:27:55  [ main:502 ] - [ INFO ]  Process finish!
  2021-07-25 16:28:28  [ main:0 ] - [ INFO ]  parseC:\Users\ding7\Desktop\newtest\phantompy\context.cpp
  2021-07-25 16:28:29  [ main:452 ] - [ INFO ]  parseC:\Users\ding7\Desktop\newtest\phantompy\context.hpp
  2021-07-25 16:28:29  [ main:452 ] - [ INFO ]  parseC:\Users\ding7\Desktop\newtest\phantompy\phantompy.cpp
  2021-07-25 16:28:29  [ main:460 ] - [ INFO ]  start dependency
  2021-07-25 16:28:29  [ main:463 ] - [ INFO ]  includenum:4
  2021-07-25 16:28:29  [ main:464 ] - [ INFO ]  definenum:0
  2021-07-25 16:28:29  [ main:464 ] - [ INFO ]  callnum:0
  2021-07-25 16:28:29  [ main:464 ] - [ INFO ]  returnnum:1
  2021-07-25 16:28:29  [ main:464 ] - [ INFO ]  parameternum:17
  2021-07-25 16:28:29  [ main:464 ] - [ INFO ]  extendnum:0
  2021-07-25 16:28:29  [ main:464 ] - [ INFO ]  overridenum:0
  2021-07-25 16:28:29  [ main:522 ] - [ INFO ]  Process finish!
  2021-07-25 16:28:45  [ main:0 ] - [ INFO ]  parseC:\Users\ding7\Desktop\newtest\phantompy\context.cpp
  2021-07-25 16:28:45  [ main:446 ] - [ INFO ]  parseC:\Users\ding7\Desktop\newtest\phantompy\context.hpp
  2021-07-25 16:28:46  [ main:447 ] - [ INFO ]  parseC:\Users\ding7\Desktop\newtest\phantompy\phantompy.cpp
  2021-07-25 16:28:46  [ main:453 ] - [ INFO ]  start dependency
  2021-07-25 16:28:46  [ main:457 ] - [ INFO ]  includenum:4
  2021-07-25 16:28:46  [ main:457 ] - [ INFO ]  definenum:0
  2021-07-25 16:28:46  [ main:457 ] - [ INFO ]  callnum:0
  2021-07-25 16:28:46  [ main:457 ] - [ INFO ]  returnnum:1
  2021-07-25 16:28:46  [ main:457 ] - [ INFO ]  parameternum:17
  2021-07-25 16:28:46  [ main:457 ] - [ INFO ]  extendnum:0
  2021-07-25 16:28:46  [ main:457 ] - [ INFO ]  overridenum:0
  2021-07-25 16:28:46  [ main:511 ] - [ INFO ]  Process finish!
  2021-07-25 16:29:03  [ main:0 ] - [ INFO ]  parseC:\Users\ding7\Desktop\newtest\phantompy\context.cpp
  2021-07-25 16:29:04  [ main:454 ] - [ INFO ]  parseC:\Users\ding7\Desktop\newtest\phantompy\context.hpp
  2021-07-25 16:29:04  [ main:455 ] - [ INFO ]  parseC:\Users\ding7\Desktop\newtest\phantompy\phantompy.cpp
  2021-07-25 16:29:04  [ main:463 ] - [ INFO ]  start dependency
  2021-07-25 16:29:04  [ main:467 ] - [ INFO ]  includenum:4
  2021-07-25 16:29:04  [ main:467 ] - [ INFO ]  definenum:0
  2021-07-25 16:29:04  [ main:467 ] - [ INFO ]  callnum:0
  2021-07-25 16:29:04  [ main:467 ] - [ INFO ]  returnnum:1
  2021-07-25 16:29:04  [ main:467 ] - [ INFO ]  parameternum:17
  2021-07-25 16:29:04  [ main:467 ] - [ INFO ]  extendnum:0
  2021-07-25 16:29:04  [ main:467 ] - [ INFO ]  overridenum:0
  2021-07-25 16:29:04  [ main:522 ] - [ INFO ]  Process finish!
  2021-07-25 16:29:37  [ main:1 ] - [ INFO ]  parseC:\Users\ding7\Desktop\newtest\phantompy\context.cpp
  2021-07-25 16:29:37  [ main:456 ] - [ INFO ]  parseC:\Users\ding7\Desktop\newtest\phantompy\context.hpp
  2021-07-25 16:29:37  [ main:456 ] - [ INFO ]  parseC:\Users\ding7\Desktop\newtest\phantompy\phantompy.cpp
  2021-07-25 16:29:37  [ main:465 ] - [ INFO ]  start dependency
  2021-07-25 16:29:37  [ main:468 ] - [ INFO ]  includenum:4
  2021-07-25 16:29:37  [ main:469 ] - [ INFO ]  definenum:0
  2021-07-25 16:29:37  [ main:469 ] - [ INFO ]  callnum:0
  2021-07-25 16:29:37  [ main:469 ] - [ INFO ]  returnnum:1
  2021-07-25 16:29:37  [ main:469 ] - [ INFO ]  parameternum:17
  2021-07-25 16:29:37  [ main:469 ] - [ INFO ]  extendnum:0
  2021-07-25 16:29:37  [ main:469 ] - [ INFO ]  overridenum:0
  2021-07-25 16:29:37  [ main:525 ] - [ INFO ]  Process finish!
  2021-07-25 16:30:51  [ main:0 ] - [ INFO ]  parseC:\Users\ding7\Desktop\newtest\phantompy\context.cpp
  2021-07-25 16:30:52  [ main:458 ] - [ INFO ]  parseC:\Users\ding7\Desktop\newtest\phantompy\context.hpp
  2021-07-25 16:30:52  [ main:459 ] - [ INFO ]  parseC:\Users\ding7\Desktop\newtest\phantompy\phantompy.cpp
  2021-07-25 16:30:52  [ main:466 ] - [ INFO ]  start dependency
  2021-07-25 16:30:52  [ main:469 ] - [ INFO ]  includenum:4
  2021-07-25 16:30:52  [ main:470 ] - [ INFO ]  definenum:0
  2021-07-25 16:30:52  [ main:470 ] - [ INFO ]  callnum:0
  2021-07-25 16:30:52  [ main:470 ] - [ INFO ]  returnnum:1
  2021-07-25 16:30:52  [ main:470 ] - [ INFO ]  parameternum:17
  2021-07-25 16:30:52  [ main:470 ] - [ INFO ]  extendnum:0
  2021-07-25 16:30:52  [ main:470 ] - [ INFO ]  overridenum:0
  2021-07-25 16:30:52  [ main:529 ] - [ INFO ]  Process finish!
  2021-07-25 16:31:06  [ main:0 ] - [ INFO ]  parseC:\Users\ding7\Desktop\newtest\phantompy\context.cpp
  2021-07-25 16:31:06  [ main:455 ] - [ INFO ]  parseC:\Users\ding7\Desktop\newtest\phantompy\context.hpp
  2021-07-25 16:31:06  [ main:456 ] - [ INFO ]  parseC:\Users\ding7\Desktop\newtest\phantompy\phantompy.cpp
  2021-07-25 16:31:06  [ main:463 ] - [ INFO ]  start dependency
  2021-07-25 16:31:06  [ main:466 ] - [ INFO ]  includenum:4
  2021-07-25 16:31:06  [ main:466 ] - [ INFO ]  definenum:0
  2021-07-25 16:31:06  [ main:466 ] - [ INFO ]  callnum:0
  2021-07-25 16:31:06  [ main:466 ] - [ INFO ]  returnnum:1
  2021-07-25 16:31:06  [ main:466 ] - [ INFO ]  parameternum:17
  2021-07-25 16:31:06  [ main:466 ] - [ INFO ]  extendnum:0
  2021-07-25 16:31:06  [ main:466 ] - [ INFO ]  overridenum:0
  2021-07-25 16:31:06  [ main:521 ] - [ INFO ]  Process finish!
  2021-07-25 16:31:19  [ main:0 ] - [ INFO ]  parseC:\Users\ding7\Desktop\newtest\phantompy\context.cpp
  2021-07-25 16:31:19  [ main:452 ] - [ INFO ]  parseC:\Users\ding7\Desktop\newtest\phantompy\context.hpp
  2021-07-25 16:31:19  [ main:452 ] - [ INFO ]  parseC:\Users\ding7\Desktop\newtest\phantompy\phantompy.cpp
  2021-07-25 16:31:19  [ main:462 ] - [ INFO ]  start dependency
  2021-07-25 16:31:19  [ main:465 ] - [ INFO ]  includenum:4
  2021-07-25 16:31:19  [ main:465 ] - [ INFO ]  definenum:0
  2021-07-25 16:31:19  [ main:465 ] - [ INFO ]  callnum:0
  2021-07-25 16:31:19  [ main:465 ] - [ INFO ]  returnnum:1
  2021-07-25 16:31:19  [ main:465 ] - [ INFO ]  parameternum:17
  2021-07-25 16:31:19  [ main:465 ] - [ INFO ]  extendnum:0
  2021-07-25 16:31:19  [ main:466 ] - [ INFO ]  overridenum:0
  2021-07-25 16:31:19  [ main:523 ] - [ INFO ]  Process finish!
  2021-07-25 16:32:01  [ main:0 ] - [ INFO ]  parseC:\Users\ding7\Desktop\newtest\phantompy\context.cpp
  2021-07-25 16:32:02  [ main:448 ] - [ INFO ]  parseC:\Users\ding7\Desktop\newtest\phantompy\context.hpp
  2021-07-25 16:32:02  [ main:449 ] - [ INFO ]  parseC:\Users\ding7\Desktop\newtest\phantompy\phantompy.cpp
  2021-07-25 16:32:02  [ main:458 ] - [ INFO ]  start dependency
  2021-07-25 16:32:02  [ main:462 ] - [ INFO ]  includenum:4
  2021-07-25 16:32:02  [ main:462 ] - [ INFO ]  definenum:0
  2021-07-25 16:32:02  [ main:462 ] - [ INFO ]  callnum:0
  2021-07-25 16:32:02  [ main:462 ] - [ INFO ]  returnnum:1
  2021-07-25 16:32:02  [ main:462 ] - [ INFO ]  parameternum:17
  2021-07-25 16:32:02  [ main:462 ] - [ INFO ]  extendnum:0
  2021-07-25 16:32:02  [ main:462 ] - [ INFO ]  overridenum:0
  2021-07-25 16:32:02  [ main:517 ] - [ INFO ]  Process finish!
  2021-07-25 16:32:56  [ main:0 ] - [ INFO ]  parseC:\Users\ding7\Desktop\newtest\phantompy\context.cpp
  2021-07-25 16:32:56  [ main:454 ] - [ INFO ]  parseC:\Users\ding7\Desktop\newtest\phantompy\context.hpp
  2021-07-25 16:32:56  [ main:455 ] - [ INFO ]  parseC:\Users\ding7\Desktop\newtest\phantompy\phantompy.cpp
  2021-07-25 16:32:56  [ main:462 ] - [ INFO ]  start dependency
  2021-07-25 16:32:56  [ main:466 ] - [ INFO ]  includenum:4
  2021-07-25 16:32:56  [ main:466 ] - [ INFO ]  definenum:0
  2021-07-25 16:32:56  [ main:466 ] - [ INFO ]  callnum:0
  2021-07-25 16:32:56  [ main:466 ] - [ INFO ]  returnnum:1
  2021-07-25 16:32:56  [ main:466 ] - [ INFO ]  parameternum:17
  2021-07-25 16:32:56  [ main:466 ] - [ INFO ]  extendnum:0
  2021-07-25 16:32:56  [ main:466 ] - [ INFO ]  overridenum:0
  2021-07-25 16:32:56  [ main:521 ] - [ INFO ]  Process finish!
  2021-07-25 16:33:47  [ main:0 ] - [ INFO ]  parseC:\Users\ding7\Desktop\newtest\phantompy\context.cpp
  2021-07-25 16:33:48  [ main:471 ] - [ INFO ]  parseC:\Users\ding7\Desktop\newtest\phantompy\context.hpp
  2021-07-25 16:33:48  [ main:472 ] - [ INFO ]  parseC:\Users\ding7\Desktop\newtest\phantompy\phantompy.cpp
  2021-07-25 16:33:48  [ main:479 ] - [ INFO ]  start dependency
  2021-07-25 16:33:48  [ main:482 ] - [ INFO ]  includenum:4
  2021-07-25 16:33:48  [ main:483 ] - [ INFO ]  definenum:0
  2021-07-25 16:33:48  [ main:483 ] - [ INFO ]  callnum:0
  2021-07-25 16:33:48  [ main:483 ] - [ INFO ]  returnnum:1
  2021-07-25 16:33:48  [ main:483 ] - [ INFO ]  parameternum:17
  2021-07-25 16:33:48  [ main:483 ] - [ INFO ]  extendnum:0
  2021-07-25 16:33:48  [ main:483 ] - [ INFO ]  overridenum:0
  2021-07-25 16:33:48  [ main:542 ] - [ INFO ]  Process finish!
  2021-07-25 16:34:09  [ main:0 ] - [ INFO ]  parseC:\Users\ding7\Desktop\newtest\phantompy\context.cpp
  2021-07-25 16:34:09  [ main:448 ] - [ INFO ]  parseC:\Users\ding7\Desktop\newtest\phantompy\context.hpp
  2021-07-25 16:34:09  [ main:448 ] - [ INFO ]  parseC:\Users\ding7\Desktop\newtest\phantompy\phantompy.cpp
  2021-07-25 16:34:09  [ main:455 ] - [ INFO ]  start dependency
  2021-07-25 16:34:09  [ main:459 ] - [ INFO ]  includenum:4
  2021-07-25 16:34:09  [ main:459 ] - [ INFO ]  definenum:0
  2021-07-25 16:34:09  [ main:459 ] - [ INFO ]  callnum:0
  2021-07-25 16:34:09  [ main:459 ] - [ INFO ]  returnnum:1
  2021-07-25 16:34:09  [ main:459 ] - [ INFO ]  parameternum:17
  2021-07-25 16:34:09  [ main:459 ] - [ INFO ]  extendnum:0
  2021-07-25 16:34:09  [ main:459 ] - [ INFO ]  overridenum:0
  2021-07-25 16:34:09  [ main:517 ] - [ INFO ]  Process finish!
  