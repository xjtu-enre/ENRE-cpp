package cdt;

import java.util.HashMap;
import java.util.Map;

public class MacroRepo {
    Map<String, String> definedMacros = new HashMap<>();
    public MacroRepo(){
        /*
         * libxml2
         */
        definedMacros.put("LIBXML_HTML_ENABLED", "");
        definedMacros.put("LIBXML_SCHEMAS_ENABLED", "");
        definedMacros.put("LIBXML_CATALOG_ENABLED", "");
        definedMacros.put("LIBXML_PUSH_ENABLED", "");
        definedMacros.put("LIBXML_UNICODE_ENABLED", "");
        definedMacros.put("LIBXML_OUTPUT_ENABLED", "");
        /*
         * JNI
         */
        definedMacros.put("JNICALL", "");
        /*
         * Gtest
         */
        definedMacros.put("GTEST_GET_FIRST_", "first");
        definedMacros.put("GTEST_MESSAGE_AT_", "::testing::internal::AssertHelper(result_type, file, line, message) = ::testing::Message()");
        definedMacros.put("GOOGLETEST_INCLUDE_GTEST_INTERNAL_GTEST_STRING_H_", "");
        definedMacros.put("ASSERT_GE", "GTEST_ASSERT_GE(val1, val2)");
        definedMacros.put("GTEST_INTERNAL_HAS_STRING_VIEW", "1");
        definedMacros.put("GTEST_SKIP_", "return GTEST_MESSAGE_(message, ::testing::TestPartResult::kSkip)");
        definedMacros.put("ASSERT_STRCASEEQ", "ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperSTRCASEEQ, s1, s2)");
        definedMacros.put("GTEST_INTERNAL_HAS_ABSL_FLAGS", "");
        definedMacros.put("GTEST_PRED1_", "GTEST_ASSERT_(::testing::AssertPred1Helper(#pred, #v1, pred, v1), on_failure)");
        definedMacros.put("GTEST_INTERNAL_HAS_VARIANT", "1");
        definedMacros.put("GOOGLETEST_INCLUDE_GTEST_GTEST_ASSERTION_RESULT_H_", "");
        definedMacros.put("GTEST_WIDE_STRING_USES_UTF16_", "1");
        definedMacros.put("GTEST_PRED_FORMAT4_", "GTEST_ASSERT_(pred_format(#v1, #v2, #v3, #v4, v1, v2, v3, v4), on_failure)");
        definedMacros.put("GTEST_GET_SECOND_", "second");
        definedMacros.put("GTEST_REMOVE_REFERENCE_AND_CONST_", "typename std::remove_const<typename std::remove_reference<T>::type>::type");
        definedMacros.put("GTEST_ATTRIBUTE_NO_SANITIZE_THREAD_", "__attribute((no_sanitize_thread))");
        definedMacros.put("EXPECT_STREQ", "EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperSTREQ, s1, s2)");
        definedMacros.put("GTEST_DEFINE_string_", "ABSL_FLAG(std::string, GTEST_FLAG_NAME_(name), default_val, doc)");
        definedMacros.put("INSTANTIATE_TEST_SUITE_P", "static ::testing::internal::ParamGenerator<test_suite_name::ParamType> gtest_##prefix##test_suite_name##_EvalGenerator_() { return GTEST_EXPAND_(GTEST_GET_FIRST_(__VA_ARGS__, DUMMY_PARAM_)); } static ::std::string gtest_##prefix##test_suite_name##_EvalGenerateName_( const ::testing::TestParamInfo<test_suite_name::ParamType>& info) { if (::testing::internal::AlwaysFalse()) { ::testing::internal::TestNotEmpty(GTEST_EXPAND_(GTEST_GET_SECOND_( __VA_ARGS__, ::testing::internal::DefaultParamName<test_suite_name::ParamType>, DUMMY_PARAM_))); auto t = std::make_tuple(__VA_ARGS__); static_assert(std::tuple_size<decltype(t)>::value <= 2, \"Too Many Args!\"); } return ((GTEST_EXPAND_(GTEST_GET_SECOND_( __VA_ARGS__, ::testing::internal::DefaultParamName<test_suite_name::ParamType>, DUMMY_PARAM_))))(info); } static int gtest_##prefix##test_suite_name##_dummy_ GTEST_ATTRIBUTE_UNUSED_ = ::testing::UnitTest::GetInstance() ->parameterized_test_registry() .GetTestSuitePatternHolder<test_suite_name>( GTEST_STRINGIFY_(test_suite_name), ::testing::internal::CodeLocation(__FILE__, __LINE__)) ->AddTestSuiteInstantiation( GTEST_STRINGIFY_(prefix), &gtest_##prefix##test_suite_name##_EvalGenerator_, &gtest_##prefix##test_suite_name##_EvalGenerateName_, __FILE__, __LINE__)");
        definedMacros.put("INSTANTIATE_TYPED_TEST_SUITE_P", "static_assert(sizeof(GTEST_STRINGIFY_(Prefix)) > 1, \"test-suit-prefix must not be empty\"); static bool gtest_##Prefix##_##SuiteName GTEST_ATTRIBUTE_UNUSED_ = ::testing::internal::TypeParameterizedTestSuite< SuiteName, GTEST_SUITE_NAMESPACE_(SuiteName)::gtest_AllTests_, ::testing::internal::GenerateTypeList<Types>::type>:: Register(GTEST_STRINGIFY_(Prefix), ::testing::internal::CodeLocation(__FILE__, __LINE__), &GTEST_TYPED_TEST_SUITE_P_STATE_(SuiteName), GTEST_STRINGIFY_(SuiteName), GTEST_REGISTERED_TEST_NAMES_(SuiteName), ::testing::internal::GenerateNames< ::testing::internal::NameGeneratorSelector< __VA_ARGS__>::type, ::testing::internal::GenerateTypeList<Types>::type>())");
        definedMacros.put("GTEST_INTERNAL_HAS_ANY", "1");
        definedMacros.put("GTEST_PRED2_", "GTEST_ASSERT_(::testing::AssertPred2Helper(#pred, #v1, #v2, pred, v1, v2), on_failure)");
        definedMacros.put("ASSERT_DEATH", "ASSERT_EXIT(statement, ::testing::internal::ExitedUnsuccessfully, matcher)");
        definedMacros.put("GTEST_STRINGIFY_", "GTEST_STRINGIFY_HELPER_(__VA_ARGS__, )");
        definedMacros.put("TYPED_TEST_CASE_P", "static_assert(::testing::internal::TypedTestCase_P_IsDeprecated(), \"\"); TYPED_TEST_SUITE_P");
        definedMacros.put("GTEST_PRED_FORMAT5_", "GTEST_ASSERT_(pred_format(#v1, #v2, #v3, #v4, #v5, v1, v2, v3, v4, v5), on_failure)");
        definedMacros.put("ASSERT_EQ", "GTEST_ASSERT_EQ(val1, val2)");
        definedMacros.put("GTEST_FATAL_FAILURE_", "return GTEST_MESSAGE_(message, ::testing::TestPartResult::kFatalFailure)");
        definedMacros.put("EXPECT_FATAL_FAILURE", "do { class GTestExpectFatalFailureHelper { public: static void Execute() { statement; } }; ::testing::TestPartResultArray gtest_failures; ::testing::internal::SingleFailureChecker gtest_checker( &gtest_failures, ::testing::TestPartResult::kFatalFailure, (substr)); { ::testing::ScopedFakeTestPartResultReporter gtest_reporter( ::testing::ScopedFakeTestPartResultReporter:: INTERCEPT_ONLY_CURRENT_THREAD, &gtest_failures); GTestExpectFatalFailureHelper::Execute(); } } while (::testing::internal::AlwaysFalse())");
        definedMacros.put("GTEST_BIND_", "TmplSel::template Bind<T>::type");
        definedMacros.put("GTEST_DEFINE_int32_", "ABSL_FLAG(int32_t, GTEST_FLAG_NAME_(name), default_val, doc)");
        definedMacros.put("EXPECT_FATAL_FAILURE_ON_ALL_THREADS", "do { class GTestExpectFatalFailureHelper { public: static void Execute() { statement; } }; ::testing::TestPartResultArray gtest_failures; ::testing::internal::SingleFailureChecker gtest_checker( &gtest_failures, ::testing::TestPartResult::kFatalFailure, (substr)); { ::testing::ScopedFakeTestPartResultReporter gtest_reporter( ::testing::ScopedFakeTestPartResultReporter::INTERCEPT_ALL_THREADS, &gtest_failures); GTestExpectFatalFailureHelper::Execute(); } } while (::testing::internal::AlwaysFalse())");
        definedMacros.put("GTEST_FLAG_PREFIX_DASH_", "\"gtest-\"");
        definedMacros.put("GTEST_EXECUTE_DEATH_TEST_STATEMENT_", "try { GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement); } catch (const ::std::exception& gtest_exception) { fprintf( stderr, \"\n%s: Caught std::exception-derived exception escaping the \" \"death test statement. Exception message: %s\n\", ::testing::internal::FormatFileLocation(__FILE__, __LINE__).c_str(), gtest_exception.what()); fflush(stderr); death_test->Abort(::testing::internal::DeathTest::TEST_THREW_EXCEPTION); } catch (...) { death_test->Abort(::testing::internal::DeathTest::TEST_THREW_EXCEPTION); }");
        definedMacros.put("EXPECT_NE", "EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperNE, val1, val2)");
        definedMacros.put("GTEST_EXPECT_FALSE", "GTEST_TEST_BOOLEAN_(!(condition), #condition, true, false, GTEST_NONFATAL_FAILURE_)");
        definedMacros.put("ASSERT_EXIT", "GTEST_DEATH_TEST_(statement, predicate, matcher, GTEST_FATAL_FAILURE_)");
        definedMacros.put("GTEST_NAME_GENERATOR_", "gtest_type_params_##TestSuiteName##_NameGenerator");
        definedMacros.put("ASSERT_NO_FATAL_FAILURE", "GTEST_TEST_NO_FATAL_FAILURE_(statement, GTEST_FATAL_FAILURE_)");
        definedMacros.put("EXPECT_DEBUG_DEATH", "GTEST_EXECUTE_STATEMENT_(statement, regex)");
        definedMacros.put("EXPECT_LT", "EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperLT, val1, val2)");
        definedMacros.put("ASSERT_STRNE", "ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperSTRNE, s1, s2)");
        definedMacros.put("GTEST_PRED_FORMAT2_", "GTEST_ASSERT_(pred_format(#v1, #v2, v1, v2), on_failure)");
        definedMacros.put("ASSERT_HRESULT_FAILED", "ASSERT_PRED_FORMAT1(::testing::internal::IsHRESULTFailure, (expr))");
        definedMacros.put("GOOGLETEST_INCLUDE_GTEST_GTEST_H_", "");
        definedMacros.put("GTEST_ASSERT_GE", "ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperGE, val1, val2)");
        definedMacros.put("ASSERT_FLOAT_EQ", "ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperFloatingPointEQ<float>, val1, val2)");
        definedMacros.put("GTEST_HAS_POSIX_RE", "(__ANDROID_API__ >= 9)");
        definedMacros.put("GTEST_TEST", "GTEST_TEST_(test_suite_name, test_name, ::testing::Test, ::testing::internal::GetTestTypeId())");
        definedMacros.put("GTEST_INTENTIONAL_CONST_COND_POP_", "GTEST_DISABLE_MSC_WARNINGS_POP_()");
        definedMacros.put("EXPECT_THROW", "GTEST_TEST_THROW_(statement, expected_exception, GTEST_NONFATAL_FAILURE_)");
        definedMacros.put("GTEST_AMBIGUOUS_ELSE_BLOCKER_", "");
        definedMacros.put("GTEST_MESSAGE_", "GTEST_MESSAGE_AT_(__FILE__, __LINE__, message, result_type)");
        definedMacros.put("GTEST_UNSUPPORTED_DEATH_TEST", "GTEST_AMBIGUOUS_ELSE_BLOCKER_ if (::testing::internal::AlwaysTrue()) { GTEST_LOG_(WARNING) << \"Death tests are not supported on this platform.\n\" << \"Statement '\" #statement \"' cannot be verified.\"; } else if (::testing::internal::AlwaysFalse()) { ::testing::internal::RE::PartialMatch(\".*\", (regex)); GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement); terminator; } else ::testing::Message()");
        definedMacros.put("TYPED_TEST_CASE", "static_assert(::testing::internal::TypedTestCaseIsDeprecated(), \"\"); TYPED_TEST_SUITE");
        definedMacros.put("GOOGLETEST_INCLUDE_GTEST_GTEST_PARAM_TEST_H_", "");
        definedMacros.put("GTEST_ASSERT_GT", "ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperGT, val1, val2)");
        definedMacros.put("GOOGLETEST_INCLUDE_GTEST_INTERNAL_CUSTOM_GTEST_PRINTERS_H_", "");
        definedMacros.put("GTEST_CONCAT_TOKEN_IMPL_", "foo##bar");
        definedMacros.put("GOOGLETEST_INCLUDE_GTEST_GTEST_PROD_H_", "");
        definedMacros.put("GOOGLETEST_INCLUDE_GTEST_INTERNAL_GTEST_PORT_ARCH_H_", "");
        definedMacros.put("GTEST_PROJECT_URL_", "\"https://github.com/google/googletest/\"");
        definedMacros.put("GOOGLETEST_INCLUDE_GTEST_INTERNAL_GTEST_PORT_H_", "");
        definedMacros.put("GTEST_MUST_USE_RESULT_", "__attribute__((warn_unused_result))");
        definedMacros.put("GTEST_PRED_FORMAT3_", "GTEST_ASSERT_(pred_format(#v1, #v2, #v3, v1, v2, v3), on_failure)");
        definedMacros.put("GTEST_EXCLUSIVE_LOCK_REQUIRED_", "");
        definedMacros.put("GOOGLETEST_INCLUDE_GTEST_INTERNAL_CUSTOM_GTEST_H_", "");
        definedMacros.put("GTEST_PATH_SEP_", "\"\\\"");
        definedMacros.put("GTEST_REGISTERED_TEST_NAMES_", "gtest_registered_test_names_##TestSuiteName##_");
        definedMacros.put("EXPECT_LE", "EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperLE, val1, val2)");
        definedMacros.put("GTEST_LOCK_EXCLUDED_", "");
        definedMacros.put("GTEST_DECLARE_STATIC_MUTEX_", "extern ::testing::internal::Mutex mutex");
        definedMacros.put("ASSERT_DEBUG_DEATH", "GTEST_EXECUTE_STATEMENT_(statement, regex)");
        definedMacros.put("ASSERT_FALSE", "GTEST_ASSERT_FALSE(condition)");
        definedMacros.put("SCOPED_TRACE", "const ::testing::ScopedTrace GTEST_CONCAT_TOKEN_(gtest_trace_, __LINE__)( __FILE__, __LINE__, (message))");
        definedMacros.put("GOOGLETEST_INCLUDE_GTEST_INTERNAL_GTEST_DEATH_TEST_INTERNAL_H_", "");
        definedMacros.put("GTEST_DEFINE_bool_", "ABSL_FLAG(bool, GTEST_FLAG_NAME_(name), default_val, doc)");
        definedMacros.put("TEST_F", "GTEST_TEST_F(test_fixture, test_name)");
        definedMacros.put("GTEST_TEST_F", "GTEST_TEST_(test_fixture, test_name, test_fixture, ::testing::internal::GetTypeId<test_fixture>())");
        definedMacros.put("GTEST_INTERNAL_HAS_STD_SPAN", "1");
        definedMacros.put("GTEST_TYPED_TEST_SUITE_P_STATE_", "gtest_typed_test_suite_p_state_##TestSuiteName##_");
        definedMacros.put("EXPECT_NEAR", "EXPECT_PRED_FORMAT3(::testing::internal::DoubleNearPredFormat, val1, val2, abs_error)");
        definedMacros.put("GTEST_HAS_PTHREAD", "1");
        definedMacros.put("GTEST_HAS_TYPED_TEST", "1");
        definedMacros.put("GOOGLETEST_INCLUDE_GTEST_GTEST_PRED_IMPL_H_", "");
        definedMacros.put("GTEST_IMPL_CMP_HELPER_", "template <typename T1, typename T2> AssertionResult CmpHelper##op_name(const char* expr1, const char* expr2, const T1& val1, const T2& val2) { if (val1 op val2) { return AssertionSuccess(); } else { return CmpHelperOpFailure(expr1, expr2, val1, val2, #op); } }");
        definedMacros.put("GTEST_HAS_EXCEPTIONS", "1");
        definedMacros.put("ASSERT_ANY_THROW", "GTEST_TEST_ANY_THROW_(statement, GTEST_FATAL_FAILURE_)");
        definedMacros.put("TEST_P", "class GTEST_TEST_CLASS_NAME_(test_suite_name, test_name) : public test_suite_name, private ::testing::internal::GTestNonCopyable { public: GTEST_TEST_CLASS_NAME_(test_suite_name, test_name)() {} void TestBody() override; private: static int AddToRegistry() { ::testing::UnitTest::GetInstance() ->parameterized_test_registry() .GetTestSuitePatternHolder<test_suite_name>( GTEST_STRINGIFY_(test_suite_name), ::testing::internal::CodeLocation(__FILE__, __LINE__)) ->AddTestPattern( GTEST_STRINGIFY_(test_suite_name), GTEST_STRINGIFY_(test_name), new ::testing::internal::TestMetaFactory<GTEST_TEST_CLASS_NAME_( test_suite_name, test_name)>(), ::testing::internal::CodeLocation(__FILE__, __LINE__)); return 0; } static int gtest_registering_dummy_ GTEST_ATTRIBUTE_UNUSED_; }; int GTEST_TEST_CLASS_NAME_(test_suite_name, test_name)::gtest_registering_dummy_ = GTEST_TEST_CLASS_NAME_(test_suite_name, test_name)::AddToRegistry(); void GTEST_TEST_CLASS_NAME_(test_suite_name, test_name)::TestBody()");
        definedMacros.put("GTEST_INTERNAL_CPLUSPLUS_LANG", "_MSVC_LANG");
        definedMacros.put("GTEST_ASSERT_NE", "ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperNE, val1, val2)");
        definedMacros.put("GTEST_SUITE_NAMESPACE_", "gtest_suite_##TestSuiteName##_");
        definedMacros.put("GTEST_DISABLE_MSC_WARNINGS_PUSH_", "__pragma(warning(push)) __pragma(warning(disable : warnings))");
        definedMacros.put("GTEST_PRED_FORMAT1_", "GTEST_ASSERT_(pred_format(#v1, v1), on_failure)");
        definedMacros.put("GTEST_TEMPLATE_", "template <typename T> class");
        definedMacros.put("ASSERT_DEATH_IF_SUPPORTED", "ASSERT_DEATH(statement, regex)");
        definedMacros.put("TEST", "GTEST_TEST(test_suite_name, test_name)");
        definedMacros.put("EXPECT_FLOAT_EQ", "EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperFloatingPointEQ<float>, val1, val2)");
        definedMacros.put("GTEST_DECLARE_string_", "ABSL_DECLARE_FLAG(std::string, GTEST_FLAG_NAME_(name))");
        definedMacros.put("EXPECT_DEATH", "EXPECT_EXIT(statement, ::testing::internal::ExitedUnsuccessfully, matcher)");
        definedMacros.put("GTEST_DISABLE_MSC_DEPRECATED_POP_", "_Pragma(\"clang diagnostic pop\")");
        definedMacros.put("TYPED_TEST_SUITE", "typedef ::testing::internal::GenerateTypeList<Types>::type GTEST_TYPE_PARAMS_(CaseName); typedef ::testing::internal::NameGeneratorSelector<__VA_ARGS__>::type GTEST_NAME_GENERATOR_(CaseName)");
        definedMacros.put("GTEST_IMPL_FORMAT_C_STRING_AS_POINTER_", "template <typename OtherOperand> class FormatForComparison<CharType*, OtherOperand> { public: static ::std::string Format(CharType* value) { return ::testing::PrintToString(static_cast<const void*>(value)); } }");
        definedMacros.put("TYPED_TEST_P", "namespace GTEST_SUITE_NAMESPACE_(SuiteName) { template <typename gtest_TypeParam_> class TestName : public SuiteName<gtest_TypeParam_> { private: typedef SuiteName<gtest_TypeParam_> TestFixture; typedef gtest_TypeParam_ TypeParam; void TestBody() override; }; static bool gtest_##TestName##_defined_ GTEST_ATTRIBUTE_UNUSED_ = GTEST_TYPED_TEST_SUITE_P_STATE_(SuiteName).AddTestName( __FILE__, __LINE__, GTEST_STRINGIFY_(SuiteName), GTEST_STRINGIFY_(TestName)); } template <typename gtest_TypeParam_> void GTEST_SUITE_NAMESPACE_( SuiteName)::TestName<gtest_TypeParam_>::TestBody()");
        definedMacros.put("GTEST_NAME_", "\"Google Test\"");
        definedMacros.put("GTEST_TEST_BOOLEAN_", "GTEST_AMBIGUOUS_ELSE_BLOCKER_ if (const ::testing::AssertionResult gtest_ar_ = ::testing::AssertionResult(expression)) ; else fail(::testing::internal::GetBoolAssertionFailureMessage( gtest_ar_, text, #actual, #expected) .c_str())");
        definedMacros.put("GTEST_GCC_VER_", "(__GNUC__ * 10000 + __GNUC_MINOR__ * 100 + __GNUC_PATCHLEVEL__)");
        definedMacros.put("GTEST_IS_THREADSAFE", "1");
        definedMacros.put("EXPECT_STRCASEEQ", "EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperSTRCASEEQ, s1, s2)");
        definedMacros.put("GOOGLETEST_INCLUDE_GTEST_INTERNAL_CUSTOM_GTEST_PORT_H_", "");
        definedMacros.put("GTEST_ATTRIBUTE_NO_SANITIZE_ADDRESS_", "__attribute__((no_sanitize_address))");
        definedMacros.put("GTEST_CHECK_POSIX_SUCCESS_", "if (const int gtest_error = (posix_call)) GTEST_LOG_(FATAL) << #posix_call << \"failed with error \" << gtest_error");
        definedMacros.put("GOOGLETEST_INCLUDE_GTEST_GTEST_SPI_H_", "");
        definedMacros.put("GOOGLETEST_INCLUDE_GTEST_INTERNAL_GTEST_PARAM_UTIL_H_", "");
        definedMacros.put("GTEST_REFERENCE_TO_CONST_", "typename ::testing::internal::ConstRef<T>::type");
        definedMacros.put("TYPED_TEST", "static_assert(sizeof(GTEST_STRINGIFY_(TestName)) > 1, \"test-name must not be empty\"); template <typename gtest_TypeParam_> class GTEST_TEST_CLASS_NAME_(CaseName, TestName) : public CaseName<gtest_TypeParam_> { private: typedef CaseName<gtest_TypeParam_> TestFixture; typedef gtest_TypeParam_ TypeParam; void TestBody() override; }; static bool gtest_##CaseName##_##TestName##_registered_ GTEST_ATTRIBUTE_UNUSED_ = ::testing::internal::TypeParameterizedTest< CaseName, ::testing::internal::TemplateSel<GTEST_TEST_CLASS_NAME_(CaseName, TestName)>, GTEST_TYPE_PARAMS_( CaseName)>::Register(\"\", ::testing::internal::CodeLocation( __FILE__, __LINE__), GTEST_STRINGIFY_(CaseName), GTEST_STRINGIFY_(TestName), 0, ::testing::internal::GenerateNames< GTEST_NAME_GENERATOR_(CaseName), GTEST_TYPE_PARAMS_(CaseName)>()); template <typename gtest_TypeParam_> void GTEST_TEST_CLASS_NAME_(CaseName, TestName)<gtest_TypeParam_>::TestBody()");
        definedMacros.put("ASSERT_TRUE", "GTEST_ASSERT_TRUE(condition)");
        definedMacros.put("GTEST_INTERNAL_DEPRECATED", "__declspec(deprecated(message))");
        definedMacros.put("GTEST_NONFATAL_FAILURE_", "GTEST_MESSAGE_(message, ::testing::TestPartResult::kNonFatalFailure)");
        definedMacros.put("GOOGLETEST_INCLUDE_GTEST_GTEST_TEST_PART_H_", "");
        definedMacros.put("GOOGLETEST_INCLUDE_GTEST_INTERNAL_GTEST_TYPE_UTIL_H_", "");
        definedMacros.put("GTEST_ASSERT_LE", "ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperLE, val1, val2)");
        definedMacros.put("EXPECT_HRESULT_SUCCEEDED", "EXPECT_PRED_FORMAT1(::testing::internal::IsHRESULTSuccess, (expr))");
        definedMacros.put("GTEST_INTERNAL_HAS_OPTIONAL", "1");
        definedMacros.put("FAIL_AT", "GTEST_FAIL_AT(file, line)");
        definedMacros.put("GTEST_DECLARE_int32_", "ABSL_DECLARE_FLAG(int32_t, GTEST_FLAG_NAME_(name))");
        definedMacros.put("ASSERT_GT", "GTEST_ASSERT_GT(val1, val2)");
        definedMacros.put("GOOGLETEST_INCLUDE_GTEST_GTEST_PRINTERS_H_", "");
        definedMacros.put("GTEST_NO_TAIL_CALL_", "__attribute__((disable_tail_calls))");
        definedMacros.put("GTEST_FLAG_GET", "::absl::GetFlag(GTEST_FLAG(name))");
        definedMacros.put("GTEST_ASSERT_LT", "ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperLT, val1, val2)");
        definedMacros.put("GTEST_INIT_GOOGLE_TEST_NAME_", "\"testing::InitGoogleTest\"");
        definedMacros.put("ASSERT_PRED_FORMAT4", "GTEST_PRED_FORMAT4_(pred_format, v1, v2, v3, v4, GTEST_FATAL_FAILURE_)");
        definedMacros.put("GTEST_DECLARE_bool_", "ABSL_DECLARE_FLAG(bool, GTEST_FLAG_NAME_(name))");
        definedMacros.put("ASSERT_PRED_FORMAT5", "GTEST_PRED_FORMAT5_(pred_format, v1, v2, v3, v4, v5, GTEST_FATAL_FAILURE_)");
        definedMacros.put("GTEST_DEFINE_STATIC_MUTEX_", "::testing::internal::Mutex mutex(::testing::internal::Mutex::kStaticMutex)");
        definedMacros.put("GTEST_HAS_CLONE", "1");
        definedMacros.put("ASSERT_STRCASENE", "ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperSTRCASENE, s1, s2)");
        definedMacros.put("EXPECT_NO_FATAL_FAILURE", "GTEST_TEST_NO_FATAL_FAILURE_(statement, GTEST_NONFATAL_FAILURE_)");
        definedMacros.put("ASSERT_PRED_FORMAT1", "GTEST_PRED_FORMAT1_(pred_format, v1, GTEST_FATAL_FAILURE_)");
        definedMacros.put("ASSERT_PRED_FORMAT2", "GTEST_PRED_FORMAT2_(pred_format, v1, v2, GTEST_FATAL_FAILURE_)");
        definedMacros.put("GTEST_USE_OWN_FLAGFILE_FLAG_", "0");
        definedMacros.put("ASSERT_PRED_FORMAT3", "GTEST_PRED_FORMAT3_(pred_format, v1, v2, v3, GTEST_FATAL_FAILURE_)");
        definedMacros.put("GTEST_ASSERT_", "GTEST_AMBIGUOUS_ELSE_BLOCKER_ if (const ::testing::AssertionResult gtest_ar = (expression)) ; else on_failure(gtest_ar.failure_message())");
        definedMacros.put("EXPECT_STRNE", "EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperSTRNE, s1, s2)");
        definedMacros.put("GTEST_API_", "__declspec(dllimport)");
        definedMacros.put("_HAS_EXCEPTIONS", "1");
        definedMacros.put("GTEST_CHECK_", "GTEST_AMBIGUOUS_ELSE_BLOCKER_ if (::testing::internal::IsTrue(condition)) ; else GTEST_LOG_(FATAL) << \"Condition \" #condition \" failed. \"");
        definedMacros.put("GTEST_HAVE_FEATURE_", "__has_feature(x)");
        definedMacros.put("GTEST_HAS_MUTEX_AND_THREAD_LOCAL_", "0");
        definedMacros.put("TYPED_TEST_SUITE_P", "static ::testing::internal::TypedTestSuitePState GTEST_TYPED_TEST_SUITE_P_STATE_(SuiteName)");
        definedMacros.put("EXPECT_PRED_FORMAT1", "GTEST_PRED_FORMAT1_(pred_format, v1, GTEST_NONFATAL_FAILURE_)");
        definedMacros.put("ASSERT_PRED2", "GTEST_PRED2_(pred, v1, v2, GTEST_FATAL_FAILURE_)");
        definedMacros.put("ASSERT_NE", "GTEST_ASSERT_NE(val1, val2)");
        definedMacros.put("GTEST_INTERNAL_NEED_REDUNDANT_CONSTEXPR_DECL", "1");
        definedMacros.put("GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_", "if (::testing::internal::AlwaysTrue()) { statement; } else static_assert(true, \"\")");
        definedMacros.put("EXPECT_PRED_FORMAT2", "GTEST_PRED_FORMAT2_(pred_format, v1, v2, GTEST_NONFATAL_FAILURE_)");
        definedMacros.put("ASSERT_PRED3", "GTEST_PRED3_(pred, v1, v2, v3, GTEST_FATAL_FAILURE_)");
        definedMacros.put("ASSERT_PRED4", "GTEST_PRED4_(pred, v1, v2, v3, v4, GTEST_FATAL_FAILURE_)");
        definedMacros.put("ASSERT_PRED5", "GTEST_PRED5_(pred, v1, v2, v3, v4, v5, GTEST_FATAL_FAILURE_)");
        definedMacros.put("EXPECT_PRED_FORMAT5", "GTEST_PRED_FORMAT5_(pred_format, v1, v2, v3, v4, v5, GTEST_NONFATAL_FAILURE_)");
        definedMacros.put("EXPECT_PRED_FORMAT3", "GTEST_PRED_FORMAT3_(pred_format, v1, v2, v3, GTEST_NONFATAL_FAILURE_)");
        definedMacros.put("EXPECT_ANY_THROW", "GTEST_TEST_ANY_THROW_(statement, GTEST_NONFATAL_FAILURE_)");
        definedMacros.put("GTEST_DEATH_TEST_", "GTEST_AMBIGUOUS_ELSE_BLOCKER_ if (::testing::internal::AlwaysTrue()) { ::testing::internal::DeathTest* gtest_dt; if (!::testing::internal::DeathTest::Create( #statement, ::testing::internal::MakeDeathTestMatcher(regex_or_matcher), __FILE__, __LINE__, &gtest_dt)) { goto GTEST_CONCAT_TOKEN_(gtest_label_, __LINE__); } if (gtest_dt != nullptr) { std::unique_ptr< ::testing::internal::DeathTest> gtest_dt_ptr(gtest_dt); switch (gtest_dt->AssumeRole()) { case ::testing::internal::DeathTest::OVERSEE_TEST: if (!gtest_dt->Passed(predicate(gtest_dt->Wait()))) { goto GTEST_CONCAT_TOKEN_(gtest_label_, __LINE__); } break; case ::testing::internal::DeathTest::EXECUTE_TEST: { const ::testing::internal::DeathTest::ReturnSentinel gtest_sentinel( gtest_dt); GTEST_EXECUTE_DEATH_TEST_STATEMENT_(statement, gtest_dt); gtest_dt->Abort(::testing::internal::DeathTest::TEST_DID_NOT_DIE); break; } } } } else GTEST_CONCAT_TOKEN_(gtest_label_, __LINE__) : fail(::testing::internal::DeathTest::LastMessage())");
        definedMacros.put("EXPECT_PRED_FORMAT4", "GTEST_PRED_FORMAT4_(pred_format, v1, v2, v3, v4, GTEST_NONFATAL_FAILURE_)");
        definedMacros.put("GTEST_TEST_NO_THROW_CATCH_STD_EXCEPTION_", "catch (std::exception const& e) { gtest_msg.value = \"it throws \"; gtest_msg.value += GTEST_EXCEPTION_TYPE_(e); gtest_msg.value += \" with description \"; gtest_msg.value += e.what(); gtest_msg.value += \".\"; goto GTEST_CONCAT_TOKEN_(gtest_label_testnothrow_, __LINE__); }");
        definedMacros.put("GTEST_ASSERT_TRUE", "GTEST_TEST_BOOLEAN_(condition, #condition, false, true, GTEST_FATAL_FAILURE_)");
        definedMacros.put("EXPECT_NONFATAL_FAILURE", "do { ::testing::TestPartResultArray gtest_failures; ::testing::internal::SingleFailureChecker gtest_checker( &gtest_failures, ::testing::TestPartResult::kNonFatalFailure, (substr)); { ::testing::ScopedFakeTestPartResultReporter gtest_reporter( ::testing::ScopedFakeTestPartResultReporter:: INTERCEPT_ONLY_CURRENT_THREAD, &gtest_failures); if (::testing::internal::AlwaysTrue()) { statement; } } } while (::testing::internal::AlwaysFalse())");
        definedMacros.put("GOOGLETEST_INCLUDE_GTEST_INTERNAL_GTEST_INTERNAL_H_", "");
        definedMacros.put("GTEST_FAIL_AT", "return GTEST_MESSAGE_AT_(file, line, \"Failed\", ::testing::TestPartResult::kFatalFailure)");
        definedMacros.put("ASSERT_PRED1", "GTEST_PRED1_(pred, v1, GTEST_FATAL_FAILURE_)");
        definedMacros.put("GTEST_EXPECT_TRUE", "GTEST_TEST_BOOLEAN_(condition, #condition, false, true, GTEST_NONFATAL_FAILURE_)");
        definedMacros.put("EXPECT_EQ", "EXPECT_PRED_FORMAT2(::testing::internal::EqHelper::Compare, val1, val2)");
        definedMacros.put("REGISTER_TYPED_TEST_CASE_P", "static_assert(::testing::internal::RegisterTypedTestCase_P_IsDeprecated(), \"\"); REGISTER_TYPED_TEST_SUITE_P");
        definedMacros.put("FAIL", "GTEST_FAIL()");
        definedMacros.put("GTEST_LOG_", "::testing::internal::GTestLog(::testing::internal::GTEST_##severity, __FILE__, __LINE__) .GetStream()");
        definedMacros.put("GTEST_FLAG_SAVER_", "::absl::FlagSaver");
        definedMacros.put("GTEST_SKIP", "GTEST_SKIP_(\"\")");
        definedMacros.put("EXPECT_TRUE", "GTEST_EXPECT_TRUE(condition)");
        definedMacros.put("FRIEND_TEST", "friend class test_case_name##_##test_name##_Test");
        definedMacros.put("ADD_FAILURE_AT", "GTEST_MESSAGE_AT_(file, line, \"Failed\", ::testing::TestPartResult::kNonFatalFailure)");
        definedMacros.put("EXPECT_DOUBLE_EQ", "EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperFloatingPointEQ<double>, val1, val2)");
        definedMacros.put("ASSERT_STREQ", "ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperSTREQ, s1, s2)");
        definedMacros.put("EXPECT_HRESULT_FAILED", "EXPECT_PRED_FORMAT1(::testing::internal::IsHRESULTFailure, (expr))");
        definedMacros.put("GTEST_HAS_TYPED_TEST_P", "1");
        definedMacros.put("GTEST_FLAG", "FLAGS_gtest_##name");
        definedMacros.put("GTEST_DISABLE_MSC_WARNINGS_POP_", "__pragma(warning(pop))");
        definedMacros.put("EXPECT_NONFATAL_FAILURE_ON_ALL_THREADS", "do { ::testing::TestPartResultArray gtest_failures; ::testing::internal::SingleFailureChecker gtest_checker( &gtest_failures, ::testing::TestPartResult::kNonFatalFailure, (substr)); { ::testing::ScopedFakeTestPartResultReporter gtest_reporter( ::testing::ScopedFakeTestPartResultReporter::INTERCEPT_ALL_THREADS, &gtest_failures); if (::testing::internal::AlwaysTrue()) { statement; } } } while (::testing::internal::AlwaysFalse())");
        definedMacros.put("ASSERT_LT", "GTEST_ASSERT_LT(val1, val2)");
        definedMacros.put("ASSERT_HRESULT_SUCCEEDED", "ASSERT_PRED_FORMAT1(::testing::internal::IsHRESULTSuccess, (expr))");
        definedMacros.put("GTEST_TEST_NO_FATAL_FAILURE_", "GTEST_AMBIGUOUS_ELSE_BLOCKER_ if (::testing::internal::AlwaysTrue()) { const ::testing::internal::HasNewFatalFailureHelper gtest_fatal_failure_checker; GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement); if (gtest_fatal_failure_checker.has_new_fatal_failure()) { goto GTEST_CONCAT_TOKEN_(gtest_label_testnofatal_, __LINE__); } } else GTEST_CONCAT_TOKEN_(gtest_label_testnofatal_, __LINE__) : fail(\"Expected: \" #statement \" doesn't generate new fatal \" \"failures in the current thread.\n\" \"  Actual: it does.\")");
        definedMacros.put("GTEST_HAS_DEATH_TEST", "1");
        definedMacros.put("GTEST_ATTRIBUTE_PRINTF_", "__attribute__((format(__MINGW_PRINTF_FORMAT, string_index, first_to_check)))");
        definedMacros.put("GTEST_EXECUTE_STATEMENT_", "GTEST_AMBIGUOUS_ELSE_BLOCKER_ if (::testing::internal::AlwaysTrue()) { GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement); } else if (!::testing::internal::AlwaysTrue()) { ::testing::internal::MakeDeathTestMatcher(regex_or_matcher); } else ::testing::Message()");
        definedMacros.put("GTEST_HAS_ALT_PATH_SEP_", "1");
        definedMacros.put("GTEST_HAS_NOTIFICATION_", "0");
        definedMacros.put("ASSERT_LE", "GTEST_ASSERT_LE(val1, val2)");
        definedMacros.put("GTEST_MAYBE_5046_", "5046");
        definedMacros.put("GTEST_HAS_STD_WSTRING", "1");
        definedMacros.put("GTEST_STRINGIFY_HELPER_", "#name");
        definedMacros.put("GTEST_TEST_THROW_", "GTEST_AMBIGUOUS_ELSE_BLOCKER_ if (::testing::internal::TrueWithString gtest_msg{}) { bool gtest_caught_expected = false; try { GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement); } catch (expected_exception const&) { gtest_caught_expected = true; } GTEST_TEST_THROW_CATCH_STD_EXCEPTION_(statement, expected_exception) catch (...) { gtest_msg.value = \"Expected: \" #statement \" throws an exception of type \" #expected_exception \".\n  Actual: it throws a different type.\"; goto GTEST_CONCAT_TOKEN_(gtest_label_testthrow_, __LINE__); } if (!gtest_caught_expected) { gtest_msg.value = \"Expected: \" #statement \" throws an exception of type \" #expected_exception \".\n  Actual: it throws nothing.\"; goto GTEST_CONCAT_TOKEN_(gtest_label_testthrow_, __LINE__); } } else GTEST_CONCAT_TOKEN_(gtest_label_testthrow_, __LINE__) : fail(gtest_msg.value.c_str())");
        definedMacros.put("GTEST_USES_RE2", "1");
        definedMacros.put("GTEST_TEST_NO_THROW_", "GTEST_AMBIGUOUS_ELSE_BLOCKER_ if (::testing::internal::TrueWithString gtest_msg{}) { try { GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement); } GTEST_TEST_NO_THROW_CATCH_STD_EXCEPTION_() catch (...) { gtest_msg.value = \"it throws.\"; goto GTEST_CONCAT_TOKEN_(gtest_label_testnothrow_, __LINE__); } } else GTEST_CONCAT_TOKEN_(gtest_label_testnothrow_, __LINE__) : fail((\"Expected: \" #statement \" doesn't throw an exception.\n\" \"  Actual: \" + gtest_msg.value) .c_str())");
        definedMacros.put("GTEST_HAS_FILE_SYSTEM", "1");
        definedMacros.put("ASSERT_THROW", "GTEST_TEST_THROW_(statement, expected_exception, GTEST_FATAL_FAILURE_)");
        definedMacros.put("ASSERT_DOUBLE_EQ", "ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperFloatingPointEQ<double>, val1, val2)");
        definedMacros.put("GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST", "namespace gtest_do_not_use_outside_namespace_scope {} static const ::testing::internal::MarkAsIgnored gtest_allow_ignore_##T( GTEST_STRINGIFY_(T))");
        definedMacros.put("INSTANTIATE_TYPED_TEST_CASE_P", "static_assert( ::testing::internal::InstantiateTypedTestCase_P_IsDeprecated(), \"\"); INSTANTIATE_TYPED_TEST_SUITE_P");
        definedMacros.put("GTEST_HAS_SEH", "1");
        definedMacros.put("GTEST_USES_SIMPLE_RE", "1");
        definedMacros.put("GOOGLETEST_INCLUDE_GTEST_GTEST_MESSAGE_H_", "");
        definedMacros.put("GTEST_DISABLE_MSC_DEPRECATED_PUSH_", "_Pragma(\"clang diagnostic push\") _Pragma(\"clang diagnostic ignored \"-Wdeprecated-declarations\"\") _Pragma(\"clang diagnostic ignored \"-Wdeprecated-implementations\"\")");
        definedMacros.put("GOOGLETEST_INCLUDE_GTEST_GTEST_DEATH_TEST_H_", "");
        definedMacros.put("GTEST_USES_POSIX_RE", "1");
        definedMacros.put("GTEST_DEV_EMAIL_", "\"googletestframework@@googlegroups.com\"");
        definedMacros.put("GTEST_TEST_CLASS_NAME_", "test_suite_name##_##test_name##_Test");
        definedMacros.put("GTEST_PRED5_", "GTEST_ASSERT_(::testing::AssertPred5Helper(#pred, #v1, #v2, #v3, #v4, #v5, pred, v1, v2, v3, v4, v5), on_failure)");
        definedMacros.put("GTEST_FLAG_NAME_", "gtest_##name");
        definedMacros.put("INSTANTIATE_TEST_CASE_P", "static_assert(::testing::internal::InstantiateTestCase_P_IsDeprecated(), \"\"); INSTANTIATE_TEST_SUITE_P");
        definedMacros.put("GTEST_ASSERT_EQ", "ASSERT_PRED_FORMAT2(::testing::internal::EqHelper::Compare, val1, val2)");
        definedMacros.put("GTEST_INTERNAL_HAS_INCLUDE", "__has_include");
        definedMacros.put("GTEST_SUCCESS_", "GTEST_MESSAGE_(message, ::testing::TestPartResult::kSuccess)");
        definedMacros.put("REGISTER_TYPED_TEST_SUITE_P", "namespace GTEST_SUITE_NAMESPACE_(SuiteName) { typedef ::testing::internal::Templates<__VA_ARGS__> gtest_AllTests_; } static const char* const GTEST_REGISTERED_TEST_NAMES_( SuiteName) GTEST_ATTRIBUTE_UNUSED_ = GTEST_TYPED_TEST_SUITE_P_STATE_(SuiteName).VerifyRegisteredTestNames( GTEST_STRINGIFY_(SuiteName), __FILE__, __LINE__, #__VA_ARGS__)");
        definedMacros.put("GTEST_FAIL", "GTEST_FATAL_FAILURE_(\"Failed\")");
        definedMacros.put("GTEST_TEST_ANY_THROW_", "GTEST_AMBIGUOUS_ELSE_BLOCKER_ if (::testing::internal::AlwaysTrue()) { bool gtest_caught_any = false; try { GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement); } catch (...) { gtest_caught_any = true; } if (!gtest_caught_any) { goto GTEST_CONCAT_TOKEN_(gtest_label_testanythrow_, __LINE__); } } else GTEST_CONCAT_TOKEN_(gtest_label_testanythrow_, __LINE__) : fail(\"Expected: \" #statement \" throws an exception.\n\" \"  Actual: it doesn't.\")");
        definedMacros.put("GTEST_ASSERT_FALSE", "GTEST_TEST_BOOLEAN_(!(condition), #condition, true, false, GTEST_FATAL_FAILURE_)");
        definedMacros.put("GTEST_DEFAULT_DEATH_TEST_STYLE", "\"fast\"");
        definedMacros.put("SUCCEED", "GTEST_SUCCEED()");
        definedMacros.put("GTEST_SUCCEED", "GTEST_SUCCESS_(\"Succeeded\")");
        definedMacros.put("GTEST_EXCEPTION_TYPE_", "::testing::internal::GetTypeName(typeid(e))");
        definedMacros.put("EXPECT_EXIT", "GTEST_DEATH_TEST_(statement, predicate, matcher, GTEST_NONFATAL_FAILURE_)");
        definedMacros.put("GTEST_SNPRINTF_", "_snprintf_s(buffer, size, size, format, __VA_ARGS__)");
        definedMacros.put("ASSERT_NEAR", "ASSERT_PRED_FORMAT3(::testing::internal::DoubleNearPredFormat, val1, val2, abs_error)");
        definedMacros.put("GTEST_TEST_THROW_CATCH_STD_EXCEPTION_", "catch (typename std::conditional< std::is_same<typename std::remove_cv<typename std::remove_reference< expected_exception>::type>::type, std::exception>::value, const ::testing::internal::NeverThrown&, const std::exception&>::type e) { gtest_msg.value = \"Expected: \" #statement \" throws an exception of type \" #expected_exception \".\n  Actual: it throws \"; gtest_msg.value += GTEST_EXCEPTION_TYPE_(e); gtest_msg.value += \" with description \"\"; gtest_msg.value += e.what(); gtest_msg.value += \"\".\"; goto GTEST_CONCAT_TOKEN_(gtest_label_testthrow_, __LINE__); }");
        definedMacros.put("GTEST_CONCAT_TOKEN_", "GTEST_CONCAT_TOKEN_IMPL_(foo, bar)");
        definedMacros.put("EXPECT_PRED1", "GTEST_PRED1_(pred, v1, GTEST_NONFATAL_FAILURE_)");
        definedMacros.put("EXPECT_PRED2", "GTEST_PRED2_(pred, v1, v2, GTEST_NONFATAL_FAILURE_)");
        definedMacros.put("EXPECT_PRED3", "GTEST_PRED3_(pred, v1, v2, v3, GTEST_NONFATAL_FAILURE_)");
        definedMacros.put("GTEST_TEST_", "static_assert(sizeof(GTEST_STRINGIFY_(test_suite_name)) > 1, \"test_suite_name must not be empty\"); static_assert(sizeof(GTEST_STRINGIFY_(test_name)) > 1, \"test_name must not be empty\"); class GTEST_TEST_CLASS_NAME_(test_suite_name, test_name) : public parent_class { public: GTEST_TEST_CLASS_NAME_(test_suite_name, test_name)() = default; ~GTEST_TEST_CLASS_NAME_(test_suite_name, test_name)() override = default; GTEST_TEST_CLASS_NAME_(test_suite_name, test_name) (const GTEST_TEST_CLASS_NAME_(test_suite_name, test_name) &) = delete; GTEST_TEST_CLASS_NAME_(test_suite_name, test_name) & operator=( const GTEST_TEST_CLASS_NAME_(test_suite_name, test_name) &) = delete; GTEST_TEST_CLASS_NAME_(test_suite_name, test_name) (GTEST_TEST_CLASS_NAME_(test_suite_name, test_name) &&) noexcept = delete; GTEST_TEST_CLASS_NAME_(test_suite_name, test_name) & operator=( GTEST_TEST_CLASS_NAME_(test_suite_name, test_name) &&) noexcept = delete; private: void TestBody() override; static ::testing::TestInfo* const test_info_ GTEST_ATTRIBUTE_UNUSED_; }; ::testing::TestInfo* const GTEST_TEST_CLASS_NAME_(test_suite_name, test_name)::test_info_ = ::testing::internal::MakeAndRegisterTestInfo( #test_suite_name, #test_name, nullptr, nullptr, ::testing::internal::CodeLocation(__FILE__, __LINE__), (parent_id), ::testing::internal::SuiteApiResolver< parent_class>::GetSetUpCaseOrSuite(__FILE__, __LINE__), ::testing::internal::SuiteApiResolver< parent_class>::GetTearDownCaseOrSuite(__FILE__, __LINE__), new ::testing::internal::TestFactoryImpl<GTEST_TEST_CLASS_NAME_( test_suite_name, test_name)>); void GTEST_TEST_CLASS_NAME_(test_suite_name, test_name)::TestBody()");
        definedMacros.put("EXPECT_PRED4", "GTEST_PRED4_(pred, v1, v2, v3, v4, GTEST_NONFATAL_FAILURE_)");
        definedMacros.put("GTEST_HAS_CXXABI_H_", "1");
        definedMacros.put("EXPECT_PRED5", "GTEST_PRED5_(pred, v1, v2, v3, v4, v5, GTEST_NONFATAL_FAILURE_)");
        definedMacros.put("GTEST_FLAG_PREFIX_UPPER_", "\"GTEST_\"");
        definedMacros.put("GTEST_EXPAND_", "arg");
        definedMacros.put("GTEST_HAVE_ATTRIBUTE_", "__has_attribute(x)");
        definedMacros.put("GTEST_HAS_RTTI", "1");
        definedMacros.put("GTEST_PRED3_", "GTEST_ASSERT_( ::testing::AssertPred3Helper(#pred, #v1, #v2, #v3, pred, v1, v2, v3), on_failure)");
        definedMacros.put("EXPECT_STRCASENE", "EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperSTRCASENE, s1, s2)");
        definedMacros.put("GTEST_ATTRIBUTE_UNUSED_", "__attribute__((unused))");
        definedMacros.put("GOOGLETEST_INCLUDE_GTEST_GTEST_TYPED_TEST_H_", "");
        definedMacros.put("GTEST_FLAG_PREFIX_", "\"gtest_\"");
        definedMacros.put("GTEST_ATTRIBUTE_NO_SANITIZE_HWADDRESS_", "__attribute__((no_sanitize(\"hwaddress\")))");
        definedMacros.put("ASSERT_NO_THROW", "GTEST_TEST_NO_THROW_(statement, GTEST_FATAL_FAILURE_)");
        definedMacros.put("GOOGLETEST_INCLUDE_GTEST_INTERNAL_GTEST_FILEPATH_H_", "");
        definedMacros.put("EXPECT_GE", "EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperGE, val1, val2)");
        definedMacros.put("GTEST_FLAG_SET", "(void)(::absl::SetFlag(&GTEST_FLAG(name), value))");
        definedMacros.put("GTEST_CAN_STREAM_RESULTS_", "1");
        definedMacros.put("EXPECT_FALSE", "GTEST_EXPECT_FALSE(condition)");
        definedMacros.put("GTEST_INTENTIONAL_CONST_COND_PUSH_", "GTEST_DISABLE_MSC_WARNINGS_PUSH_(4127)");
        definedMacros.put("GTEST_NO_INLINE_", "__attribute__((noinline))");
        definedMacros.put("EXPECT_GT", "EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperGT, val1, val2)");
        definedMacros.put("GOOGLETEST_INCLUDE_GTEST_GTEST_MATCHERS_H_", "");
        definedMacros.put("ADD_FAILURE", "GTEST_NONFATAL_FAILURE_(\"Failed\")");
        definedMacros.put("GTEST_ATTRIBUTE_NO_SANITIZE_MEMORY_", "__attribute__((no_sanitize_memory))");
        definedMacros.put("GTEST_HAS_STREAM_REDIRECTION", "0");
        definedMacros.put("GTEST_TYPE_PARAMS_", "gtest_type_params_##TestSuiteName##_");
        definedMacros.put("GTEST_PRED4_", "GTEST_ASSERT_(::testing::AssertPred4Helper(#pred, #v1, #v2, #v3, #v4, pred, v1, v2, v3, v4), on_failure)");
        definedMacros.put("GTEST_IMPL_FORMAT_C_STRING_AS_STRING_", "template <> class FormatForComparison<CharType*, OtherStringType> { public: static ::std::string Format(CharType* value) { return ::testing::PrintToString(value); } }");
        definedMacros.put("EXPECT_NO_THROW", "GTEST_TEST_NO_THROW_(statement, GTEST_NONFATAL_FAILURE_)");
        definedMacros.put("EXPECT_DEATH_IF_SUPPORTED", "EXPECT_DEATH(statement, regex)");


    }
    public  Map<String, String> getDefinedMacros(){
        return definedMacros;
    }
}
