2021-07-23 19:59:13  [ main:0 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\phantompy.cpp
  2021-07-23 19:59:13  [ main:471 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-23 19:59:13  [ main:527 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\frame.hpp:11
  2021-07-23 19:59:13  [ main:530 ] - [ ERROR ]  parsing error 
private slots:
    void loadFinished(bool ok);
  2021-07-23 19:59:13  [ main:530 ] - [ ERROR ]  warning: parse error private slots:
    void loadFinished(bool ok);Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\frame.hpp:38
  2021-07-23 19:59:13  [ main:533 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-23 19:59:13  [ main:533 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\image.hpp:9
  2021-07-23 19:59:14  [ main:551 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-23 19:59:14  [ main:551 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\timeout.hpp:9
  2021-07-23 19:59:14  [ main:552 ] - [ ERROR ]  parsing error 
private slots:
    void handleTimeout();
  2021-07-23 19:59:14  [ main:552 ] - [ ERROR ]  warning: parse error private slots:
    void handleTimeout();Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\timeout.hpp:22
  2021-07-23 19:59:14  [ main:561 ] - [ ERROR ]  parsing error 
QT_BEGIN_NAMESPACE
  2021-07-23 19:59:14  [ main:562 ] - [ ERROR ]  warning: parse error QT_BEGIN_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\parser.h:26
  2021-07-23 19:59:14  [ main:562 ] - [ ERROR ]  parsing error 
QT_END_NAMESPACE
  2021-07-23 19:59:14  [ main:562 ] - [ ERROR ]  warning: parse error QT_END_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\parser.h:29
  2021-07-23 19:59:14  [ main:563 ] - [ ERROR ]  parsing error 
class QJSON_EXPORT Parser
  {
    public:
      Parser();
      ~Parser();

      /**
      * Read JSON string from the I/O Device and converts it to a QVariant object
      * @param io Input output device
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true.
      * @returns a QVariant object generated from the JSON string
      */
      QVariant parse(QIODevice* io, bool* ok = 0);

      /**
      * This is a method provided for convenience.
      * @param jsonData data containing the JSON object representation
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true.
      * @returns a QVariant object generated from the JSON string
      * @sa errorString
      * @sa errorLine
      */
      QVariant parse(const QByteArray& jsonData, bool* ok = 0);

      /**
      * This method returns the error message
      * @returns a QString object containing the error message of the last parse operation
      * @sa errorLine
      */
      QString errorString() const;

      /**
      * This method returns line number where the error occurred
      * @returns the line number where the error occurred
      * @sa errorString
      */
      int errorLine() const;

      /**
       * Sets whether special numbers (Infinity, -Infinity, NaN) are allowed as an extension to
       * the standard
       * @param  allowSpecialNumbers new value of whether special numbers are allowed
       * @sa specialNumbersAllowed
       */
      void allowSpecialNumbers(bool allowSpecialNumbers);

      /**
       * @returns whether special numbers (Infinity, -Infinity, NaN) are allowed
       * @sa allowSpecialNumbers
       */
      bool specialNumbersAllowed() const;

    private:
      Q_DISABLE_COPY(Parser)
      ParserPrivate* const d;
  };
  2021-07-23 19:59:14  [ main:563 ] - [ ERROR ]  warning: parse error class QJSON_EXPORT Parser
  {
    public:
      Parser();
      ~Parser();

      /**
      * Read JSON string from the I/O Device and converts it to a QVariant object
      * @param io Input output device
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true.
      * @returns a QVariant object generated from the JSON string
      */
      QVariant parse(QIODevice* io, bool* ok = 0);

      /**
      * This is a method provided for convenience.
      * @param jsonData data containing the JSON object representation
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true.
      * @returns a QVariant object generated from the JSON string
      * @sa errorString
      * @sa errorLine
      */
      QVariant parse(const QByteArray& jsonData, bool* ok = 0);

      /**
      * This method returns the error message
      * @returns a QString object containing the error message of the last parse operation
      * @sa errorLine
      */
      QString errorString() const;

      /**
      * This method returns line number where the error occurred
      * @returns the line number where the error occurred
      * @sa errorString
      */
      int errorLine() const;

      /**
       * Sets whether special numbers (Infinity, -Infinity, NaN) are allowed as an extension to
       * the standard
       * @param  allowSpecialNumbers new value of whether special numbers are allowed
       * @sa specialNumbersAllowed
       */
      void allowSpecialNumbers(bool allowSpecialNumbers);

      /**
       * @returns whether special numbers (Infinity, -Infinity, NaN) are allowed
       * @sa allowSpecialNumbers
       */
      bool specialNumbersAllowed() const;

    private:
      Q_DISABLE_COPY(Parser)
      ParserPrivate* const d;
  };Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\parser.h:41
  2021-07-23 19:59:14  [ main:580 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-23 19:59:14  [ main:580 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\networkmanager.hpp:11
  2021-07-23 19:59:14  [ main:581 ] - [ ERROR ]  parsing error 
signals:
    void replyReceived(const QVariantMap &reply);
  2021-07-23 19:59:14  [ main:581 ] - [ ERROR ]  warning: parse error signals:
    void replyReceived(const QVariantMap &reply);Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\networkmanager.hpp:29
  2021-07-23 19:59:14  [ main:581 ] - [ ERROR ]  parsing error 
private slots:
    void provideAuthentication(QNetworkReply *reply, QAuthenticator *authenticator);
  2021-07-23 19:59:14  [ main:581 ] - [ ERROR ]  warning: parse error private slots:
    void provideAuthentication(QNetworkReply *reply, QAuthenticator *authenticator);Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\networkmanager.hpp:35
  2021-07-23 19:59:14  [ main:585 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-23 19:59:14  [ main:586 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\networkmanagerproxy.hpp:10
  2021-07-23 19:59:14  [ main:586 ] - [ ERROR ]  parsing error 
private slots:
    void finished();
  2021-07-23 19:59:14  [ main:586 ] - [ ERROR ]  warning: parse error private slots:
    void finished();Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\networkmanagerproxy.hpp:25
  2021-07-23 19:59:14  [ main:590 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-23 19:59:14  [ main:590 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\page.hpp:19
  2021-07-23 19:59:14  [ main:591 ] - [ ERROR ]  parsing error 
private slots:
    void loadFinished(bool ok);
  2021-07-23 19:59:14  [ main:592 ] - [ ERROR ]  warning: parse error private slots:
    void loadFinished(bool ok);Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\page.hpp:57
  2021-07-23 19:59:14  [ main:595 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-23 19:59:14  [ main:595 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\eventprocessor.hpp:9
  2021-07-23 19:59:14  [ main:596 ] - [ ERROR ]  parsing error 
private slots:
    void handleTimeout();
  2021-07-23 19:59:14  [ main:596 ] - [ ERROR ]  warning: parse error private slots:
    void handleTimeout();Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\eventprocessor.hpp:23
  2021-07-23 19:59:14  [ main:600 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-23 19:59:14  [ main:600 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\webelement.hpp:11
  2021-07-23 19:59:14  [ main:602 ] - [ ERROR ]  parsing error 
private slots:
    void loadFinished(bool ok);
  2021-07-23 19:59:14  [ main:602 ] - [ ERROR ]  warning: parse error private slots:
    void loadFinished(bool ok);Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\webelement.hpp:69
  2021-07-23 19:59:14  [ main:605 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-23 19:59:14  [ main:606 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\webelementcollection.hpp:11
  2021-07-23 19:59:14  [ main:625 ] - [ ERROR ]  parsing error 
QT_BEGIN_NAMESPACE
  2021-07-23 19:59:14  [ main:625 ] - [ ERROR ]  warning: parse error QT_BEGIN_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializer.h:26
  2021-07-23 19:59:14  [ main:625 ] - [ ERROR ]  parsing error 
QT_END_NAMESPACE
  2021-07-23 19:59:14  [ main:625 ] - [ ERROR ]  warning: parse error QT_END_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializer.h:30
  2021-07-23 19:59:14  [ main:625 ] - [ ERROR ]  parsing error 
class QJSON_EXPORT Serializer {
  public:
    Serializer();
    ~Serializer();

     /**
      * This method generates a textual JSON representation and outputs it to the
      * passed in I/O Device.
      * @param variant The JSON document in its in-memory representation as generated by the
      * parser.
      * @param out Input output device
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true
      */
    void serialize( const QVariant& variant, QIODevice* out, bool* ok);

    /**
      * This is a method provided for convenience. It turns the passed in in-memory
      * representation of the JSON document into a textual one, which is returned.
      * If the returned string is empty, the document was empty. If it was null, there
      * was a parsing error.
      *
      * @param variant The JSON document in its in-memory representation as generated by the
      * parser.
      *
      * \deprecated This method is going to be removed with the next major release of QJson.
      */
    QByteArray serialize( const QVariant& variant);

    /**
      * This is a method provided for convenience. It turns the passed in in-memory
      * representation of the JSON document into a textual one, which is returned.
      * If the returned string is empty, the document was empty. If it was null, there
      * was a parsing error.
      *
      * @param variant The JSON document in its in-memory representation as generated by the
      * parser.
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true
      */
    QByteArray serialize( const QVariant& variant, bool *ok);

    /**
     * Allow or disallow writing of NaN and/or Infinity (as an extension to QJson)
     */
    void allowSpecialNumbers(bool allow);

    /**
     * Is Nan and/or Infinity allowed?
     */
    bool specialNumbersAllowed() const;

    /**
     * set output indentation mode as defined in QJson::IndentMode
     */
    void setIndentMode(IndentMode mode = QJson::IndentNone);


    /**
    * set double precision used while converting Double
    * \sa QByteArray::number
    */
    void setDoublePrecision(int precision);

    /**
     * Returns one of the indentation modes defined in QJson::IndentMode
     */
    IndentMode indentMode() const;

    /**
     * Returns the error message
     */
    QString errorMessage() const;

  private:
    Q_DISABLE_COPY(Serializer)
    class SerializerPrivate;
    SerializerPrivate* const d;
  };
  2021-07-23 19:59:14  [ main:625 ] - [ ERROR ]  warning: parse error class QJSON_EXPORT Serializer {
  public:
    Serializer();
    ~Serializer();

     /**
      * This method generates a textual JSON representation and outputs it to the
      * passed in I/O Device.
      * @param variant The JSON document in its in-memory representation as generated by the
      * parser.
      * @param out Input output device
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true
      */
    void serialize( const QVariant& variant, QIODevice* out, bool* ok);

    /**
      * This is a method provided for convenience. It turns the passed in in-memory
      * representation of the JSON document into a textual one, which is returned.
      * If the returned string is empty, the document was empty. If it was null, there
      * was a parsing error.
      *
      * @param variant The JSON document in its in-memory representation as generated by the
      * parser.
      *
      * \deprecated This method is going to be removed with the next major release of QJson.
      */
    QByteArray serialize( const QVariant& variant);

    /**
      * This is a method provided for convenience. It turns the passed in in-memory
      * representation of the JSON document into a textual one, which is returned.
      * If the returned string is empty, the document was empty. If it was null, there
      * was a parsing error.
      *
      * @param variant The JSON document in its in-memory representation as generated by the
      * parser.
      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true
      */
    QByteArray serialize( const QVariant& variant, bool *ok);

    /**
     * Allow or disallow writing of NaN and/or Infinity (as an extension to QJson)
     */
    void allowSpecialNumbers(bool allow);

    /**
     * Is Nan and/or Infinity allowed?
     */
    bool specialNumbersAllowed() const;

    /**
     * set output indentation mode as defined in QJson::IndentMode
     */
    void setIndentMode(IndentMode mode = QJson::IndentNone);


    /**
    * set double precision used while converting Double
    * \sa QByteArray::number
    */
    void setDoublePrecision(int precision);

    /**
     * Returns one of the indentation modes defined in QJson::IndentMode
     */
    IndentMode indentMode() const;

    /**
     * Returns the error message
     */
    QString errorMessage() const;

  private:
    Q_DISABLE_COPY(Serializer)
    class SerializerPrivate;
    SerializerPrivate* const d;
  };Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializer.h:112
  2021-07-23 19:59:14  [ main:629 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-23 19:59:14  [ main:630 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\cookiejar.hpp:14
  2021-07-23 19:59:14  [ main:693 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\phantompy.hpp
  2021-07-23 19:59:14  [ main:694 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\context.cpp
  2021-07-23 19:59:14  [ main:717 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\context.hpp
  2021-07-23 19:59:14  [ main:718 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\cookiejar.cpp
  2021-07-23 19:59:14  [ main:739 ] - [ ERROR ]  warning: parse error foreach(QNetworkCookie n_cookie, cookiesForUrl(QUrl(url))) {
        cookie["name"] = QString::fromUtf8(n_cookie.name());
        cookie["value"] = QString::fromUtf8(n_cookie.value());
        cookie["domain"] = n_cookie.domain();
        cookie["path"] = n_cookie.path();
        cookie["expires"] = n_cookie.expirationDate().toString(Qt::ISODate);

        cookiesList.append(cookie);
    }Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\cookiejar.cpp:112
  2021-07-23 19:59:14  [ main:740 ] - [ ERROR ]  warning: parse error foreach(QNetworkCookie n_cookie, allCookies()) {
        cookie["name"] = QString::fromUtf8(n_cookie.name());
        cookie["value"] = QString::fromUtf8(n_cookie.value());
        cookie["domain"] = n_cookie.domain();
        cookie["path"] = n_cookie.path();
        cookie["expires"] = n_cookie.expirationDate().toString(Qt::ISODate);

        cookiesList.append(cookie);
    }Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\cookiejar.cpp:129
  2021-07-23 19:59:14  [ main:741 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\cookiejar.hpp
  2021-07-23 19:59:14  [ main:742 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\eventprocessor.cpp
  2021-07-23 19:59:14  [ main:749 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\eventprocessor.hpp
  2021-07-23 19:59:14  [ main:750 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\frame.cpp
  2021-07-23 19:59:14  [ main:778 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\frame.hpp
  2021-07-23 19:59:14  [ main:778 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\image.cpp
  2021-07-23 19:59:14  [ main:784 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\image.hpp
  2021-07-23 19:59:14  [ main:785 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\networkmanager.cpp
  2021-07-23 19:59:14  [ main:793 ] - [ ERROR ]  parsing error 
Q_OBJECT
  2021-07-23 19:59:14  [ main:794 ] - [ ERROR ]  warning: parse error Q_OBJECTSyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\networktimeout.hpp:10
  2021-07-23 19:59:14  [ main:801 ] - [ ERROR ]  warning: parse error foreach (QByteArray headerName, reply->rawHeaderList()) {
        QVariantMap header;
        header["name"] = QString::fromUtf8(headerName);
        header["value"] = QString::fromUtf8(reply->rawHeader(headerName));

        headers.append(header);
    }Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\private\networkmanager.cpp:69
  2021-07-23 19:59:14  [ main:804 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\networkmanager.hpp
  2021-07-23 19:59:14  [ main:804 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\networkmanagerproxy.cpp
  2021-07-23 19:59:14  [ main:813 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\networkmanagerproxy.hpp
  2021-07-23 19:59:14  [ main:814 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\networktimeout.cpp
  2021-07-23 19:59:14  [ main:818 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\networktimeout.hpp
  2021-07-23 19:59:14  [ main:818 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\page.cpp
  2021-07-23 19:59:14  [ main:829 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\page.hpp
  2021-07-23 19:59:14  [ main:830 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\timeout.cpp
  2021-07-23 19:59:14  [ main:835 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\timeout.hpp
  2021-07-23 19:59:14  [ main:835 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\webelement.cpp
  2021-07-23 19:59:14  [ main:846 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\webelement.hpp
  2021-07-23 19:59:14  [ main:847 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\webelementcollection.cpp
  2021-07-23 19:59:14  [ main:852 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\private\webelementcollection.hpp
  2021-07-23 19:59:14  [ main:853 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\FlexLexer.h
  2021-07-23 19:59:14  [ main:867 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\json_parser.cc
  2021-07-23 19:59:14  [ main:962 ] - [ ERROR ]  parsing error 
Q_DECLARE_METATYPE(QVector<QVariant>*)
  Q_DECLARE_METATYPE(QVariantMap*)


/* Line 33 of lalr1.cc  */
#line 72 "json_parser.hh"


#include <string>
#include <iostream>
#include "stack.hh"
#include "location.hh"

/* Enabling traces.  */
#ifndef YYDEBUG
# define YYDEBUG 1
#endif


namespace yy {
/* Line 33 of lalr1.cc  */
#line 88 "json_parser.hh"

  /// A Bison parser.
  class json_parser
  {
  public:
    /// Symbol semantic values.
#ifndef YYSTYPE
    typedef int semantic_type;
#else
    typedef YYSTYPE semantic_type;
#endif
    /// Symbol locations.
    typedef location location_type;
    /// Tokens.
    struct token
    {
      /* Tokens.  */
   enum yytokentype {
     END = 0,
     CURLY_BRACKET_OPEN = 1,
     CURLY_BRACKET_CLOSE = 2,
     SQUARE_BRACKET_OPEN = 3,
     SQUARE_BRACKET_CLOSE = 4,
     COLON = 5,
     COMMA = 6,
     NUMBER = 7,
     TRUE_VAL = 8,
     FALSE_VAL = 9,
     NULL_VAL = 10,
     STRING = 11,
     INVALID = 12
   };

    };
    /// Token type.
    typedef token::yytokentype token_type;

    /// Build a parser object.
    json_parser (QJson::ParserPrivate* driver_yyarg);
    virtual ~json_parser ();

    /// Parse.
    /// \returns  0 iff parsing succeeded.
    virtual int parse ();

#if YYDEBUG
    /// The current debugging stream.
    std::ostream& debug_stream () const;
    /// Set the current debugging stream.
    void set_debug_stream (std::ostream &);

    /// Type for debugging levels.
    typedef int debug_level_type;
    /// The current debugging level.
    debug_level_type debug_level () const;
    /// Set the current debugging level.
    void set_debug_level (debug_level_type l);
#endif

  private:
    /// Report a syntax error.
    /// \param loc    where the syntax error is found.
    /// \param msg    a description of the syntax error.
    virtual void error (const location_type& loc, const std::string& msg);

    /// Generate an error message.
    /// \param state   the state where the error occurred.
    /// \param tok     the lookahead token.
    virtual std::string yysyntax_error_ (int yystate, int tok);

#if YYDEBUG
    /// \brief Report a symbol value on the debug stream.
    /// \param yytype       The token type.
    /// \param yyvaluep     Its semantic value.
    /// \param yylocationp  Its location.
    virtual void yy_symbol_value_print_ (int yytype,
					 const semantic_type* yyvaluep,
					 const location_type* yylocationp);
    /// \brief Report a symbol on the debug stream.
    /// \param yytype       The token type.
    /// \param yyvaluep     Its semantic value.
    /// \param yylocationp  Its location.
    virtual void yy_symbol_print_ (int yytype,
				   const semantic_type* yyvaluep,
				   const location_type* yylocationp);
#endif


    /// State numbers.
    typedef int state_type;
    /// State stack type.
    typedef stack<state_type>    state_stack_type;
    /// Semantic value stack type.
    typedef stack<semantic_type> semantic_stack_type;
    /// location stack type.
    typedef stack<location_type> location_stack_type;

    /// The state stack.
    state_stack_type yystate_stack_;
    /// The semantic value stack.
    semantic_stack_type yysemantic_stack_;
    /// The location stack.
    location_stack_type yylocation_stack_;

    /// Whether the given \c yypact_ value indicates a defaulted state.
    /// \param yyvalue   the value to check
    static bool yy_pact_value_is_default_ (int yyvalue);

    /// Whether the given \c yytable_ value indicates a syntax error.
    /// \param yyvalue   the value to check
    static bool yy_table_value_is_error_ (int yyvalue);

    /// Internal symbol numbers.
    typedef unsigned char token_number_type;
    /* Tables.  */
    /// For a state, the index in \a yytable_ of its portion.
    static const signed char yypact_[];
    static const signed char yypact_ninf_;

    /// For a state, default reduction number.
    /// Unless\a  yytable_ specifies something else to do.
    /// Zero means the default is an error.
    static const unsigned char yydefact_[];

    static const signed char yypgoto_[];
    static const signed char yydefgoto_[];

    /// What to do in a state.
    /// \a yytable_[yypact_[s]]: what to do in state \a s.
    /// - if positive, shift that token.
    /// - if negative, reduce the rule which number is the opposite.
    /// - if zero, do what YYDEFACT says.
    static const unsigned char yytable_[];
    static const signed char yytable_ninf_;

    static const signed char yycheck_[];

    /// For a state, its accessing symbol.
    static const unsigned char yystos_[];

    /// For a rule, its LHS.
    static const unsigned char yyr1_[];
    /// For a rule, its RHS length.
    static const unsigned char yyr2_[]; 

    /// Convert the symbol name \a n to a form suitable for a diagnostic.
    static std::string yytnamerr_ (const char *n);


    /// For a symbol, its name in clear.
    static const char* const yytname_[];
#if YYDEBUG
    /// A type to store symbol numbers and -1.
    typedef signed char rhs_number_type;
    /// A `-1'-separated list of the rules' RHS.
    static const rhs_number_type yyrhs_[];
    /// For each rule, the index of the first RHS symbol in \a yyrhs_.
    static const unsigned char yyprhs_[];
    /// For each rule, its source line number.
    static const unsigned char yyrline_[];
    /// For each scanner token number, its symbol number.
    static const unsigned short int yytoken_number_[];
    /// Report on the debug stream that the rule \a r is going to be reduced.
    virtual void yy_reduce_print_ (int r);
    /// Print the state stack on the debug stream.
    virtual void yystack_print_ ();

    /* Debugging.  */
    int yydebug_;
    std::ostream* yycdebug_;
#endif

    /// Convert a scanner token number \a t to a symbol number.
    token_number_type yytranslate_ (int t);

    /// \brief Reclaim the memory associated to a symbol.
    /// \param yymsg        Why this token is reclaimed.
    ///                     If null, do not display the symbol, just free it.
    /// \param yytype       The symbol type.
    /// \param yyvaluep     Its semantic value.
    /// \param yylocationp  Its location.
    inline void yydestruct_ (const char* yymsg,
			     int yytype,
			     semantic_type* yyvaluep,
			     location_type* yylocationp);

    /// Pop \a n symbols the three stacks.
    inline void yypop_ (unsigned int n = 1);

    /* Constants.  */
    static const int yyeof_;
    /* LAST_ -- Last index in TABLE_.  */
    static const int yylast_;
    static const int yynnts_;
    static const int yyempty_;
    static const int yyfinal_;
    static const int yyterror_;
    static const int yyerrcode_;
    static const int yyntokens_;
    static const unsigned int yyuser_token_number_max_;
    static const token_number_type yyundef_token_;

    /* User arguments.  */
    QJson::ParserPrivate* driver;
  };

}
  2021-07-23 19:59:14  [ main:962 ] - [ ERROR ]  warning: parse error Q_DECLARE_METATYPE(QVector<QVariant>*)
  Q_DECLARE_METATYPE(QVariantMap*)


/* Line 33 of lalr1.cc  */
#line 72 "json_parser.hh"


#include <string>
#include <iostream>
#include "stack.hh"
#include "location.hh"

/* Enabling traces.  */
#ifndef YYDEBUG
# define YYDEBUG 1
#endif


namespace yy {
/* Line 33 of lalr1.cc  */
#line 88 "json_parser.hh"

  /// A Bison parser.
  class json_parser
  {
  public:
    /// Symbol semantic values.
#ifndef YYSTYPE
    typedef int semantic_type;
#else
    typedef YYSTYPE semantic_type;
#endif
    /// Symbol locations.
    typedef location location_type;
    /// Tokens.
    struct token
    {
      /* Tokens.  */
   enum yytokentype {
     END = 0,
     CURLY_BRACKET_OPEN = 1,
     CURLY_BRACKET_CLOSE = 2,
     SQUARE_BRACKET_OPEN = 3,
     SQUARE_BRACKET_CLOSE = 4,
     COLON = 5,
     COMMA = 6,
     NUMBER = 7,
     TRUE_VAL = 8,
     FALSE_VAL = 9,
     NULL_VAL = 10,
     STRING = 11,
     INVALID = 12
   };

    };
    /// Token type.
    typedef token::yytokentype token_type;

    /// Build a parser object.
    json_parser (QJson::ParserPrivate* driver_yyarg);
    virtual ~json_parser ();

    /// Parse.
    /// \returns  0 iff parsing succeeded.
    virtual int parse ();

#if YYDEBUG
    /// The current debugging stream.
    std::ostream& debug_stream () const;
    /// Set the current debugging stream.
    void set_debug_stream (std::ostream &);

    /// Type for debugging levels.
    typedef int debug_level_type;
    /// The current debugging level.
    debug_level_type debug_level () const;
    /// Set the current debugging level.
    void set_debug_level (debug_level_type l);
#endif

  private:
    /// Report a syntax error.
    /// \param loc    where the syntax error is found.
    /// \param msg    a description of the syntax error.
    virtual void error (const location_type& loc, const std::string& msg);

    /// Generate an error message.
    /// \param state   the state where the error occurred.
    /// \param tok     the lookahead token.
    virtual std::string yysyntax_error_ (int yystate, int tok);

#if YYDEBUG
    /// \brief Report a symbol value on the debug stream.
    /// \param yytype       The token type.
    /// \param yyvaluep     Its semantic value.
    /// \param yylocationp  Its location.
    virtual void yy_symbol_value_print_ (int yytype,
					 const semantic_type* yyvaluep,
					 const location_type* yylocationp);
    /// \brief Report a symbol on the debug stream.
    /// \param yytype       The token type.
    /// \param yyvaluep     Its semantic value.
    /// \param yylocationp  Its location.
    virtual void yy_symbol_print_ (int yytype,
				   const semantic_type* yyvaluep,
				   const location_type* yylocationp);
#endif


    /// State numbers.
    typedef int state_type;
    /// State stack type.
    typedef stack<state_type>    state_stack_type;
    /// Semantic value stack type.
    typedef stack<semantic_type> semantic_stack_type;
    /// location stack type.
    typedef stack<location_type> location_stack_type;

    /// The state stack.
    state_stack_type yystate_stack_;
    /// The semantic value stack.
    semantic_stack_type yysemantic_stack_;
    /// The location stack.
    location_stack_type yylocation_stack_;

    /// Whether the given \c yypact_ value indicates a defaulted state.
    /// \param yyvalue   the value to check
    static bool yy_pact_value_is_default_ (int yyvalue);

    /// Whether the given \c yytable_ value indicates a syntax error.
    /// \param yyvalue   the value to check
    static bool yy_table_value_is_error_ (int yyvalue);

    /// Internal symbol numbers.
    typedef unsigned char token_number_type;
    /* Tables.  */
    /// For a state, the index in \a yytable_ of its portion.
    static const signed char yypact_[];
    static const signed char yypact_ninf_;

    /// For a state, default reduction number.
    /// Unless\a  yytable_ specifies something else to do.
    /// Zero means the default is an error.
    static const unsigned char yydefact_[];

    static const signed char yypgoto_[];
    static const signed char yydefgoto_[];

    /// What to do in a state.
    /// \a yytable_[yypact_[s]]: what to do in state \a s.
    /// - if positive, shift that token.
    /// - if negative, reduce the rule which number is the opposite.
    /// - if zero, do what YYDEFACT says.
    static const unsigned char yytable_[];
    static const signed char yytable_ninf_;

    static const signed char yycheck_[];

    /// For a state, its accessing symbol.
    static const unsigned char yystos_[];

    /// For a rule, its LHS.
    static const unsigned char yyr1_[];
    /// For a rule, its RHS length.
    static const unsigned char yyr2_[]; 

    /// Convert the symbol name \a n to a form suitable for a diagnostic.
    static std::string yytnamerr_ (const char *n);


    /// For a symbol, its name in clear.
    static const char* const yytname_[];
#if YYDEBUG
    /// A type to store symbol numbers and -1.
    typedef signed char rhs_number_type;
    /// A `-1'-separated list of the rules' RHS.
    static const rhs_number_type yyrhs_[];
    /// For each rule, the index of the first RHS symbol in \a yyrhs_.
    static const unsigned char yyprhs_[];
    /// For each rule, its source line number.
    static const unsigned char yyrline_[];
    /// For each scanner token number, its symbol number.
    static const unsigned short int yytoken_number_[];
    /// Report on the debug stream that the rule \a r is going to be reduced.
    virtual void yy_reduce_print_ (int r);
    /// Print the state stack on the debug stream.
    virtual void yystack_print_ ();

    /* Debugging.  */
    int yydebug_;
    std::ostream* yycdebug_;
#endif

    /// Convert a scanner token number \a t to a symbol number.
    token_number_type yytranslate_ (int t);

    /// \brief Reclaim the memory associated to a symbol.
    /// \param yymsg        Why this token is reclaimed.
    ///                     If null, do not display the symbol, just free it.
    /// \param yytype       The symbol type.
    /// \param yyvaluep     Its semantic value.
    /// \param yylocationp  Its location.
    inline void yydestruct_ (const char* yymsg,
			     int yytype,
			     semantic_type* yyvaluep,
			     location_type* yylocationp);

    /// Pop \a n symbols the three stacks.
    inline void yypop_ (unsigned int n = 1);

    /* Constants.  */
    static const int yyeof_;
    /* LAST_ -- Last index in TABLE_.  */
    static const int yylast_;
    static const int yynnts_;
    static const int yyempty_;
    static const int yyfinal_;
    static const int yyterror_;
    static const int yyerrcode_;
    static const int yyntokens_;
    static const unsigned int yyuser_token_number_max_;
    static const token_number_type yyundef_token_;

    /* User arguments.  */
    QJson::ParserPrivate* driver;
  };

}Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\json_parser.hh:66
  2021-07-23 19:59:14  [ main:1010 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\json_parser.hh
  2021-07-23 19:59:14  [ main:1010 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\json_scanner.cc
  2021-07-23 19:59:14  [ main:1431 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\json_scanner.cpp
  2021-07-23 19:59:14  [ main:1440 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\json_scanner.h
  2021-07-23 19:59:14  [ main:1441 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\location.hh
  2021-07-23 19:59:14  [ main:1441 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\parser.cpp
  2021-07-23 19:59:14  [ main:1454 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\parser.h
  2021-07-23 19:59:14  [ main:1455 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\parserrunnable.cpp
  2021-07-23 19:59:14  [ main:1464 ] - [ ERROR ]  parsing error 
QT_BEGIN_NAMESPACE
  2021-07-23 19:59:14  [ main:1464 ] - [ ERROR ]  warning: parse error QT_BEGIN_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\parserrunnable.h:29
  2021-07-23 19:59:14  [ main:1464 ] - [ ERROR ]  parsing error 
QT_END_NAMESPACE
  2021-07-23 19:59:14  [ main:1464 ] - [ ERROR ]  warning: parse error QT_END_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\parserrunnable.h:31
  2021-07-23 19:59:14  [ main:1464 ] - [ ERROR ]  parsing error 
class QJSON_EXPORT ParserRunnable  : public QObject, public QRunnable
  {
    Q_OBJECT
    public:
      explicit ParserRunnable(QObject* parent = 0);
      ~ParserRunnable();

      void setData( const QByteArray& data );

      void run();

    Q_SIGNALS:
      /**
      * This signal is emitted when the parsing process has been completed
      * @param json contains the result of the parsing
      * @param ok if a parsing error occurs ok is set to false, otherwise it's set to true.
      * @param error_msg contains a string explaining the failure reason
      **/
      void parsingFinished(const QVariant& json, bool ok, const QString& error_msg);

    private:
      Q_DISABLE_COPY(ParserRunnable)
      class Private;
      Private* const d;
  };
  2021-07-23 19:59:14  [ main:1465 ] - [ ERROR ]  warning: parse error class QJSON_EXPORT ParserRunnable  : public QObject, public QRunnable
  {
    Q_OBJECT
    public:
      explicit ParserRunnable(QObject* parent = 0);
      ~ParserRunnable();

      void setData( const QByteArray& data );

      void run();

    Q_SIGNALS:
      /**
      * This signal is emitted when the parsing process has been completed
      * @param json contains the result of the parsing
      * @param ok if a parsing error occurs ok is set to false, otherwise it's set to true.
      * @param error_msg contains a string explaining the failure reason
      **/
      void parsingFinished(const QVariant& json, bool ok, const QString& error_msg);

    private:
      Q_DISABLE_COPY(ParserRunnable)
      class Private;
      Private* const d;
  };Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\parserrunnable.h:37
  2021-07-23 19:59:14  [ main:1469 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\parserrunnable.h
  2021-07-23 19:59:14  [ main:1470 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\parser_p.h
  2021-07-23 19:59:14  [ main:1471 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\position.hh
  2021-07-23 19:59:14  [ main:1481 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\qjson_debug.h
  2021-07-23 19:59:14  [ main:1482 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\qjson_export.h
  2021-07-23 19:59:14  [ main:1482 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\qobjecthelper.cpp
  2021-07-23 19:59:14  [ main:1493 ] - [ ERROR ]  parsing error 
QT_BEGIN_NAMESPACE
  2021-07-23 19:59:14  [ main:1493 ] - [ ERROR ]  warning: parse error QT_BEGIN_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\qobjecthelper.h:30
  2021-07-23 19:59:14  [ main:1493 ] - [ ERROR ]  parsing error 
QT_END_NAMESPACE
  2021-07-23 19:59:14  [ main:1493 ] - [ ERROR ]  warning: parse error QT_END_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\qobjecthelper.h:32
  2021-07-23 19:59:14  [ main:1493 ] - [ ERROR ]  parsing error 
class QJSON_EXPORT QObjectHelper {
    public:
      QObjectHelper();
      ~QObjectHelper();

    /**
    * This method converts a QObject instance into a QVariantMap.
    *
    * @param object The QObject instance to be converted.
    * @param ignoredProperties Properties that won't be converted.
    */
    static QVariantMap qobject2qvariant( const QObject* object,
                                  const QStringList& ignoredProperties = QStringList(QString(QLatin1String("objectName"))));

    /**
    * This method converts a QVariantMap instance into a QObject
    *
    * @param variant Attributes to assign to the object.
    * @param object The QObject instance to update.
    */
    static void qvariant2qobject(const QVariantMap& variant, QObject* object);

    private:
      Q_DISABLE_COPY(QObjectHelper)
      class QObjectHelperPrivate;
      QObjectHelperPrivate* const d;
  };
  2021-07-23 19:59:14  [ main:1493 ] - [ ERROR ]  warning: parse error class QJSON_EXPORT QObjectHelper {
    public:
      QObjectHelper();
      ~QObjectHelper();

    /**
    * This method converts a QObject instance into a QVariantMap.
    *
    * @param object The QObject instance to be converted.
    * @param ignoredProperties Properties that won't be converted.
    */
    static QVariantMap qobject2qvariant( const QObject* object,
                                  const QStringList& ignoredProperties = QStringList(QString(QLatin1String("objectName"))));

    /**
    * This method converts a QVariantMap instance into a QObject
    *
    * @param variant Attributes to assign to the object.
    * @param object The QObject instance to update.
    */
    static void qvariant2qobject(const QVariantMap& variant, QObject* object);

    private:
      Q_DISABLE_COPY(QObjectHelper)
      class QObjectHelperPrivate;
      QObjectHelperPrivate* const d;
  };Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\qobjecthelper.h:118
  2021-07-23 19:59:14  [ main:1498 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\qobjecthelper.h
  2021-07-23 19:59:14  [ main:1499 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\serializer.cpp
  2021-07-23 19:59:14  [ main:1522 ] - [ ERROR ]  warning: parse error Q_FOREACH( const QByteArray& i, list ) {
    if ( !res.isEmpty() )
      res += sep;
    res += i;
  }Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializer.cpp:55
  2021-07-23 19:59:14  [ main:1523 ] - [ ERROR ]  warning: parse error Q_FOREACH( const QVariant& var, list )
    {
      indentLevel++;
      QByteArray serializedValue = serialize( var, ok, indentLevel);
      indentLevel--;
      if ( !*ok ) {
        break;
      }
      values << serializedValue;
    }Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializer.cpp:72
  2021-07-23 19:59:14  [ main:1535 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\serializer.h
  2021-07-23 19:59:14  [ main:1536 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\serializerrunnable.cpp
  2021-07-23 19:59:15  [ main:1548 ] - [ ERROR ]  parsing error 
QT_BEGIN_NAMESPACE
  2021-07-23 19:59:15  [ main:1549 ] - [ ERROR ]  warning: parse error QT_BEGIN_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializerrunnable.h:29
  2021-07-23 19:59:15  [ main:1549 ] - [ ERROR ]  parsing error 
QT_END_NAMESPACE
  2021-07-23 19:59:15  [ main:1549 ] - [ ERROR ]  warning: parse error QT_END_NAMESPACESyntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializerrunnable.h:33
  2021-07-23 19:59:15  [ main:1549 ] - [ ERROR ]  parsing error 
class QJSON_EXPORT SerializerRunnable  : public QObject, public QRunnable
  {
    Q_OBJECT
    public:
      explicit SerializerRunnable(QObject* parent = 0);
      ~SerializerRunnable();

      /**
       * Sets the json object to serialize.
       *
       * @param json QVariant containing the json representation to be serialized
       */
      void setJsonObject( const QVariant& json );

      /* reimp */ void run();

    Q_SIGNALS:
      /**
      * This signal is emitted when the serialization process has been completed
      * @param serialized contains the result of the serialization
      * @param ok if a serialization error occurs ok is set to false, otherwise it's set to true.
      * @param error_msg contains a string explaining the failure reason
      **/
      void parsingFinished(const QByteArray& serialized, bool ok, const QString& error_msg);

    private:
      Q_DISABLE_COPY(SerializerRunnable)
      class Private;
      Private* const d;
  };
  2021-07-23 19:59:15  [ main:1549 ] - [ ERROR ]  warning: parse error class QJSON_EXPORT SerializerRunnable  : public QObject, public QRunnable
  {
    Q_OBJECT
    public:
      explicit SerializerRunnable(QObject* parent = 0);
      ~SerializerRunnable();

      /**
       * Sets the json object to serialize.
       *
       * @param json QVariant containing the json representation to be serialized
       */
      void setJsonObject( const QVariant& json );

      /* reimp */ void run();

    Q_SIGNALS:
      /**
      * This signal is emitted when the serialization process has been completed
      * @param serialized contains the result of the serialization
      * @param ok if a serialization error occurs ok is set to false, otherwise it's set to true.
      * @param error_msg contains a string explaining the failure reason
      **/
      void parsingFinished(const QByteArray& serialized, bool ok, const QString& error_msg);

    private:
      Q_DISABLE_COPY(SerializerRunnable)
      class Private;
      Private* const d;
  };Syntax error in file: C:\Users\ding7\Desktop\phantompy\lib\qjson\serializerrunnable.h:39
  2021-07-23 19:59:15  [ main:1553 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\serializerrunnable.h
  2021-07-23 19:59:15  [ main:1553 ] - [ INFO ]  parseC:\Users\ding7\Desktop\phantompy\lib\qjson\stack.hh
  2021-07-23 19:59:15  [ main:1555 ] - [ INFO ]  start dependency
  2021-07-23 19:59:15  [ main:1651 ] - [ INFO ]  includenum:73
  2021-07-23 19:59:15  [ main:1651 ] - [ INFO ]  definenum:81
  2021-07-23 19:59:15  [ main:1651 ] - [ INFO ]  callnum:45
  2021-07-23 19:59:15  [ main:1652 ] - [ INFO ]  returnnum:159
  2021-07-23 19:59:15  [ main:1652 ] - [ INFO ]  parameternum:614
  2021-07-23 19:59:15  [ main:1652 ] - [ INFO ]  extendnum:1
  2021-07-23 19:59:15  [ main:1652 ] - [ INFO ]  overridenum:1
  2021-07-23 19:59:15  [ main:1771 ] - [ INFO ]  Process finish!
  